{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback } from 'react';\nimport { useTransaction } from '../context/TransactionContext';\nimport { useWalletContext } from '../context/WalletContext';\nimport { useNotification } from '../context/NotificationContext';\n\n/**\r\n * Hook for executing transactions with proper error handling and status tracking\r\n */\nconst useTransactions = () => {\n  _s();\n  const {\n    executeStrategy,\n    executeStrategyTransaction,\n    isExecuting\n  } = useTransaction();\n  const {\n    isConnected,\n    connectWallet\n  } = useWalletContext();\n  const {\n    showNotification\n  } = useNotification();\n  const [status, setStatus] = useState('idle'); // idle, preparing, executing, success, error\n  const [error, setError] = useState(null);\n  const [currentOperation, setCurrentOperation] = useState(null);\n  const [result, setResult] = useState(null);\n\n  // Execute a strategy with proper error handling\n  const executeAIStrategy = useCallback(async (operations, options = {}) => {\n    try {\n      if (!isConnected) {\n        await connectWallet();\n      }\n      setStatus('preparing');\n      setError(null);\n      setResult(null);\n\n      // Validate operations\n      if (!operations || operations.length === 0) {\n        throw new Error('No operations to execute');\n      }\n\n      // Execute the strategy\n      setStatus('executing');\n      const strategyResult = await executeStrategy(operations, options);\n      setStatus('success');\n      setResult(strategyResult);\n      return strategyResult;\n    } catch (err) {\n      console.error('Strategy execution error:', err);\n      setStatus('error');\n      setError(err.message || 'Failed to execute strategy');\n      showNotification(`Transaction failed: ${err.message}`, 'error');\n      throw err;\n    }\n  }, [isConnected, connectWallet, executeStrategy, showNotification]);\n\n  // Execute a single transaction with error handling\n  const executeSingleTransaction = useCallback(async transaction => {\n    try {\n      if (!isConnected) {\n        await connectWallet();\n      }\n      setStatus('preparing');\n      setError(null);\n      setResult(null);\n      setCurrentOperation(transaction);\n\n      // Execute the transaction\n      setStatus('executing');\n      const txResult = await executeStrategyTransaction(transaction);\n      setStatus('success');\n      setResult(txResult);\n      setCurrentOperation(null);\n      return txResult;\n    } catch (err) {\n      console.error('Transaction execution error:', err);\n      setStatus('error');\n      setError(err.message || 'Failed to execute transaction');\n      showNotification(`Transaction failed: ${err.message}`, 'error');\n      throw err;\n    }\n  }, [isConnected, connectWallet, executeStrategyTransaction, showNotification]);\n\n  // Reset state\n  const reset = useCallback(() => {\n    setStatus('idle');\n    setError(null);\n    setResult(null);\n    setCurrentOperation(null);\n  }, []);\n  return {\n    executeAIStrategy,\n    executeSingleTransaction,\n    status,\n    error,\n    isExecuting,\n    currentOperation,\n    result,\n    reset\n  };\n};\n_s(useTransactions, \"CqUdpNAfWbuYJR5uW4wDjemgGFA=\", false, function () {\n  return [useTransaction, useWalletContext, useNotification];\n});\nexport default useTransactions;","map":{"version":3,"names":["useState","useCallback","useTransaction","useWalletContext","useNotification","useTransactions","_s","executeStrategy","executeStrategyTransaction","isExecuting","isConnected","connectWallet","showNotification","status","setStatus","error","setError","currentOperation","setCurrentOperation","result","setResult","executeAIStrategy","operations","options","length","Error","strategyResult","err","console","message","executeSingleTransaction","transaction","txResult","reset"],"sources":["/home/ck/compoundefi/client/src/hooks/useTransactions.js"],"sourcesContent":["import { useState, useCallback } from 'react';\r\nimport { useTransaction } from '../context/TransactionContext';\r\nimport { useWalletContext } from '../context/WalletContext';\r\nimport { useNotification } from '../context/NotificationContext';\r\n\r\n/**\r\n * Hook for executing transactions with proper error handling and status tracking\r\n */\r\nconst useTransactions = () => {\r\n  const { executeStrategy, executeStrategyTransaction, isExecuting } = useTransaction();\r\n  const { isConnected, connectWallet } = useWalletContext();\r\n  const { showNotification } = useNotification();\r\n  const [status, setStatus] = useState('idle'); // idle, preparing, executing, success, error\r\n  const [error, setError] = useState(null);\r\n  const [currentOperation, setCurrentOperation] = useState(null);\r\n  const [result, setResult] = useState(null);\r\n\r\n  // Execute a strategy with proper error handling\r\n  const executeAIStrategy = useCallback(async (operations, options = {}) => {\r\n    try {\r\n      if (!isConnected) {\r\n        await connectWallet();\r\n      }\r\n\r\n      setStatus('preparing');\r\n      setError(null);\r\n      setResult(null);\r\n\r\n      // Validate operations\r\n      if (!operations || operations.length === 0) {\r\n        throw new Error('No operations to execute');\r\n      }\r\n\r\n      // Execute the strategy\r\n      setStatus('executing');\r\n      const strategyResult = await executeStrategy(operations, options);\r\n      \r\n      setStatus('success');\r\n      setResult(strategyResult);\r\n      \r\n      return strategyResult;\r\n    } catch (err) {\r\n      console.error('Strategy execution error:', err);\r\n      setStatus('error');\r\n      setError(err.message || 'Failed to execute strategy');\r\n      showNotification(`Transaction failed: ${err.message}`, 'error');\r\n      throw err;\r\n    }\r\n  }, [isConnected, connectWallet, executeStrategy, showNotification]);\r\n\r\n  // Execute a single transaction with error handling\r\n  const executeSingleTransaction = useCallback(async (transaction) => {\r\n    try {\r\n      if (!isConnected) {\r\n        await connectWallet();\r\n      }\r\n\r\n      setStatus('preparing');\r\n      setError(null);\r\n      setResult(null);\r\n      setCurrentOperation(transaction);\r\n\r\n      // Execute the transaction\r\n      setStatus('executing');\r\n      const txResult = await executeStrategyTransaction(transaction);\r\n      \r\n      setStatus('success');\r\n      setResult(txResult);\r\n      setCurrentOperation(null);\r\n      \r\n      return txResult;\r\n    } catch (err) {\r\n      console.error('Transaction execution error:', err);\r\n      setStatus('error');\r\n      setError(err.message || 'Failed to execute transaction');\r\n      showNotification(`Transaction failed: ${err.message}`, 'error');\r\n      throw err;\r\n    }\r\n  }, [isConnected, connectWallet, executeStrategyTransaction, showNotification]);\r\n\r\n  // Reset state\r\n  const reset = useCallback(() => {\r\n    setStatus('idle');\r\n    setError(null);\r\n    setResult(null);\r\n    setCurrentOperation(null);\r\n  }, []);\r\n\r\n  return {\r\n    executeAIStrategy,\r\n    executeSingleTransaction,\r\n    status,\r\n    error,\r\n    isExecuting,\r\n    currentOperation,\r\n    result,\r\n    reset\r\n  };\r\n};\r\n\r\nexport default useTransactions;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}