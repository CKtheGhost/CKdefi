{"ast":null,"code":"var _jsxFileName = \"/home/ck/compoundefi/client/src/context/TransactionContext.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useState, useContext, useCallback } from 'react';\nimport { useNotification } from './NotificationContext';\nimport { useWalletContext } from './WalletContext';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const TransactionContext = /*#__PURE__*/createContext();\nexport const TransactionProvider = ({\n  children\n}) => {\n  _s();\n  const [pendingTransactions, setPendingTransactions] = useState([]);\n  const [transactionHistory, setTransactionHistory] = useState([]);\n  const [isExecuting, setIsExecuting] = useState(false);\n  const {\n    showNotification\n  } = useNotification();\n  const {\n    executeTransaction,\n    isConnected,\n    address\n  } = useWalletContext();\n\n  // Add a transaction to the queue\n  const addTransaction = useCallback(transaction => {\n    setPendingTransactions(prev => [...prev, {\n      ...transaction,\n      id: Date.now(),\n      status: 'pending'\n    }]);\n    return Date.now(); // Return transaction ID\n  }, []);\n\n  // Execute a single transaction\n  const executeStrategyTransaction = useCallback(async transaction => {\n    if (!isConnected) {\n      throw new Error('Wallet not connected');\n    }\n    try {\n      setIsExecuting(true);\n\n      // Log transaction in history\n      const txHistoryEntry = {\n        id: transaction.id || Date.now(),\n        type: transaction.type,\n        protocol: transaction.protocol,\n        function: transaction.functionName,\n        amount: transaction.amount,\n        timestamp: Date.now(),\n        status: 'executing'\n      };\n      setTransactionHistory(prev => [txHistoryEntry, ...prev]);\n\n      // Execute the transaction through wallet\n      const result = await executeTransaction({\n        function: `${transaction.contractAddress}${transaction.functionName}`,\n        type_arguments: transaction.typeArguments || [],\n        arguments: [transaction.amount.toString()]\n      });\n\n      // Update transaction history\n      setTransactionHistory(prev => prev.map(tx => tx.id === txHistoryEntry.id ? {\n        ...tx,\n        status: 'success',\n        hash: result.hash,\n        blockHeight: result.blockHeight\n      } : tx));\n      return {\n        success: true,\n        hash: result.hash,\n        blockHeight: result.blockHeight\n      };\n    } catch (error) {\n      console.error('Transaction execution failed:', error);\n\n      // Update transaction history\n      setTransactionHistory(prev => prev.map(tx => tx.id === (transaction.id || Date.now()) ? {\n        ...tx,\n        status: 'failed',\n        error: error.message\n      } : tx));\n      throw error;\n    } finally {\n      setIsExecuting(false);\n    }\n  }, [isConnected, executeTransaction]);\n\n  // Execute a strategy (multiple transactions)\n  const executeStrategy = useCallback(async (operations, options = {}) => {\n    if (!isConnected) {\n      showNotification('Please connect your wallet to execute transactions', 'error');\n      throw new Error('Wallet not connected');\n    }\n    setIsExecuting(true);\n    try {\n      showNotification('Executing strategy...', 'info');\n      const results = {\n        success: true,\n        operations: [],\n        failedOperations: [],\n        startTime: Date.now()\n      };\n\n      // Execute operations sequentially\n      for (const operation of operations) {\n        try {\n          // Create transaction payload\n          const transaction = {\n            id: Date.now(),\n            protocol: operation.protocol,\n            type: operation.type,\n            functionName: operation.functionName || getDefaultFunctionName(operation.protocol, operation.type),\n            contractAddress: operation.contractAddress || getContractAddress(operation.protocol),\n            amount: Math.floor(parseFloat(operation.amount) * 100000000).toString(),\n            // Convert to octas\n            typeArguments: operation.typeArguments || []\n          };\n\n          // Execute transaction\n          const txResult = await executeStrategyTransaction(transaction);\n\n          // Add to successful operations\n          results.operations.push({\n            ...operation,\n            result: txResult,\n            status: 'success'\n          });\n          showNotification(`Successfully executed ${operation.type} on ${operation.protocol}`, 'success');\n\n          // Add delay between transactions\n          if (operations.indexOf(operation) < operations.length - 1) {\n            await new Promise(resolve => setTimeout(resolve, 1000));\n          }\n        } catch (error) {\n          console.error(`Operation failed: ${operation.type} on ${operation.protocol}`, error);\n\n          // Add to failed operations\n          results.failedOperations.push({\n            ...operation,\n            error: error.message,\n            status: 'failed'\n          });\n          showNotification(`Failed to execute ${operation.type} on ${operation.protocol}: ${error.message}`, 'error');\n          results.success = false;\n\n          // Continue with next operation instead of aborting everything\n        }\n      }\n\n      // Finalize results\n      results.endTime = Date.now();\n      results.duration = results.endTime - results.startTime;\n      results.totalOperations = operations.length;\n      results.successfulOperations = results.operations.length;\n\n      // Show final notification\n      showNotification(results.success ? `Strategy executed successfully! ${results.operations.length} operations completed.` : `Strategy execution completed with ${results.failedOperations.length} failures.`, results.success ? 'success' : 'warning');\n      return results;\n    } catch (error) {\n      showNotification(`Strategy execution failed: ${error.message}`, 'error');\n      throw error;\n    } finally {\n      setIsExecuting(false);\n    }\n  }, [isConnected, executeStrategyTransaction, showNotification]);\n\n  // Get transaction history for the connected wallet\n  const getTransactionHistory = useCallback(() => {\n    return transactionHistory;\n  }, [transactionHistory]);\n\n  // Helper functions for operation execution\n  const getDefaultFunctionName = (protocol, operationType) => {\n    var _functionMappings$pro;\n    protocol = protocol.toLowerCase();\n    operationType = operationType.toLowerCase();\n    const functionMappings = {\n      'amnis': {\n        'stake': '::staking::stake',\n        'unstake': '::staking::unstake',\n        'lend': '::lending::supply',\n        'withdraw': '::lending::withdraw',\n        'addLiquidity': '::router::add_liquidity',\n        'removeLiquidity': '::router::remove_liquidity'\n      },\n      'thala': {\n        'stake': '::staking::stake_apt',\n        'unstake': '::staking::unstake_apt',\n        'lend': '::lending::supply_apt',\n        'withdraw': '::lending::withdraw_apt',\n        'addLiquidity': '::router::add_liquidity',\n        'removeLiquidity': '::router::remove_liquidity'\n      },\n      'tortuga': {\n        'stake': '::staking::stake_apt',\n        'unstake': '::staking::unstake_apt'\n      },\n      'ditto': {\n        'stake': '::staking::stake',\n        'unstake': '::staking::unstake'\n      }\n    };\n    if ((_functionMappings$pro = functionMappings[protocol]) !== null && _functionMappings$pro !== void 0 && _functionMappings$pro[operationType]) {\n      return functionMappings[protocol][operationType];\n    }\n\n    // Default mappings\n    switch (operationType) {\n      case 'stake':\n        return '::staking::stake';\n      case 'unstake':\n        return '::staking::unstake';\n      case 'lend':\n        return '::lending::supply';\n      case 'withdraw':\n        return '::lending::withdraw';\n      case 'addLiquidity':\n        return '::router::add_liquidity';\n      case 'removeLiquidity':\n        return '::router::remove_liquidity';\n      default:\n        return `::${operationType}::execute`;\n    }\n  };\n  const getContractAddress = protocol => {\n    // Contract addresses should ideally come from a configuration file\n    const contractAddresses = {\n      'amnis': '0x111ae3e5bc816a5e63c2da97d0aa3886519e0cd5e4b046659fa35796bd11542a',\n      'thala': '0xfaf4e633ae9eb31366c9ca24214231760926576c7b625313b3688b5e900731f6',\n      'tortuga': '0x952c1b1fc8eb75ee80f432c9d0a84fcda1d5c7481501a7eca9199f1596a60b53',\n      'ditto': '0xd11107bdf0d6d7040c6c0bfbdecb6545191fdf13e8d8d259952f53e1713f61b5'\n    };\n    return contractAddresses[protocol.toLowerCase()] || '';\n  };\n  return /*#__PURE__*/_jsxDEV(TransactionContext.Provider, {\n    value: {\n      pendingTransactions,\n      transactionHistory,\n      isExecuting,\n      addTransaction,\n      executeStrategyTransaction,\n      executeStrategy,\n      getTransactionHistory\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 233,\n    columnNumber: 5\n  }, this);\n};\n\n// Custom hook to use the transaction context\n_s(TransactionProvider, \"HfHbWvgj69MCkZY+J24q8fQ70wk=\", false, function () {\n  return [useNotification, useWalletContext];\n});\n_c = TransactionProvider;\nexport const useTransaction = () => {\n  _s2();\n  return useContext(TransactionContext);\n};\n_s2(useTransaction, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar _c;\n$RefreshReg$(_c, \"TransactionProvider\");","map":{"version":3,"names":["React","createContext","useState","useContext","useCallback","useNotification","useWalletContext","jsxDEV","_jsxDEV","TransactionContext","TransactionProvider","children","_s","pendingTransactions","setPendingTransactions","transactionHistory","setTransactionHistory","isExecuting","setIsExecuting","showNotification","executeTransaction","isConnected","address","addTransaction","transaction","prev","id","Date","now","status","executeStrategyTransaction","Error","txHistoryEntry","type","protocol","function","functionName","amount","timestamp","result","contractAddress","type_arguments","typeArguments","arguments","toString","map","tx","hash","blockHeight","success","error","console","message","executeStrategy","operations","options","results","failedOperations","startTime","operation","getDefaultFunctionName","getContractAddress","Math","floor","parseFloat","txResult","push","indexOf","length","Promise","resolve","setTimeout","endTime","duration","totalOperations","successfulOperations","getTransactionHistory","operationType","_functionMappings$pro","toLowerCase","functionMappings","contractAddresses","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useTransaction","_s2","$RefreshReg$"],"sources":["/home/ck/compoundefi/client/src/context/TransactionContext.jsx"],"sourcesContent":["import React, { createContext, useState, useContext, useCallback } from 'react';\r\nimport { useNotification } from './NotificationContext';\r\nimport { useWalletContext } from './WalletContext';\r\n\r\nexport const TransactionContext = createContext();\r\n\r\nexport const TransactionProvider = ({ children }) => {\r\n  const [pendingTransactions, setPendingTransactions] = useState([]);\r\n  const [transactionHistory, setTransactionHistory] = useState([]);\r\n  const [isExecuting, setIsExecuting] = useState(false);\r\n  const { showNotification } = useNotification();\r\n  const { executeTransaction, isConnected, address } = useWalletContext();\r\n\r\n  // Add a transaction to the queue\r\n  const addTransaction = useCallback((transaction) => {\r\n    setPendingTransactions(prev => [...prev, { ...transaction, id: Date.now(), status: 'pending' }]);\r\n    return Date.now(); // Return transaction ID\r\n  }, []);\r\n\r\n  // Execute a single transaction\r\n  const executeStrategyTransaction = useCallback(async (transaction) => {\r\n    if (!isConnected) {\r\n      throw new Error('Wallet not connected');\r\n    }\r\n\r\n    try {\r\n      setIsExecuting(true);\r\n      \r\n      // Log transaction in history\r\n      const txHistoryEntry = {\r\n        id: transaction.id || Date.now(),\r\n        type: transaction.type,\r\n        protocol: transaction.protocol,\r\n        function: transaction.functionName,\r\n        amount: transaction.amount,\r\n        timestamp: Date.now(),\r\n        status: 'executing'\r\n      };\r\n      \r\n      setTransactionHistory(prev => [txHistoryEntry, ...prev]);\r\n      \r\n      // Execute the transaction through wallet\r\n      const result = await executeTransaction({\r\n        function: `${transaction.contractAddress}${transaction.functionName}`,\r\n        type_arguments: transaction.typeArguments || [],\r\n        arguments: [transaction.amount.toString()]\r\n      });\r\n      \r\n      // Update transaction history\r\n      setTransactionHistory(prev => \r\n        prev.map(tx => \r\n          tx.id === txHistoryEntry.id \r\n            ? { ...tx, status: 'success', hash: result.hash, blockHeight: result.blockHeight } \r\n            : tx\r\n        )\r\n      );\r\n      \r\n      return { success: true, hash: result.hash, blockHeight: result.blockHeight };\r\n    } catch (error) {\r\n      console.error('Transaction execution failed:', error);\r\n      \r\n      // Update transaction history\r\n      setTransactionHistory(prev => \r\n        prev.map(tx => \r\n          tx.id === (transaction.id || Date.now())\r\n            ? { ...tx, status: 'failed', error: error.message } \r\n            : tx\r\n        )\r\n      );\r\n      \r\n      throw error;\r\n    } finally {\r\n      setIsExecuting(false);\r\n    }\r\n  }, [isConnected, executeTransaction]);\r\n\r\n  // Execute a strategy (multiple transactions)\r\n  const executeStrategy = useCallback(async (operations, options = {}) => {\r\n    if (!isConnected) {\r\n      showNotification('Please connect your wallet to execute transactions', 'error');\r\n      throw new Error('Wallet not connected');\r\n    }\r\n    \r\n    setIsExecuting(true);\r\n    \r\n    try {\r\n      showNotification('Executing strategy...', 'info');\r\n      \r\n      const results = {\r\n        success: true,\r\n        operations: [],\r\n        failedOperations: [],\r\n        startTime: Date.now()\r\n      };\r\n      \r\n      // Execute operations sequentially\r\n      for (const operation of operations) {\r\n        try {\r\n          // Create transaction payload\r\n          const transaction = {\r\n            id: Date.now(),\r\n            protocol: operation.protocol,\r\n            type: operation.type,\r\n            functionName: operation.functionName || getDefaultFunctionName(operation.protocol, operation.type),\r\n            contractAddress: operation.contractAddress || getContractAddress(operation.protocol),\r\n            amount: Math.floor(parseFloat(operation.amount) * 100000000).toString(), // Convert to octas\r\n            typeArguments: operation.typeArguments || []\r\n          };\r\n          \r\n          // Execute transaction\r\n          const txResult = await executeStrategyTransaction(transaction);\r\n          \r\n          // Add to successful operations\r\n          results.operations.push({\r\n            ...operation,\r\n            result: txResult,\r\n            status: 'success'\r\n          });\r\n          \r\n          showNotification(`Successfully executed ${operation.type} on ${operation.protocol}`, 'success');\r\n          \r\n          // Add delay between transactions\r\n          if (operations.indexOf(operation) < operations.length - 1) {\r\n            await new Promise(resolve => setTimeout(resolve, 1000));\r\n          }\r\n        } catch (error) {\r\n          console.error(`Operation failed: ${operation.type} on ${operation.protocol}`, error);\r\n          \r\n          // Add to failed operations\r\n          results.failedOperations.push({\r\n            ...operation,\r\n            error: error.message,\r\n            status: 'failed'\r\n          });\r\n          \r\n          showNotification(`Failed to execute ${operation.type} on ${operation.protocol}: ${error.message}`, 'error');\r\n          \r\n          results.success = false;\r\n          \r\n          // Continue with next operation instead of aborting everything\r\n        }\r\n      }\r\n      \r\n      // Finalize results\r\n      results.endTime = Date.now();\r\n      results.duration = results.endTime - results.startTime;\r\n      results.totalOperations = operations.length;\r\n      results.successfulOperations = results.operations.length;\r\n      \r\n      // Show final notification\r\n      showNotification(\r\n        results.success \r\n          ? `Strategy executed successfully! ${results.operations.length} operations completed.` \r\n          : `Strategy execution completed with ${results.failedOperations.length} failures.`,\r\n        results.success ? 'success' : 'warning'\r\n      );\r\n      \r\n      return results;\r\n    } catch (error) {\r\n      showNotification(`Strategy execution failed: ${error.message}`, 'error');\r\n      throw error;\r\n    } finally {\r\n      setIsExecuting(false);\r\n    }\r\n  }, [isConnected, executeStrategyTransaction, showNotification]);\r\n\r\n  // Get transaction history for the connected wallet\r\n  const getTransactionHistory = useCallback(() => {\r\n    return transactionHistory;\r\n  }, [transactionHistory]);\r\n\r\n  // Helper functions for operation execution\r\n  const getDefaultFunctionName = (protocol, operationType) => {\r\n    protocol = protocol.toLowerCase();\r\n    operationType = operationType.toLowerCase();\r\n    \r\n    const functionMappings = {\r\n      'amnis': { \r\n        'stake': '::staking::stake', \r\n        'unstake': '::staking::unstake', \r\n        'lend': '::lending::supply', \r\n        'withdraw': '::lending::withdraw', \r\n        'addLiquidity': '::router::add_liquidity', \r\n        'removeLiquidity': '::router::remove_liquidity' \r\n      },\r\n      'thala': { \r\n        'stake': '::staking::stake_apt', \r\n        'unstake': '::staking::unstake_apt', \r\n        'lend': '::lending::supply_apt', \r\n        'withdraw': '::lending::withdraw_apt', \r\n        'addLiquidity': '::router::add_liquidity', \r\n        'removeLiquidity': '::router::remove_liquidity' \r\n      },\r\n      'tortuga': { \r\n        'stake': '::staking::stake_apt', \r\n        'unstake': '::staking::unstake_apt' \r\n      },\r\n      'ditto': { \r\n        'stake': '::staking::stake', \r\n        'unstake': '::staking::unstake' \r\n      }\r\n    };\r\n    \r\n    if (functionMappings[protocol]?.[operationType]) {\r\n      return functionMappings[protocol][operationType];\r\n    }\r\n    \r\n    // Default mappings\r\n    switch (operationType) {\r\n      case 'stake': return '::staking::stake';\r\n      case 'unstake': return '::staking::unstake';\r\n      case 'lend': return '::lending::supply';\r\n      case 'withdraw': return '::lending::withdraw';\r\n      case 'addLiquidity': return '::router::add_liquidity';\r\n      case 'removeLiquidity': return '::router::remove_liquidity';\r\n      default: return `::${operationType}::execute`;\r\n    }\r\n  };\r\n  \r\n  const getContractAddress = (protocol) => {\r\n    // Contract addresses should ideally come from a configuration file\r\n    const contractAddresses = {\r\n      'amnis': '0x111ae3e5bc816a5e63c2da97d0aa3886519e0cd5e4b046659fa35796bd11542a',\r\n      'thala': '0xfaf4e633ae9eb31366c9ca24214231760926576c7b625313b3688b5e900731f6',\r\n      'tortuga': '0x952c1b1fc8eb75ee80f432c9d0a84fcda1d5c7481501a7eca9199f1596a60b53',\r\n      'ditto': '0xd11107bdf0d6d7040c6c0bfbdecb6545191fdf13e8d8d259952f53e1713f61b5'\r\n    };\r\n    \r\n    return contractAddresses[protocol.toLowerCase()] || '';\r\n  };\r\n\r\n  return (\r\n    <TransactionContext.Provider value={{\r\n      pendingTransactions,\r\n      transactionHistory,\r\n      isExecuting,\r\n      addTransaction,\r\n      executeStrategyTransaction,\r\n      executeStrategy,\r\n      getTransactionHistory\r\n    }}>\r\n      {children}\r\n    </TransactionContext.Provider>\r\n  );\r\n};\r\n\r\n// Custom hook to use the transaction context\r\nexport const useTransaction = () => useContext(TransactionContext);"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}