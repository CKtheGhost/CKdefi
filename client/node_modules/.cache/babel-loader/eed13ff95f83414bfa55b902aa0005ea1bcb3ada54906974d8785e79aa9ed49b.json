{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--) if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\n\n// src/client/types.ts\nvar AptosApiError = class extends Error {\n  constructor(request2, response, message) {\n    super(message);\n    this.name = \"AptosApiError\";\n    this.url = response.url;\n    this.status = response.status;\n    this.statusText = response.statusText;\n    this.data = response.data;\n    this.request = request2;\n  }\n};\n\n// src/version.ts\nvar VERSION = \"2.0.0\";\n\n// src/types/index.ts\nvar MimeType = /* @__PURE__ */(MimeType2 => {\n  MimeType2[\"JSON\"] = \"application/json\";\n  MimeType2[\"BCS\"] = \"application/x-bcs\";\n  MimeType2[\"BCS_SIGNED_TRANSACTION\"] = \"application/x.aptos.signed_transaction+bcs\";\n  return MimeType2;\n})(MimeType || {});\nvar TypeTagVariants = /* @__PURE__ */(TypeTagVariants2 => {\n  TypeTagVariants2[TypeTagVariants2[\"Bool\"] = 0] = \"Bool\";\n  TypeTagVariants2[TypeTagVariants2[\"U8\"] = 1] = \"U8\";\n  TypeTagVariants2[TypeTagVariants2[\"U64\"] = 2] = \"U64\";\n  TypeTagVariants2[TypeTagVariants2[\"U128\"] = 3] = \"U128\";\n  TypeTagVariants2[TypeTagVariants2[\"Address\"] = 4] = \"Address\";\n  TypeTagVariants2[TypeTagVariants2[\"Signer\"] = 5] = \"Signer\";\n  TypeTagVariants2[TypeTagVariants2[\"Vector\"] = 6] = \"Vector\";\n  TypeTagVariants2[TypeTagVariants2[\"Struct\"] = 7] = \"Struct\";\n  TypeTagVariants2[TypeTagVariants2[\"U16\"] = 8] = \"U16\";\n  TypeTagVariants2[TypeTagVariants2[\"U32\"] = 9] = \"U32\";\n  TypeTagVariants2[TypeTagVariants2[\"U256\"] = 10] = \"U256\";\n  TypeTagVariants2[TypeTagVariants2[\"Reference\"] = 254] = \"Reference\";\n  TypeTagVariants2[TypeTagVariants2[\"Generic\"] = 255] = \"Generic\";\n  return TypeTagVariants2;\n})(TypeTagVariants || {});\nvar ScriptTransactionArgumentVariants = /* @__PURE__ */(ScriptTransactionArgumentVariants2 => {\n  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2[\"U8\"] = 0] = \"U8\";\n  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2[\"U64\"] = 1] = \"U64\";\n  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2[\"U128\"] = 2] = \"U128\";\n  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2[\"Address\"] = 3] = \"Address\";\n  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2[\"U8Vector\"] = 4] = \"U8Vector\";\n  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2[\"Bool\"] = 5] = \"Bool\";\n  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2[\"U16\"] = 6] = \"U16\";\n  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2[\"U32\"] = 7] = \"U32\";\n  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2[\"U256\"] = 8] = \"U256\";\n  return ScriptTransactionArgumentVariants2;\n})(ScriptTransactionArgumentVariants || {});\nvar TransactionPayloadVariants = /* @__PURE__ */(TransactionPayloadVariants2 => {\n  TransactionPayloadVariants2[TransactionPayloadVariants2[\"Script\"] = 0] = \"Script\";\n  TransactionPayloadVariants2[TransactionPayloadVariants2[\"EntryFunction\"] = 2] = \"EntryFunction\";\n  TransactionPayloadVariants2[TransactionPayloadVariants2[\"Multisig\"] = 3] = \"Multisig\";\n  return TransactionPayloadVariants2;\n})(TransactionPayloadVariants || {});\nvar TransactionVariants = /* @__PURE__ */(TransactionVariants2 => {\n  TransactionVariants2[TransactionVariants2[\"MultiAgentTransaction\"] = 0] = \"MultiAgentTransaction\";\n  TransactionVariants2[TransactionVariants2[\"FeePayerTransaction\"] = 1] = \"FeePayerTransaction\";\n  return TransactionVariants2;\n})(TransactionVariants || {});\nvar TransactionAuthenticatorVariant = /* @__PURE__ */(TransactionAuthenticatorVariant2 => {\n  TransactionAuthenticatorVariant2[TransactionAuthenticatorVariant2[\"Ed25519\"] = 0] = \"Ed25519\";\n  TransactionAuthenticatorVariant2[TransactionAuthenticatorVariant2[\"MultiEd25519\"] = 1] = \"MultiEd25519\";\n  TransactionAuthenticatorVariant2[TransactionAuthenticatorVariant2[\"MultiAgent\"] = 2] = \"MultiAgent\";\n  TransactionAuthenticatorVariant2[TransactionAuthenticatorVariant2[\"FeePayer\"] = 3] = \"FeePayer\";\n  TransactionAuthenticatorVariant2[TransactionAuthenticatorVariant2[\"SingleSender\"] = 4] = \"SingleSender\";\n  return TransactionAuthenticatorVariant2;\n})(TransactionAuthenticatorVariant || {});\nvar AccountAuthenticatorVariant = /* @__PURE__ */(AccountAuthenticatorVariant2 => {\n  AccountAuthenticatorVariant2[AccountAuthenticatorVariant2[\"Ed25519\"] = 0] = \"Ed25519\";\n  AccountAuthenticatorVariant2[AccountAuthenticatorVariant2[\"MultiEd25519\"] = 1] = \"MultiEd25519\";\n  AccountAuthenticatorVariant2[AccountAuthenticatorVariant2[\"SingleKey\"] = 2] = \"SingleKey\";\n  AccountAuthenticatorVariant2[AccountAuthenticatorVariant2[\"MultiKey\"] = 3] = \"MultiKey\";\n  return AccountAuthenticatorVariant2;\n})(AccountAuthenticatorVariant || {});\nvar AnyPublicKeyVariant = /* @__PURE__ */(AnyPublicKeyVariant2 => {\n  AnyPublicKeyVariant2[AnyPublicKeyVariant2[\"Ed25519\"] = 0] = \"Ed25519\";\n  AnyPublicKeyVariant2[AnyPublicKeyVariant2[\"Secp256k1\"] = 1] = \"Secp256k1\";\n  return AnyPublicKeyVariant2;\n})(AnyPublicKeyVariant || {});\nvar AnySignatureVariant = /* @__PURE__ */(AnySignatureVariant2 => {\n  AnySignatureVariant2[AnySignatureVariant2[\"Ed25519\"] = 0] = \"Ed25519\";\n  AnySignatureVariant2[AnySignatureVariant2[\"Secp256k1\"] = 1] = \"Secp256k1\";\n  return AnySignatureVariant2;\n})(AnySignatureVariant || {});\nvar TransactionResponseType = /* @__PURE__ */(TransactionResponseType2 => {\n  TransactionResponseType2[\"Pending\"] = \"pending_transaction\";\n  TransactionResponseType2[\"User\"] = \"user_transaction\";\n  TransactionResponseType2[\"Genesis\"] = \"genesis_transaction\";\n  TransactionResponseType2[\"BlockMetadata\"] = \"block_metadata_transaction\";\n  TransactionResponseType2[\"StateCheckpoint\"] = \"state_checkpoint_transaction\";\n  return TransactionResponseType2;\n})(TransactionResponseType || {});\nvar MoveFunctionVisibility = /* @__PURE__ */(MoveFunctionVisibility2 => {\n  MoveFunctionVisibility2[\"PRIVATE\"] = \"private\";\n  MoveFunctionVisibility2[\"PUBLIC\"] = \"public\";\n  MoveFunctionVisibility2[\"FRIEND\"] = \"friend\";\n  return MoveFunctionVisibility2;\n})(MoveFunctionVisibility || {});\nvar MoveAbility = /* @__PURE__ */(MoveAbility2 => {\n  MoveAbility2[\"STORE\"] = \"store\";\n  MoveAbility2[\"DROP\"] = \"drop\";\n  MoveAbility2[\"KEY\"] = \"key\";\n  MoveAbility2[\"COPY\"] = \"copy\";\n  return MoveAbility2;\n})(MoveAbility || {});\nvar RoleType = /* @__PURE__ */(RoleType2 => {\n  RoleType2[\"VALIDATOR\"] = \"validator\";\n  RoleType2[\"FULL_NODE\"] = \"full_node\";\n  return RoleType2;\n})(RoleType || {});\nvar SigningScheme = /* @__PURE__ */(SigningScheme2 => {\n  SigningScheme2[SigningScheme2[\"Ed25519\"] = 0] = \"Ed25519\";\n  SigningScheme2[SigningScheme2[\"MultiEd25519\"] = 1] = \"MultiEd25519\";\n  SigningScheme2[SigningScheme2[\"SingleKey\"] = 2] = \"SingleKey\";\n  SigningScheme2[SigningScheme2[\"MultiKey\"] = 3] = \"MultiKey\";\n  return SigningScheme2;\n})(SigningScheme || {});\nvar SigningSchemeInput = /* @__PURE__ */(SigningSchemeInput2 => {\n  SigningSchemeInput2[SigningSchemeInput2[\"Ed25519\"] = 0] = \"Ed25519\";\n  SigningSchemeInput2[SigningSchemeInput2[\"Secp256k1Ecdsa\"] = 2] = \"Secp256k1Ecdsa\";\n  return SigningSchemeInput2;\n})(SigningSchemeInput || {});\nvar DeriveScheme = /* @__PURE__ */(DeriveScheme2 => {\n  DeriveScheme2[DeriveScheme2[\"DeriveAuid\"] = 251] = \"DeriveAuid\";\n  DeriveScheme2[DeriveScheme2[\"DeriveObjectAddressFromObject\"] = 252] = \"DeriveObjectAddressFromObject\";\n  DeriveScheme2[DeriveScheme2[\"DeriveObjectAddressFromGuid\"] = 253] = \"DeriveObjectAddressFromGuid\";\n  DeriveScheme2[DeriveScheme2[\"DeriveObjectAddressFromSeed\"] = 254] = \"DeriveObjectAddressFromSeed\";\n  DeriveScheme2[DeriveScheme2[\"DeriveResourceAccountAddress\"] = 255] = \"DeriveResourceAccountAddress\";\n  return DeriveScheme2;\n})(DeriveScheme || {});\n\n// src/client/core.ts\nvar errors = {\n  400: \"Bad Request\",\n  401: \"Unauthorized\",\n  403: \"Forbidden\",\n  404: \"Not Found\",\n  429: \"Too Many Requests\",\n  500: \"Internal Server Error\",\n  502: \"Bad Gateway\",\n  503: \"Service Unavailable\"\n};\nasync function request(options, client) {\n  const {\n    url,\n    method,\n    body,\n    contentType,\n    params,\n    overrides\n  } = options;\n  const headers = {\n    ...(overrides == null ? void 0 : overrides.HEADERS),\n    \"x-aptos-client\": `aptos-ts-sdk/${VERSION}`,\n    \"content-type\": contentType != null ? contentType : \"application/json\" /* JSON */\n  };\n  if (overrides == null ? void 0 : overrides.TOKEN) {\n    headers.Authorization = `Bearer ${overrides == null ? void 0 : overrides.TOKEN}`;\n  }\n  return client.provider({\n    url,\n    method,\n    body,\n    params,\n    headers,\n    overrides\n  });\n}\nasync function aptosRequest(options, aptosConfig) {\n  var _a;\n  const {\n    url,\n    path\n  } = options;\n  const fullUrl = `${url}/${path != null ? path : \"\"}`;\n  const response = await request({\n    ...options,\n    url: fullUrl\n  }, aptosConfig.client);\n  const result = {\n    status: response.status,\n    statusText: response.statusText,\n    data: response.data,\n    headers: response.headers,\n    config: response.config,\n    request: response.request,\n    url: fullUrl\n  };\n  if (aptosConfig.isIndexerRequest(url)) {\n    const indexerResponse = result.data;\n    if (indexerResponse.errors) {\n      throw new AptosApiError(options, result, (_a = indexerResponse.errors[0].message) != null ? _a : `Unhandled Error ${response.status} : ${response.statusText}`);\n    }\n    result.data = indexerResponse.data;\n  }\n  if (result.status >= 200 && result.status < 300) {\n    return result;\n  }\n  const errorMessage = errors[result.status];\n  throw new AptosApiError(options, result, errorMessage != null ? errorMessage : `Unhandled Error ${response.status} : ${response.statusText}`);\n}\n\n// src/utils/apiEndpoints.ts\nvar NetworkToIndexerAPI = {\n  mainnet: \"https://indexer.mainnet.aptoslabs.com/v1/graphql\",\n  testnet: \"https://indexer-testnet.staging.gcp.aptosdev.com/v1/graphql\",\n  devnet: \"https://indexer-devnet.staging.gcp.aptosdev.com/v1/graphql\",\n  local: \"http://127.0.0.1:8090/v1/graphql\"\n};\nvar NetworkToNodeAPI = {\n  mainnet: \"https://fullnode.mainnet.aptoslabs.com/v1\",\n  testnet: \"https://fullnode.testnet.aptoslabs.com/v1\",\n  devnet: \"https://fullnode.devnet.aptoslabs.com/v1\",\n  local: \"http://127.0.0.1:8080/v1\"\n};\nvar NetworkToFaucetAPI = {\n  mainnet: \"https://faucet.mainnet.aptoslabs.com\",\n  testnet: \"https://faucet.testnet.aptoslabs.com\",\n  devnet: \"https://faucet.devnet.aptoslabs.com\",\n  local: \"http://127.0.0.1:8081\"\n};\nvar Network = /* @__PURE__ */(Network2 => {\n  Network2[\"MAINNET\"] = \"mainnet\";\n  Network2[\"TESTNET\"] = \"testnet\";\n  Network2[\"DEVNET\"] = \"devnet\";\n  Network2[\"LOCAL\"] = \"local\";\n  Network2[\"CUSTOM\"] = \"custom\";\n  return Network2;\n})(Network || {});\nvar NetworkToChainId = {\n  mainnet: 1,\n  testnet: 2\n};\n\n// src/utils/const.ts\nvar DEFAULT_NETWORK = \"devnet\" /* DEVNET */;\nvar DEFAULT_MAX_GAS_AMOUNT = 2e5;\nvar DEFAULT_TXN_EXP_SEC_FROM_NOW = 20;\nvar DEFAULT_TXN_TIMEOUT_SEC = 20;\nvar APTOS_COIN = \"0x1::aptos_coin::AptosCoin\";\nvar RAW_TRANSACTION_SALT = \"APTOS::RawTransaction\";\nvar RAW_TRANSACTION_WITH_DATA_SALT = \"APTOS::RawTransactionWithData\";\n\n// src/client/get.ts\nasync function get(options) {\n  const {\n    aptosConfig,\n    overrides,\n    params,\n    contentType,\n    acceptType,\n    path,\n    originMethod,\n    type\n  } = options;\n  const url = aptosConfig.getRequestUrl(type);\n  return aptosRequest({\n    url,\n    method: \"GET\",\n    originMethod,\n    path,\n    contentType: contentType == null ? void 0 : contentType.valueOf(),\n    acceptType: acceptType == null ? void 0 : acceptType.valueOf(),\n    params,\n    overrides: {\n      ...aptosConfig.clientConfig,\n      ...overrides\n    }\n  }, aptosConfig);\n}\nasync function getAptosFullNode(options) {\n  return get({\n    ...options,\n    type: 0 /* FULLNODE */\n  });\n}\nasync function paginateWithCursor(options) {\n  const out = [];\n  let cursor;\n  const requestParams = options.params;\n  while (true) {\n    requestParams.start = cursor;\n    const response = await getAptosFullNode({\n      aptosConfig: options.aptosConfig,\n      originMethod: options.originMethod,\n      path: options.path,\n      params: requestParams,\n      overrides: options.overrides\n    });\n    cursor = response.headers[\"x-aptos-cursor\"];\n    delete response.headers;\n    out.push(...response.data);\n    if (cursor === null || cursor === void 0) {\n      break;\n    }\n  }\n  return out;\n}\n\n// src/client/post.ts\nasync function post(options) {\n  const {\n    type,\n    originMethod,\n    path,\n    body,\n    acceptType,\n    contentType,\n    params,\n    aptosConfig,\n    overrides\n  } = options;\n  const url = aptosConfig.getRequestUrl(type);\n  return aptosRequest({\n    url,\n    method: \"POST\",\n    originMethod,\n    path,\n    body,\n    contentType: contentType == null ? void 0 : contentType.valueOf(),\n    acceptType: acceptType == null ? void 0 : acceptType.valueOf(),\n    params,\n    overrides: {\n      ...aptosConfig.clientConfig,\n      ...overrides\n    }\n  }, aptosConfig);\n}\nasync function postAptosFullNode(options) {\n  return post({\n    ...options,\n    type: 0 /* FULLNODE */\n  });\n}\nasync function postAptosIndexer(options) {\n  return post({\n    ...options,\n    type: 1 /* INDEXER */\n  });\n}\nasync function postAptosFaucet(options) {\n  return post({\n    ...options,\n    type: 2 /* FAUCET */\n  });\n}\n\n// src/core/accountAddress.ts\nimport { bytesToHex as bytesToHex2, hexToBytes as hexToBytes2 } from \"@noble/hashes/utils\";\n\n// src/bcs/consts.ts\nvar MAX_U8_NUMBER = 2 ** 8 - 1;\nvar MAX_U16_NUMBER = 2 ** 16 - 1;\nvar MAX_U32_NUMBER = 2 ** 32 - 1;\nvar MAX_U64_BIG_INT = BigInt(2) ** BigInt(64) - BigInt(1);\nvar MAX_U128_BIG_INT = BigInt(2) ** BigInt(128) - BigInt(1);\nvar MAX_U256_BIG_INT = BigInt(2) ** BigInt(256) - BigInt(1);\n\n// src/core/hex.ts\nimport { bytesToHex, hexToBytes } from \"@noble/hashes/utils\";\n\n// src/core/common.ts\nvar ParsingError = class extends Error {\n  constructor(message, invalidReason) {\n    super(message);\n    this.invalidReason = invalidReason;\n  }\n};\n\n// src/core/hex.ts\nvar HexInvalidReason = /* @__PURE__ */(HexInvalidReason2 => {\n  HexInvalidReason2[\"TOO_SHORT\"] = \"too_short\";\n  HexInvalidReason2[\"INVALID_LENGTH\"] = \"invalid_length\";\n  HexInvalidReason2[\"INVALID_HEX_CHARS\"] = \"invalid_hex_chars\";\n  return HexInvalidReason2;\n})(HexInvalidReason || {});\nvar Hex = class {\n  constructor(data) {\n    this.data = data;\n  }\n  toUint8Array() {\n    return this.data;\n  }\n  toStringWithoutPrefix() {\n    return bytesToHex(this.data);\n  }\n  toString() {\n    return `0x${this.toStringWithoutPrefix()}`;\n  }\n  static fromString(str) {\n    let input = str;\n    if (input.startsWith(\"0x\")) {\n      input = input.slice(2);\n    }\n    if (input.length === 0) {\n      throw new ParsingError(\"Hex string is too short, must be at least 1 char long, excluding the optional leading 0x.\", \"too_short\" /* TOO_SHORT */);\n    }\n    if (input.length % 2 !== 0) {\n      throw new ParsingError(\"Hex string must be an even number of hex characters.\", \"invalid_length\" /* INVALID_LENGTH */);\n    }\n    try {\n      return new Hex(hexToBytes(input));\n    } catch (e) {\n      const error = e;\n      throw new ParsingError(`Hex string contains invalid hex characters: ${error.message}`, \"invalid_hex_chars\" /* INVALID_HEX_CHARS */);\n    }\n  }\n  static fromHexInput(hexInput) {\n    if (hexInput instanceof Uint8Array) return new Hex(hexInput);\n    return Hex.fromString(hexInput);\n  }\n  static isValid(str) {\n    try {\n      Hex.fromString(str);\n      return {\n        valid: true\n      };\n    } catch (e) {\n      const error = e;\n      return {\n        valid: false,\n        invalidReason: error.invalidReason,\n        invalidReasonMessage: error.message\n      };\n    }\n  }\n  equals(other) {\n    if (this.data.length !== other.data.length) return false;\n    return this.data.every((value, index) => value === other.data[index]);\n  }\n};\n\n// src/bcs/serializer.ts\nvar Serializable = class {\n  bcsToBytes() {\n    const serializer = new Serializer();\n    this.serialize(serializer);\n    return serializer.toUint8Array();\n  }\n  bcsToHex() {\n    const bcsBytes = this.bcsToBytes();\n    return Hex.fromHexInput(bcsBytes);\n  }\n};\nvar Serializer = class {\n  constructor() {\n    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 64;\n    if (length <= 0) {\n      throw new Error(\"Length needs to be greater than 0\");\n    }\n    this.buffer = new ArrayBuffer(length);\n    this.offset = 0;\n  }\n  ensureBufferWillHandleSize(bytes) {\n    while (this.buffer.byteLength < this.offset + bytes) {\n      const newBuffer = new ArrayBuffer(this.buffer.byteLength * 2);\n      new Uint8Array(newBuffer).set(new Uint8Array(this.buffer));\n      this.buffer = newBuffer;\n    }\n  }\n  appendToBuffer(values) {\n    this.ensureBufferWillHandleSize(values.length);\n    new Uint8Array(this.buffer, this.offset).set(values);\n    this.offset += values.length;\n  }\n  serializeWithFunction(fn, bytesLength, value) {\n    this.ensureBufferWillHandleSize(bytesLength);\n    const dv = new DataView(this.buffer, this.offset);\n    fn.apply(dv, [0, value, true]);\n    this.offset += bytesLength;\n  }\n  serializeStr(value) {\n    const textEncoder = new TextEncoder();\n    this.serializeBytes(textEncoder.encode(value));\n  }\n  serializeBytes(value) {\n    this.serializeU32AsUleb128(value.length);\n    this.appendToBuffer(value);\n  }\n  serializeFixedBytes(value) {\n    this.appendToBuffer(value);\n  }\n  serializeBool(value) {\n    ensureBoolean(value);\n    const byteValue = value ? 1 : 0;\n    this.appendToBuffer(new Uint8Array([byteValue]));\n  }\n  serializeU8(value) {\n    this.appendToBuffer(new Uint8Array([value]));\n  }\n  serializeU16(value) {\n    this.serializeWithFunction(DataView.prototype.setUint16, 2, value);\n  }\n  serializeU32(value) {\n    this.serializeWithFunction(DataView.prototype.setUint32, 4, value);\n  }\n  serializeU64(value) {\n    const low = BigInt(value) & BigInt(MAX_U32_NUMBER);\n    const high = BigInt(value) >> BigInt(32);\n    this.serializeU32(Number(low));\n    this.serializeU32(Number(high));\n  }\n  serializeU128(value) {\n    const low = BigInt(value) & MAX_U64_BIG_INT;\n    const high = BigInt(value) >> BigInt(64);\n    this.serializeU64(low);\n    this.serializeU64(high);\n  }\n  serializeU256(value) {\n    const low = BigInt(value) & MAX_U128_BIG_INT;\n    const high = BigInt(value) >> BigInt(128);\n    this.serializeU128(low);\n    this.serializeU128(high);\n  }\n  serializeU32AsUleb128(val) {\n    let value = val;\n    const valueArray = [];\n    while (value >>> 7 !== 0) {\n      valueArray.push(value & 127 | 128);\n      value >>>= 7;\n    }\n    valueArray.push(value);\n    this.appendToBuffer(new Uint8Array(valueArray));\n  }\n  toUint8Array() {\n    return new Uint8Array(this.buffer).slice(0, this.offset);\n  }\n  serialize(value) {\n    value.serialize(this);\n  }\n  serializeVector(values) {\n    this.serializeU32AsUleb128(values.length);\n    values.forEach(item => {\n      item.serialize(this);\n    });\n  }\n};\n__decorateClass([checkNumberRange(0, MAX_U8_NUMBER)], Serializer.prototype, \"serializeU8\", 1);\n__decorateClass([checkNumberRange(0, MAX_U16_NUMBER)], Serializer.prototype, \"serializeU16\", 1);\n__decorateClass([checkNumberRange(0, MAX_U32_NUMBER)], Serializer.prototype, \"serializeU32\", 1);\n__decorateClass([checkNumberRange(BigInt(0), MAX_U64_BIG_INT)], Serializer.prototype, \"serializeU64\", 1);\n__decorateClass([checkNumberRange(BigInt(0), MAX_U128_BIG_INT)], Serializer.prototype, \"serializeU128\", 1);\n__decorateClass([checkNumberRange(BigInt(0), MAX_U256_BIG_INT)], Serializer.prototype, \"serializeU256\", 1);\n__decorateClass([checkNumberRange(0, MAX_U32_NUMBER)], Serializer.prototype, \"serializeU32AsUleb128\", 1);\nfunction ensureBoolean(value) {\n  if (typeof value !== \"boolean\") {\n    throw new Error(`${value} is not a boolean value`);\n  }\n}\nvar outOfRangeErrorMessage = (value, min, max) => `${value} is out of range: [${min}, ${max}]`;\nfunction validateNumberInRange(value, minValue, maxValue) {\n  const valueBigInt = BigInt(value);\n  if (valueBigInt > BigInt(maxValue) || valueBigInt < BigInt(minValue)) {\n    throw new Error(outOfRangeErrorMessage(value, minValue, maxValue));\n  }\n}\nfunction checkNumberRange(minValue, maxValue) {\n  return (target, propertyKey, descriptor) => {\n    const childFunction = descriptor.value;\n    descriptor.value = function deco(value) {\n      validateNumberInRange(value, minValue, maxValue);\n      return childFunction.apply(this, [value]);\n    };\n    return descriptor;\n  };\n}\n\n// src/core/accountAddress.ts\nvar AddressInvalidReason = /* @__PURE__ */(AddressInvalidReason2 => {\n  AddressInvalidReason2[\"INCORRECT_NUMBER_OF_BYTES\"] = \"incorrect_number_of_bytes\";\n  AddressInvalidReason2[\"INVALID_HEX_CHARS\"] = \"invalid_hex_chars\";\n  AddressInvalidReason2[\"TOO_SHORT\"] = \"too_short\";\n  AddressInvalidReason2[\"TOO_LONG\"] = \"too_long\";\n  AddressInvalidReason2[\"LEADING_ZERO_X_REQUIRED\"] = \"leading_zero_x_required\";\n  AddressInvalidReason2[\"LONG_FORM_REQUIRED_UNLESS_SPECIAL\"] = \"long_form_required_unless_special\";\n  AddressInvalidReason2[\"INVALID_PADDING_ZEROES\"] = \"INVALID_PADDING_ZEROES\";\n  return AddressInvalidReason2;\n})(AddressInvalidReason || {});\nvar _AccountAddress = class extends Serializable {\n  constructor(args) {\n    super();\n    if (args.data.length !== _AccountAddress.LENGTH) {\n      throw new ParsingError(\"AccountAddress data should be exactly 32 bytes long\", \"incorrect_number_of_bytes\" /* INCORRECT_NUMBER_OF_BYTES */);\n    }\n    this.data = args.data;\n  }\n  isSpecial() {\n    return this.data.slice(0, this.data.length - 1).every(byte => byte === 0) && this.data[this.data.length - 1] < 16;\n  }\n  toString() {\n    return `0x${this.toStringWithoutPrefix()}`;\n  }\n  toStringWithoutPrefix() {\n    let hex = bytesToHex2(this.data);\n    if (this.isSpecial()) {\n      hex = hex[hex.length - 1];\n    }\n    return hex;\n  }\n  toStringLong() {\n    return `0x${this.toStringLongWithoutPrefix()}`;\n  }\n  toStringLongWithoutPrefix() {\n    return bytesToHex2(this.data);\n  }\n  toUint8Array() {\n    return this.data;\n  }\n  serialize(serializer) {\n    serializer.serializeFixedBytes(this.data);\n  }\n  serializeForEntryFunction(serializer) {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n  serializeForScriptFunction(serializer) {\n    serializer.serializeU32AsUleb128(3 /* Address */);\n    serializer.serialize(this);\n  }\n  static deserialize(deserializer) {\n    const bytes = deserializer.deserializeFixedBytes(_AccountAddress.LENGTH);\n    return new _AccountAddress({\n      data: bytes\n    });\n  }\n  static fromString(input) {\n    if (!input.startsWith(\"0x\")) {\n      throw new ParsingError(\"Hex string must start with a leading 0x.\", \"leading_zero_x_required\" /* LEADING_ZERO_X_REQUIRED */);\n    }\n    const address = _AccountAddress.fromStringRelaxed(input);\n    if (input.length !== _AccountAddress.LONG_STRING_LENGTH + 2) {\n      if (!address.isSpecial()) {\n        throw new ParsingError(`The given hex string ${address} is not a special address, it must be represented as 0x + 64 chars.`, \"long_form_required_unless_special\" /* LONG_FORM_REQUIRED_UNLESS_SPECIAL */);\n      } else if (input.length !== 3) {\n        throw new ParsingError(`The given hex string ${input} is a special address not in LONG form, it must be 0x0 to 0xf without padding zeroes.`, \"INVALID_PADDING_ZEROES\" /* INVALID_PADDING_ZEROES */);\n      }\n    }\n    return address;\n  }\n  static fromStringRelaxed(input) {\n    let parsedInput = input;\n    if (input.startsWith(\"0x\")) {\n      parsedInput = input.slice(2);\n    }\n    if (parsedInput.length === 0) {\n      throw new ParsingError(\"Hex string is too short, must be 1 to 64 chars long, excluding the leading 0x.\", \"too_short\" /* TOO_SHORT */);\n    }\n    if (parsedInput.length > 64) {\n      throw new ParsingError(\"Hex string is too long, must be 1 to 64 chars long, excluding the leading 0x.\", \"too_long\" /* TOO_LONG */);\n    }\n    let addressBytes;\n    try {\n      addressBytes = hexToBytes2(parsedInput.padStart(64, \"0\"));\n    } catch (e) {\n      const error = e;\n      throw new ParsingError(`Hex characters are invalid: ${error.message}`, \"invalid_hex_chars\" /* INVALID_HEX_CHARS */);\n    }\n    return new _AccountAddress({\n      data: addressBytes\n    });\n  }\n  static fromHexInput(input) {\n    if (input instanceof Uint8Array) {\n      return new _AccountAddress({\n        data: input\n      });\n    }\n    return _AccountAddress.fromString(input);\n  }\n  static fromHexInputRelaxed(hexInput) {\n    if (hexInput instanceof Uint8Array) {\n      return new _AccountAddress({\n        data: hexInput\n      });\n    }\n    return _AccountAddress.fromStringRelaxed(hexInput);\n  }\n  static isValid(args) {\n    try {\n      if (args.relaxed) {\n        _AccountAddress.fromStringRelaxed(args.input);\n      } else {\n        _AccountAddress.fromString(args.input);\n      }\n      return {\n        valid: true\n      };\n    } catch (e) {\n      const error = e;\n      return {\n        valid: false,\n        invalidReason: error.invalidReason,\n        invalidReasonMessage: error.message\n      };\n    }\n  }\n  equals(other) {\n    if (this.data.length !== other.data.length) return false;\n    return this.data.every((value, index) => value === other.data[index]);\n  }\n};\nvar AccountAddress = _AccountAddress;\nAccountAddress.LENGTH = 32;\nAccountAddress.LONG_STRING_LENGTH = 64;\nAccountAddress.ZERO = _AccountAddress.fromString(\"0x0\");\nAccountAddress.ONE = _AccountAddress.fromString(\"0x1\");\nAccountAddress.TWO = _AccountAddress.fromString(\"0x2\");\nAccountAddress.THREE = _AccountAddress.fromString(\"0x3\");\nAccountAddress.FOUR = _AccountAddress.fromString(\"0x4\");\n\n// src/core/authenticationKey.ts\nimport { sha3_256 as sha3Hash } from \"@noble/hashes/sha3\";\n\n// src/core/crypto/ed25519.ts\nimport nacl from \"tweetnacl\";\n\n// src/bcs/deserializer.ts\nvar Deserializer = class {\n  constructor(data) {\n    this.buffer = new ArrayBuffer(data.length);\n    new Uint8Array(this.buffer).set(data, 0);\n    this.offset = 0;\n  }\n  read(length) {\n    if (this.offset + length > this.buffer.byteLength) {\n      throw new Error(\"Reached to the end of buffer\");\n    }\n    const bytes = this.buffer.slice(this.offset, this.offset + length);\n    this.offset += length;\n    return bytes;\n  }\n  deserializeStr() {\n    const value = this.deserializeBytes();\n    const textDecoder = new TextDecoder();\n    return textDecoder.decode(value);\n  }\n  deserializeBytes() {\n    const len = this.deserializeUleb128AsU32();\n    return new Uint8Array(this.read(len));\n  }\n  deserializeFixedBytes(len) {\n    return new Uint8Array(this.read(len));\n  }\n  deserializeBool() {\n    const bool = new Uint8Array(this.read(1))[0];\n    if (bool !== 1 && bool !== 0) {\n      throw new Error(\"Invalid boolean value\");\n    }\n    return bool === 1;\n  }\n  deserializeU8() {\n    return new DataView(this.read(1)).getUint8(0);\n  }\n  deserializeU16() {\n    return new DataView(this.read(2)).getUint16(0, true);\n  }\n  deserializeU32() {\n    return new DataView(this.read(4)).getUint32(0, true);\n  }\n  deserializeU64() {\n    const low = this.deserializeU32();\n    const high = this.deserializeU32();\n    return BigInt(BigInt(high) << BigInt(32) | BigInt(low));\n  }\n  deserializeU128() {\n    const low = this.deserializeU64();\n    const high = this.deserializeU64();\n    return BigInt(high << BigInt(64) | low);\n  }\n  deserializeU256() {\n    const low = this.deserializeU128();\n    const high = this.deserializeU128();\n    return BigInt(high << BigInt(128) | low);\n  }\n  deserializeUleb128AsU32() {\n    let value = BigInt(0);\n    let shift = 0;\n    while (value < MAX_U32_NUMBER) {\n      const byte = this.deserializeU8();\n      value |= BigInt(byte & 127) << BigInt(shift);\n      if ((byte & 128) === 0) {\n        break;\n      }\n      shift += 7;\n    }\n    if (value > MAX_U32_NUMBER) {\n      throw new Error(\"Overflow while parsing uleb128-encoded uint32 value\");\n    }\n    return Number(value);\n  }\n  deserialize(cls) {\n    return cls.deserialize(this);\n  }\n  deserializeVector(cls) {\n    const length = this.deserializeUleb128AsU32();\n    const vector = new Array();\n    for (let i = 0; i < length; i += 1) {\n      vector.push(this.deserialize(cls));\n    }\n    return vector;\n  }\n};\n\n// src/bcs/serializable/fixedBytes.ts\nvar FixedBytes = class extends Serializable {\n  constructor(value) {\n    super();\n    this.value = Hex.fromHexInput(value).toUint8Array();\n  }\n  serialize(serializer) {\n    serializer.serializeFixedBytes(this.value);\n  }\n  serializeForEntryFunction(serializer) {\n    serializer.serialize(this);\n  }\n  serializeForScriptFunction(serializer) {\n    serializer.serialize(this);\n  }\n  static deserialize(deserializer, length) {\n    const bytes = deserializer.deserializeFixedBytes(length);\n    return new FixedBytes(bytes);\n  }\n};\n\n// src/bcs/serializable/entryFunctionBytes.ts\nvar EntryFunctionBytes = class extends Serializable {\n  constructor(value) {\n    super();\n    this.value = new FixedBytes(value);\n  }\n  serialize(serializer) {\n    serializer.serialize(this.value);\n  }\n  serializeForEntryFunction(serializer) {\n    serializer.serializeU32AsUleb128(this.value.value.length);\n    serializer.serialize(this);\n  }\n  static deserialize(deserializer, length) {\n    const fixedBytes = FixedBytes.deserialize(deserializer, length);\n    return new EntryFunctionBytes(fixedBytes.value);\n  }\n};\n\n// src/bcs/serializable/movePrimitives.ts\nvar Bool = class extends Serializable {\n  constructor(value) {\n    super();\n    ensureBoolean(value);\n    this.value = value;\n  }\n  serialize(serializer) {\n    serializer.serializeBool(this.value);\n  }\n  serializeForEntryFunction(serializer) {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n  serializeForScriptFunction(serializer) {\n    serializer.serializeU32AsUleb128(5 /* Bool */);\n    serializer.serialize(this);\n  }\n  static deserialize(deserializer) {\n    return new Bool(deserializer.deserializeBool());\n  }\n};\nvar U8 = class extends Serializable {\n  constructor(value) {\n    super();\n    validateNumberInRange(value, 0, MAX_U8_NUMBER);\n    this.value = value;\n  }\n  serialize(serializer) {\n    serializer.serializeU8(this.value);\n  }\n  serializeForEntryFunction(serializer) {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n  serializeForScriptFunction(serializer) {\n    serializer.serializeU32AsUleb128(0 /* U8 */);\n    serializer.serialize(this);\n  }\n  static deserialize(deserializer) {\n    return new U8(deserializer.deserializeU8());\n  }\n};\nvar U16 = class extends Serializable {\n  constructor(value) {\n    super();\n    validateNumberInRange(value, 0, MAX_U16_NUMBER);\n    this.value = value;\n  }\n  serialize(serializer) {\n    serializer.serializeU16(this.value);\n  }\n  serializeForEntryFunction(serializer) {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n  serializeForScriptFunction(serializer) {\n    serializer.serializeU32AsUleb128(6 /* U16 */);\n    serializer.serialize(this);\n  }\n  static deserialize(deserializer) {\n    return new U16(deserializer.deserializeU16());\n  }\n};\nvar U32 = class extends Serializable {\n  constructor(value) {\n    super();\n    validateNumberInRange(value, 0, MAX_U32_NUMBER);\n    this.value = value;\n  }\n  serialize(serializer) {\n    serializer.serializeU32(this.value);\n  }\n  serializeForEntryFunction(serializer) {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n  serializeForScriptFunction(serializer) {\n    serializer.serializeU32AsUleb128(7 /* U32 */);\n    serializer.serialize(this);\n  }\n  static deserialize(deserializer) {\n    return new U32(deserializer.deserializeU32());\n  }\n};\nvar U64 = class extends Serializable {\n  constructor(value) {\n    super();\n    validateNumberInRange(value, BigInt(0), MAX_U64_BIG_INT);\n    this.value = BigInt(value);\n  }\n  serialize(serializer) {\n    serializer.serializeU64(this.value);\n  }\n  serializeForEntryFunction(serializer) {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n  serializeForScriptFunction(serializer) {\n    serializer.serializeU32AsUleb128(1 /* U64 */);\n    serializer.serialize(this);\n  }\n  static deserialize(deserializer) {\n    return new U64(deserializer.deserializeU64());\n  }\n};\nvar U128 = class extends Serializable {\n  constructor(value) {\n    super();\n    validateNumberInRange(value, BigInt(0), MAX_U128_BIG_INT);\n    this.value = BigInt(value);\n  }\n  serialize(serializer) {\n    serializer.serializeU128(this.value);\n  }\n  serializeForEntryFunction(serializer) {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n  serializeForScriptFunction(serializer) {\n    serializer.serializeU32AsUleb128(2 /* U128 */);\n    serializer.serialize(this);\n  }\n  static deserialize(deserializer) {\n    return new U128(deserializer.deserializeU128());\n  }\n};\nvar U256 = class extends Serializable {\n  constructor(value) {\n    super();\n    validateNumberInRange(value, BigInt(0), MAX_U256_BIG_INT);\n    this.value = BigInt(value);\n  }\n  serialize(serializer) {\n    serializer.serializeU256(this.value);\n  }\n  serializeForEntryFunction(serializer) {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n  serializeForScriptFunction(serializer) {\n    serializer.serializeU32AsUleb128(8 /* U256 */);\n    serializer.serialize(this);\n  }\n  static deserialize(deserializer) {\n    return new U256(deserializer.deserializeU256());\n  }\n};\n\n// src/bcs/serializable/moveStructs.ts\nvar MoveVector = class extends Serializable {\n  constructor(values) {\n    super();\n    this.values = values;\n  }\n  serializeForEntryFunction(serializer) {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n  serializeForScriptFunction(serializer) {\n    const isU8 = this.values[0] instanceof U8;\n    if (!isU8) {\n      throw new Error(\"Script function arguments only accept u8 vectors\");\n    }\n    serializer.serializeU32AsUleb128(4 /* U8Vector */);\n    serializer.serialize(this);\n  }\n  static U8(values) {\n    let numbers;\n    if (Array.isArray(values) && typeof values[0] === \"number\") {\n      numbers = values;\n    } else if (typeof values === \"string\") {\n      const hex = Hex.fromHexInput(values);\n      numbers = Array.from(hex.toUint8Array());\n    } else if (values instanceof Uint8Array) {\n      numbers = Array.from(values);\n    } else {\n      throw new Error(\"Invalid input type\");\n    }\n    return new MoveVector(numbers.map(v => new U8(v)));\n  }\n  static U16(values) {\n    return new MoveVector(values.map(v => new U16(v)));\n  }\n  static U32(values) {\n    return new MoveVector(values.map(v => new U32(v)));\n  }\n  static U64(values) {\n    return new MoveVector(values.map(v => new U64(v)));\n  }\n  static U128(values) {\n    return new MoveVector(values.map(v => new U128(v)));\n  }\n  static U256(values) {\n    return new MoveVector(values.map(v => new U256(v)));\n  }\n  static Bool(values) {\n    return new MoveVector(values.map(v => new Bool(v)));\n  }\n  static MoveString(values) {\n    return new MoveVector(values.map(v => new MoveString(v)));\n  }\n  serialize(serializer) {\n    serializer.serializeVector(this.values);\n  }\n  static deserialize(deserializer, cls) {\n    const length = deserializer.deserializeUleb128AsU32();\n    const values = new Array();\n    for (let i = 0; i < length; i += 1) {\n      values.push(cls.deserialize(deserializer));\n    }\n    return new MoveVector(values);\n  }\n};\nvar MoveString = class extends Serializable {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  serialize(serializer) {\n    serializer.serializeStr(this.value);\n  }\n  serializeForEntryFunction(serializer) {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n  serializeForScriptFunction(serializer) {\n    const vectorU8 = MoveVector.U8(this.bcsToBytes());\n    vectorU8.serializeForScriptFunction(serializer);\n  }\n  static deserialize(deserializer) {\n    return new MoveString(deserializer.deserializeStr());\n  }\n};\nvar MoveOption = class extends Serializable {\n  constructor(value) {\n    super();\n    if (typeof value !== \"undefined\" && value !== null) {\n      this.vec = new MoveVector([value]);\n    } else {\n      this.vec = new MoveVector([]);\n    }\n    [this.value] = this.vec.values;\n  }\n  serializeForEntryFunction(serializer) {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n  unwrap() {\n    if (!this.isSome()) {\n      throw new Error(\"Called unwrap on a MoveOption with no value\");\n    } else {\n      return this.vec.values[0];\n    }\n  }\n  isSome() {\n    return this.vec.values.length === 1;\n  }\n  serialize(serializer) {\n    this.vec.serialize(serializer);\n  }\n  static U8(value) {\n    return new MoveOption(value !== null && value !== void 0 ? new U8(value) : void 0);\n  }\n  static U16(value) {\n    return new MoveOption(value !== null && value !== void 0 ? new U16(value) : void 0);\n  }\n  static U32(value) {\n    return new MoveOption(value !== null && value !== void 0 ? new U32(value) : void 0);\n  }\n  static U64(value) {\n    return new MoveOption(value !== null && value !== void 0 ? new U64(value) : void 0);\n  }\n  static U128(value) {\n    return new MoveOption(value !== null && value !== void 0 ? new U128(value) : void 0);\n  }\n  static U256(value) {\n    return new MoveOption(value !== null && value !== void 0 ? new U256(value) : void 0);\n  }\n  static Bool(value) {\n    return new MoveOption(value !== null && value !== void 0 ? new Bool(value) : void 0);\n  }\n  static MoveString(value) {\n    return new MoveOption(value !== null && value !== void 0 ? new MoveString(value) : void 0);\n  }\n  static deserialize(deserializer, cls) {\n    const vector = MoveVector.deserialize(deserializer, cls);\n    return new MoveOption(vector.values[0]);\n  }\n};\n\n// src/core/crypto/asymmetricCrypto.ts\nvar PublicKey = class extends Serializable {};\nvar PrivateKey = class extends Serializable {};\nvar Signature = class extends Serializable {};\n\n// src/core/crypto/ed25519.ts\nvar _Ed25519PublicKey = class extends PublicKey {\n  constructor(hexInput) {\n    super();\n    const hex = Hex.fromHexInput(hexInput);\n    if (hex.toUint8Array().length !== _Ed25519PublicKey.LENGTH) {\n      throw new Error(`PublicKey length should be ${_Ed25519PublicKey.LENGTH}`);\n    }\n    this.key = hex;\n  }\n  toUint8Array() {\n    return this.key.toUint8Array();\n  }\n  toString() {\n    return this.key.toString();\n  }\n  verifySignature(args) {\n    const {\n      message,\n      signature\n    } = args;\n    const rawMessage = Hex.fromHexInput(message).toUint8Array();\n    const rawSignature = Hex.fromHexInput(signature.toUint8Array()).toUint8Array();\n    return nacl.sign.detached.verify(rawMessage, rawSignature, this.key.toUint8Array());\n  }\n  serialize(serializer) {\n    serializer.serializeBytes(this.key.toUint8Array());\n  }\n  static deserialize(deserializer) {\n    const bytes = deserializer.deserializeBytes();\n    return new _Ed25519PublicKey(bytes);\n  }\n  static load(deserializer) {\n    const bytes = deserializer.deserializeBytes();\n    return new _Ed25519PublicKey(bytes);\n  }\n};\nvar Ed25519PublicKey = _Ed25519PublicKey;\nEd25519PublicKey.LENGTH = 32;\nvar _Ed25519PrivateKey = class extends PrivateKey {\n  constructor(hexInput) {\n    super();\n    const privateKeyHex = Hex.fromHexInput(hexInput);\n    if (privateKeyHex.toUint8Array().length !== _Ed25519PrivateKey.LENGTH) {\n      throw new Error(`PrivateKey length should be ${_Ed25519PrivateKey.LENGTH}`);\n    }\n    this.signingKeyPair = nacl.sign.keyPair.fromSeed(privateKeyHex.toUint8Array().slice(0, _Ed25519PrivateKey.LENGTH));\n  }\n  toUint8Array() {\n    return this.signingKeyPair.secretKey.slice(0, _Ed25519PrivateKey.LENGTH);\n  }\n  toString() {\n    return Hex.fromHexInput(this.toUint8Array()).toString();\n  }\n  sign(message) {\n    const hex = Hex.fromHexInput(message);\n    const signature = nacl.sign.detached(hex.toUint8Array(), this.signingKeyPair.secretKey);\n    return new Ed25519Signature(signature);\n  }\n  serialize(serializer) {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n  static deserialize(deserializer) {\n    const bytes = deserializer.deserializeBytes();\n    return new _Ed25519PrivateKey(bytes);\n  }\n  static generate() {\n    const keyPair = nacl.sign.keyPair();\n    return new _Ed25519PrivateKey(keyPair.secretKey.slice(0, _Ed25519PrivateKey.LENGTH));\n  }\n  publicKey() {\n    const bytes = this.signingKeyPair.publicKey;\n    return new Ed25519PublicKey(bytes);\n  }\n};\nvar Ed25519PrivateKey = _Ed25519PrivateKey;\nEd25519PrivateKey.LENGTH = 32;\nvar _Ed25519Signature = class extends Signature {\n  constructor(hexInput) {\n    super();\n    const hex = Hex.fromHexInput(hexInput);\n    if (hex.toUint8Array().length !== _Ed25519Signature.LENGTH) {\n      throw new Error(`Signature length should be ${_Ed25519Signature.LENGTH}`);\n    }\n    this.data = hex;\n  }\n  toUint8Array() {\n    return this.data.toUint8Array();\n  }\n  toString() {\n    return this.data.toString();\n  }\n  serialize(serializer) {\n    serializer.serializeBytes(this.data.toUint8Array());\n  }\n  static deserialize(deserializer) {\n    const bytes = deserializer.deserializeBytes();\n    return new _Ed25519Signature(bytes);\n  }\n  static load(deserializer) {\n    const bytes = deserializer.deserializeBytes();\n    return new _Ed25519Signature(bytes);\n  }\n};\nvar Ed25519Signature = _Ed25519Signature;\nEd25519Signature.LENGTH = 64;\n\n// src/core/crypto/multiEd25519.ts\nvar _MultiEd25519PublicKey = class extends PublicKey {\n  constructor(args) {\n    super();\n    const {\n      publicKeys,\n      threshold\n    } = args;\n    if (publicKeys.length > _MultiEd25519PublicKey.MAX_KEYS || publicKeys.length < _MultiEd25519PublicKey.MIN_KEYS) {\n      throw new Error(`Must have between ${_MultiEd25519PublicKey.MIN_KEYS} and ${_MultiEd25519PublicKey.MAX_KEYS} public keys, inclusive`);\n    }\n    if (threshold < _MultiEd25519PublicKey.MIN_THRESHOLD || threshold > publicKeys.length) {\n      throw new Error(`Threshold must be between ${_MultiEd25519PublicKey.MIN_THRESHOLD} and ${publicKeys.length}, inclusive`);\n    }\n    this.publicKeys = publicKeys;\n    this.threshold = threshold;\n  }\n  toUint8Array() {\n    const bytes = new Uint8Array(this.publicKeys.length * Ed25519PublicKey.LENGTH + 1);\n    this.publicKeys.forEach((k, i) => {\n      bytes.set(k.toUint8Array(), i * Ed25519PublicKey.LENGTH);\n    });\n    bytes[this.publicKeys.length * Ed25519PublicKey.LENGTH] = this.threshold;\n    return bytes;\n  }\n  toString() {\n    return Hex.fromHexInput(this.toUint8Array()).toString();\n  }\n  verifySignature(args) {\n    throw new Error(\"TODO - Method not implemented.\");\n  }\n  serialize(serializer) {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n  static deserialize(deserializer) {\n    const bytes = deserializer.deserializeBytes();\n    const threshold = bytes[bytes.length - 1];\n    const keys = [];\n    for (let i = 0; i < bytes.length - 1; i += Ed25519PublicKey.LENGTH) {\n      const begin = i;\n      keys.push(new Ed25519PublicKey(bytes.subarray(begin, begin + Ed25519PublicKey.LENGTH)));\n    }\n    return new _MultiEd25519PublicKey({\n      publicKeys: keys,\n      threshold\n    });\n  }\n};\nvar MultiEd25519PublicKey = _MultiEd25519PublicKey;\nMultiEd25519PublicKey.MAX_KEYS = 32;\nMultiEd25519PublicKey.MIN_KEYS = 2;\nMultiEd25519PublicKey.MIN_THRESHOLD = 1;\nvar _MultiEd25519Signature = class extends Signature {\n  constructor(args) {\n    super();\n    const {\n      signatures,\n      bitmap\n    } = args;\n    if (bitmap.length !== _MultiEd25519Signature.BITMAP_LEN) {\n      throw new Error(`\"bitmap\" length should be ${_MultiEd25519Signature.BITMAP_LEN}`);\n    }\n    if (signatures.length > _MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED) {\n      throw new Error(`The number of signatures cannot be greater than ${_MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED}`);\n    }\n    this.signatures = signatures;\n    this.bitmap = bitmap;\n  }\n  toUint8Array() {\n    const bytes = new Uint8Array(this.signatures.length * Ed25519Signature.LENGTH + _MultiEd25519Signature.BITMAP_LEN);\n    this.signatures.forEach((k, i) => {\n      bytes.set(k.toUint8Array(), i * Ed25519Signature.LENGTH);\n    });\n    bytes.set(this.bitmap, this.signatures.length * Ed25519Signature.LENGTH);\n    return bytes;\n  }\n  toString() {\n    return Hex.fromHexInput(this.toUint8Array()).toString();\n  }\n  static createBitmap(args) {\n    const {\n      bits\n    } = args;\n    const firstBitInByte = 128;\n    const bitmap = new Uint8Array([0, 0, 0, 0]);\n    const dupCheckSet = /* @__PURE__ */new Set();\n    bits.forEach(bit => {\n      if (bit >= _MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED) {\n        throw new Error(`Cannot have a signature larger than ${_MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED - 1}.`);\n      }\n      if (dupCheckSet.has(bit)) {\n        throw new Error(\"Duplicate bits detected.\");\n      }\n      dupCheckSet.add(bit);\n      const byteOffset = Math.floor(bit / 8);\n      let byte = bitmap[byteOffset];\n      byte |= firstBitInByte >> bit % 8;\n      bitmap[byteOffset] = byte;\n    });\n    return bitmap;\n  }\n  serialize(serializer) {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n  static deserialize(deserializer) {\n    const bytes = deserializer.deserializeBytes();\n    const bitmap = bytes.subarray(bytes.length - 4);\n    const signatures = [];\n    for (let i = 0; i < bytes.length - bitmap.length; i += Ed25519Signature.LENGTH) {\n      const begin = i;\n      signatures.push(new Ed25519Signature(bytes.subarray(begin, begin + Ed25519Signature.LENGTH)));\n    }\n    return new _MultiEd25519Signature({\n      signatures,\n      bitmap\n    });\n  }\n};\nvar MultiEd25519Signature = _MultiEd25519Signature;\nMultiEd25519Signature.MAX_SIGNATURES_SUPPORTED = 32;\nMultiEd25519Signature.BITMAP_LEN = 4;\n\n// src/core/crypto/secp256k1.ts\nimport { sha3_256 } from \"@noble/hashes/sha3\";\nimport { secp256k1 } from \"@noble/curves/secp256k1\";\nvar _Secp256k1PublicKey = class extends PublicKey {\n  constructor(hexInput) {\n    super();\n    const hex = Hex.fromHexInput(hexInput);\n    if (hex.toUint8Array().length !== _Secp256k1PublicKey.LENGTH) {\n      throw new Error(`PublicKey length should be ${_Secp256k1PublicKey.LENGTH}`);\n    }\n    this.key = hex;\n  }\n  toUint8Array() {\n    return this.key.toUint8Array();\n  }\n  toString() {\n    return this.key.toString();\n  }\n  verifySignature(args) {\n    const {\n      message,\n      signature\n    } = args;\n    const msgHex = Hex.fromHexInput(message).toUint8Array();\n    const sha3Message = sha3_256(msgHex);\n    const rawSignature = signature.toUint8Array();\n    return secp256k1.verify(rawSignature, sha3Message, this.toUint8Array());\n  }\n  serialize(serializer) {\n    serializer.serializeBytes(this.key.toUint8Array());\n  }\n  static deserialize(deserializer) {\n    const bytes = deserializer.deserializeBytes();\n    return new _Secp256k1PublicKey(bytes);\n  }\n  static load(deserializer) {\n    const bytes = deserializer.deserializeBytes();\n    return new _Secp256k1PublicKey(bytes);\n  }\n};\nvar Secp256k1PublicKey = _Secp256k1PublicKey;\nSecp256k1PublicKey.LENGTH = 65;\nvar _Secp256k1PrivateKey = class extends PrivateKey {\n  constructor(hexInput) {\n    super();\n    const privateKeyHex = Hex.fromHexInput(hexInput);\n    if (privateKeyHex.toUint8Array().length !== _Secp256k1PrivateKey.LENGTH) {\n      throw new Error(`PrivateKey length should be ${_Secp256k1PrivateKey.LENGTH}`);\n    }\n    this.key = privateKeyHex;\n  }\n  toUint8Array() {\n    return this.key.toUint8Array();\n  }\n  toString() {\n    return this.key.toString();\n  }\n  sign(message) {\n    const msgHex = Hex.fromHexInput(message);\n    const sha3Message = sha3_256(msgHex.toUint8Array());\n    const signature = secp256k1.sign(sha3Message, this.key.toUint8Array());\n    return new Secp256k1Signature(signature.toCompactRawBytes());\n  }\n  serialize(serializer) {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n  static deserialize(deserializer) {\n    const bytes = deserializer.deserializeBytes();\n    return new _Secp256k1PrivateKey(bytes);\n  }\n  static generate() {\n    const hexInput = secp256k1.utils.randomPrivateKey();\n    return new _Secp256k1PrivateKey(hexInput);\n  }\n  publicKey() {\n    const bytes = secp256k1.getPublicKey(this.key.toUint8Array(), false);\n    return new Secp256k1PublicKey(bytes);\n  }\n};\nvar Secp256k1PrivateKey = _Secp256k1PrivateKey;\nSecp256k1PrivateKey.LENGTH = 32;\nvar _Secp256k1Signature = class extends Signature {\n  constructor(hexInput) {\n    super();\n    const hex = Hex.fromHexInput(hexInput);\n    if (hex.toUint8Array().length !== _Secp256k1Signature.LENGTH) {\n      throw new Error(`Signature length should be ${_Secp256k1Signature.LENGTH}, recieved ${hex.toUint8Array().length}`);\n    }\n    this.data = hex;\n  }\n  toUint8Array() {\n    return this.data.toUint8Array();\n  }\n  toString() {\n    return this.data.toString();\n  }\n  serialize(serializer) {\n    serializer.serializeBytes(this.data.toUint8Array());\n  }\n  static deserialize(deserializer) {\n    const hex = deserializer.deserializeBytes();\n    return new _Secp256k1Signature(hex);\n  }\n  static load(deserializer) {\n    const bytes = deserializer.deserializeBytes();\n    return new _Secp256k1Signature(bytes);\n  }\n};\nvar Secp256k1Signature = _Secp256k1Signature;\nSecp256k1Signature.LENGTH = 64;\n\n// src/core/crypto/anyPublicKey.ts\nvar AnyPublicKey = class extends PublicKey {\n  constructor(publicKey) {\n    super();\n    this.publicKey = publicKey;\n  }\n  toUint8Array() {\n    return this.publicKey.toUint8Array();\n  }\n  toString() {\n    return this.publicKey.toString();\n  }\n  verifySignature(args) {\n    const {\n      message,\n      signature\n    } = args;\n    return this.publicKey.verifySignature({\n      message,\n      signature\n    });\n  }\n  serialize(serializer) {\n    if (this.publicKey instanceof Ed25519PublicKey) {\n      serializer.serializeU32AsUleb128(0 /* Ed25519 */);\n      this.publicKey.serialize(serializer);\n    } else if (this.publicKey instanceof Secp256k1PublicKey) {\n      serializer.serializeU32AsUleb128(1 /* Secp256k1 */);\n      this.publicKey.serialize(serializer);\n    } else {\n      throw new Error(\"Unknown public key type\");\n    }\n  }\n  static deserialize(deserializer) {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case 0 /* Ed25519 */:\n        return new AnyPublicKey(Ed25519PublicKey.load(deserializer));\n      case 1 /* Secp256k1 */:\n        return new AnyPublicKey(Secp256k1PublicKey.load(deserializer));\n      default:\n        throw new Error(`Unknown variant index for AnyPublicKey: ${index}`);\n    }\n  }\n};\n\n// src/core/crypto/multiKey.ts\nvar MultiKey = class extends PublicKey {\n  constructor(args) {\n    super();\n    const {\n      publicKeys,\n      signaturesRequired\n    } = args;\n    if (signaturesRequired < 1) {\n      throw new Error(\"The number of required signatures needs to be greater then 0\");\n    }\n    if (publicKeys.length < signaturesRequired) {\n      throw new Error(`Provided ${publicKeys.length} public keys is smaller than the ${signaturesRequired} required signatures`);\n    }\n    const keys = [];\n    publicKeys.forEach(publicKey => {\n      if (publicKey instanceof AnyPublicKey) {\n        keys.push(publicKey);\n      } else {\n        keys.push(new AnyPublicKey(publicKey));\n      }\n    });\n    this.publicKeys = keys;\n    this.signaturesRequired = signaturesRequired;\n  }\n  toUint8Array() {\n    return this.bcsToBytes();\n  }\n  createBitmap(args) {\n    const {\n      bits\n    } = args;\n    const firstBitInByte = 128;\n    const bitmap = new Uint8Array([0, 0, 0, 0]);\n    const dupCheckSet = /* @__PURE__ */new Set();\n    bits.forEach((bit, idx) => {\n      if (idx + 1 > this.publicKeys.length) {\n        throw new Error(`Signature index ${idx + 1} is out of public keys range, ${this.publicKeys.length}.`);\n      }\n      if (dupCheckSet.has(bit)) {\n        throw new Error(`Duplicate bit ${bit} detected.`);\n      }\n      dupCheckSet.add(bit);\n      const byteOffset = Math.floor(bit / 8);\n      let byte = bitmap[byteOffset];\n      byte |= firstBitInByte >> bit % 8;\n      bitmap[byteOffset] = byte;\n    });\n    return bitmap;\n  }\n  toString() {\n    return Hex.fromHexInput(this.toUint8Array()).toString();\n  }\n  verifySignature(args) {\n    throw new Error(\"not implemented\");\n  }\n  serialize(serializer) {\n    serializer.serializeVector(this.publicKeys);\n    serializer.serializeU8(this.signaturesRequired);\n  }\n  static deserialize(deserializer) {\n    const keys = deserializer.deserializeVector(AnyPublicKey);\n    const signaturesRequired = deserializer.deserializeU8();\n    return new MultiKey({\n      publicKeys: keys,\n      signaturesRequired\n    });\n  }\n};\n\n// src/core/authenticationKey.ts\nvar _AuthenticationKey = class extends Serializable {\n  constructor(args) {\n    super();\n    const {\n      data\n    } = args;\n    const hex = Hex.fromHexInput(data);\n    if (hex.toUint8Array().length !== _AuthenticationKey.LENGTH) {\n      throw new Error(`Authentication Key length should be ${_AuthenticationKey.LENGTH}`);\n    }\n    this.data = hex;\n  }\n  serialize(serializer) {\n    serializer.serializeFixedBytes(this.data.toUint8Array());\n  }\n  static deserialize(deserializer) {\n    const bytes = deserializer.deserializeFixedBytes(_AuthenticationKey.LENGTH);\n    return new _AuthenticationKey({\n      data: bytes\n    });\n  }\n  toString() {\n    return this.data.toString();\n  }\n  toUint8Array() {\n    return this.data.toUint8Array();\n  }\n  static fromPublicKeyAndScheme(args) {\n    const {\n      publicKey,\n      scheme\n    } = args;\n    let authKeyBytes;\n    switch (scheme) {\n      case 3 /* MultiKey */:\n      case 2 /* SingleKey */:\n        {\n          const singleKeyBytes = publicKey.bcsToBytes();\n          authKeyBytes = new Uint8Array([...singleKeyBytes, scheme]);\n          break;\n        }\n      case 0 /* Ed25519 */:\n      case 1 /* MultiEd25519 */:\n        {\n          const ed25519PublicKeyBytes = publicKey.toUint8Array();\n          const inputBytes = Hex.fromHexInput(ed25519PublicKeyBytes).toUint8Array();\n          authKeyBytes = new Uint8Array([...inputBytes, scheme]);\n          break;\n        }\n      default:\n        throw new Error(`Scheme ${scheme} is not supported`);\n    }\n    const hash = sha3Hash.create();\n    hash.update(authKeyBytes);\n    const hashDigest = hash.digest();\n    return new _AuthenticationKey({\n      data: hashDigest\n    });\n  }\n  static fromPublicKey(args) {\n    const {\n      publicKey\n    } = args;\n    let scheme;\n    if (publicKey instanceof Ed25519PublicKey) {\n      scheme = 0 /* Ed25519 */.valueOf();\n    } else if (publicKey instanceof MultiEd25519PublicKey) {\n      scheme = 1 /* MultiEd25519 */.valueOf();\n    } else if (publicKey instanceof AnyPublicKey) {\n      scheme = 2 /* SingleKey */.valueOf();\n    } else if (publicKey instanceof MultiKey) {\n      scheme = 3 /* MultiKey */.valueOf();\n    } else {\n      throw new Error(\"No supported authentication scheme for public key\");\n    }\n    return _AuthenticationKey.fromPublicKeyAndScheme({\n      publicKey,\n      scheme\n    });\n  }\n  derivedAddress() {\n    return new AccountAddress({\n      data: this.data.toUint8Array()\n    });\n  }\n};\nvar AuthenticationKey = _AuthenticationKey;\nAuthenticationKey.LENGTH = 32;\n\n// src/utils/hdKey.ts\nimport { hmac } from \"@noble/hashes/hmac\";\nimport { sha512 } from \"@noble/hashes/sha512\";\nimport * as bip39 from \"@scure/bip39\";\nvar APTOS_PATH_REGEX = /^m\\/44'\\/637'\\/[0-9]+'\\/[0-9]+'\\/[0-9]+'?$/;\nvar KeyType = /* @__PURE__ */(KeyType2 => {\n  KeyType2[\"ED25519\"] = \"ed25519 seed\";\n  return KeyType2;\n})(KeyType || {});\nvar HARDENED_OFFSET = 2147483648;\nvar deriveKey = (hashSeed, data) => {\n  const digest = hmac.create(sha512, hashSeed).update(data).digest();\n  return {\n    key: digest.slice(0, 32),\n    chainCode: digest.slice(32)\n  };\n};\nvar CKDPriv = (_ref, index) => {\n  let {\n    key,\n    chainCode\n  } = _ref;\n  const buffer = new ArrayBuffer(4);\n  new DataView(buffer).setUint32(0, index);\n  const indexBytes = new Uint8Array(buffer);\n  const zero = new Uint8Array([0]);\n  const data = new Uint8Array([...zero, ...key, ...indexBytes]);\n  return deriveKey(chainCode, data);\n};\nvar removeApostrophes = val => val.replace(\"'\", \"\");\nvar splitPath = path => path.split(\"/\").slice(1).map(removeApostrophes);\nvar isValidPath = path => {\n  if (!APTOS_PATH_REGEX.test(path)) {\n    return false;\n  }\n  return !splitPath(path).some(Number.isNaN);\n};\nvar mnemonicToSeed = mnemonic => {\n  const normalizedMnemonic = mnemonic.trim().split(/\\s+/).map(part => part.toLowerCase()).join(\" \");\n  return bip39.mnemonicToSeedSync(normalizedMnemonic);\n};\nvar derivePrivateKeyFromMnemonic = function (keyType, path, seedPhrase) {\n  let offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : HARDENED_OFFSET;\n  if (!isValidPath(path)) {\n    throw new Error(\"Invalid derivation path\");\n  }\n  const {\n    key,\n    chainCode\n  } = deriveKey(keyType, mnemonicToSeed(seedPhrase));\n  const segments = splitPath(path).map(el => parseInt(el, 10));\n  return segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset), {\n    key,\n    chainCode\n  });\n};\n\n// src/core/account.ts\nvar Account = class {\n  constructor(args) {\n    const {\n      privateKey,\n      address,\n      legacy\n    } = args;\n    this.publicKey = privateKey.publicKey();\n    if (this.publicKey instanceof Ed25519PublicKey) {\n      if (legacy) {\n        this.signingScheme = 0 /* Ed25519 */;\n      } else {\n        this.publicKey = new AnyPublicKey(this.publicKey);\n        this.signingScheme = 2 /* SingleKey */;\n      }\n    } else if (this.publicKey instanceof MultiEd25519PublicKey) {\n      this.signingScheme = 1 /* MultiEd25519 */;\n    } else if (this.publicKey instanceof Secp256k1PublicKey) {\n      this.publicKey = new AnyPublicKey(this.publicKey);\n      this.signingScheme = 2 /* SingleKey */;\n    } else {\n      throw new Error(\"Can not create new Account, unsupported public key type\");\n    }\n    this.privateKey = privateKey;\n    this.accountAddress = address;\n  }\n  static generate(args) {\n    let privateKey;\n    switch (args == null ? void 0 : args.scheme) {\n      case 2 /* Secp256k1Ecdsa */:\n        privateKey = Secp256k1PrivateKey.generate();\n        break;\n      default:\n        privateKey = Ed25519PrivateKey.generate();\n    }\n    let publicKey = privateKey.publicKey();\n    if (!(args == null ? void 0 : args.legacy)) {\n      publicKey = new AnyPublicKey(privateKey.publicKey());\n    }\n    const address = new AccountAddress({\n      data: Account.authKey({\n        publicKey\n      }).toUint8Array()\n    });\n    return new Account({\n      privateKey,\n      address,\n      legacy: args == null ? void 0 : args.legacy\n    });\n  }\n  static fromPrivateKeyAndAddress(args) {\n    const {\n      privateKey,\n      address,\n      legacy\n    } = args;\n    return new Account({\n      privateKey,\n      address,\n      legacy\n    });\n  }\n  static fromDerivationPath(args) {\n    const {\n      path,\n      mnemonic\n    } = args;\n    const {\n      key\n    } = derivePrivateKeyFromMnemonic(\"ed25519 seed\" /* ED25519 */, path, mnemonic);\n    const privateKey = new Ed25519PrivateKey(key);\n    const publicKey = privateKey.publicKey();\n    const authKey = Account.authKey({\n      publicKey\n    });\n    const address = new AccountAddress({\n      data: authKey.toUint8Array()\n    });\n    return new Account({\n      privateKey,\n      address,\n      legacy: true\n    });\n  }\n  static authKey(args) {\n    const {\n      publicKey\n    } = args;\n    const authKey = AuthenticationKey.fromPublicKey({\n      publicKey\n    });\n    return authKey.data;\n  }\n  sign(data) {\n    return this.privateKey.sign(data);\n  }\n  verifySignature(args) {\n    const {\n      message,\n      signature\n    } = args;\n    const rawMessage = Hex.fromHexInput(message).toUint8Array();\n    return this.publicKey.verifySignature({\n      message: rawMessage,\n      signature\n    });\n  }\n};\n\n// src/types/generated/queries.ts\nvar CurrentTokenOwnershipFieldsFragmentDoc = `\n    fragment CurrentTokenOwnershipFields on current_token_ownerships_v2 {\n  token_standard\n  token_properties_mutated_v1\n  token_data_id\n  table_type_v1\n  storage_id\n  property_version_v1\n  owner_address\n  last_transaction_version\n  last_transaction_timestamp\n  is_soulbound_v2\n  is_fungible_v2\n  amount\n  current_token_data {\n    collection_id\n    description\n    is_fungible_v2\n    largest_property_version_v1\n    last_transaction_timestamp\n    last_transaction_version\n    maximum\n    supply\n    token_data_id\n    token_name\n    token_properties\n    token_standard\n    token_uri\n    current_collection {\n      collection_id\n      collection_name\n      creator_address\n      current_supply\n      description\n      last_transaction_timestamp\n      last_transaction_version\n      max_supply\n      mutable_description\n      mutable_uri\n      table_handle_v1\n      token_standard\n      total_minted_v2\n      uri\n    }\n  }\n}\n    `;\nvar TokenActivitiesFieldsFragmentDoc = `\n    fragment TokenActivitiesFields on token_activities_v2 {\n  after_value\n  before_value\n  entry_function_id_str\n  event_account_address\n  event_index\n  from_address\n  is_fungible_v2\n  property_version_v1\n  to_address\n  token_amount\n  token_data_id\n  token_standard\n  transaction_timestamp\n  transaction_version\n  type\n}\n    `;\nvar GetAccountCoinsCount = `\n    query getAccountCoinsCount($address: String) {\n  current_fungible_asset_balances_aggregate(\n    where: {owner_address: {_eq: $address}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n    `;\nvar GetAccountCoinsData = `\n    query getAccountCoinsData($where_condition: current_fungible_asset_balances_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_fungible_asset_balances_order_by!]) {\n  current_fungible_asset_balances(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    amount\n    asset_type\n    is_frozen\n    is_primary\n    last_transaction_timestamp\n    last_transaction_version\n    owner_address\n    storage_id\n    token_standard\n    metadata {\n      token_standard\n      symbol\n      supply_aggregator_table_key_v1\n      supply_aggregator_table_handle_v1\n      project_uri\n      name\n      last_transaction_version\n      last_transaction_timestamp\n      icon_uri\n      decimals\n      creator_address\n      asset_type\n    }\n  }\n}\n    `;\nvar GetAccountCollectionsWithOwnedTokens = `\n    query getAccountCollectionsWithOwnedTokens($where_condition: current_collection_ownership_v2_view_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_collection_ownership_v2_view_order_by!]) {\n  current_collection_ownership_v2_view(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    current_collection {\n      collection_id\n      collection_name\n      creator_address\n      current_supply\n      description\n      last_transaction_timestamp\n      last_transaction_version\n      mutable_description\n      max_supply\n      mutable_uri\n      table_handle_v1\n      token_standard\n      total_minted_v2\n      uri\n    }\n    collection_id\n    collection_name\n    collection_uri\n    creator_address\n    distinct_tokens\n    last_transaction_version\n    owner_address\n    single_token_uri\n  }\n}\n    `;\nvar GetAccountOwnedObjects = `\n    query getAccountOwnedObjects($where_condition: current_objects_bool_exp, $offset: Int, $limit: Int, $order_by: [current_objects_order_by!]) {\n  current_objects(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    allow_ungated_transfer\n    state_key_hash\n    owner_address\n    object_address\n    last_transaction_version\n    last_guid_creation_num\n    is_deleted\n  }\n}\n    `;\nvar GetAccountOwnedTokens = `\n    query getAccountOwnedTokens($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {\n  current_token_ownerships_v2(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    ...CurrentTokenOwnershipFields\n  }\n}\n    ${CurrentTokenOwnershipFieldsFragmentDoc}`;\nvar GetAccountOwnedTokensByTokenData = `\n    query getAccountOwnedTokensByTokenData($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {\n  current_token_ownerships_v2(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    ...CurrentTokenOwnershipFields\n  }\n}\n    ${CurrentTokenOwnershipFieldsFragmentDoc}`;\nvar GetAccountOwnedTokensFromCollection = `\n    query getAccountOwnedTokensFromCollection($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {\n  current_token_ownerships_v2(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    ...CurrentTokenOwnershipFields\n  }\n}\n    ${CurrentTokenOwnershipFieldsFragmentDoc}`;\nvar GetAccountTokensCount = `\n    query getAccountTokensCount($where_condition: current_token_ownerships_v2_bool_exp, $offset: Int, $limit: Int) {\n  current_token_ownerships_v2_aggregate(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n    `;\nvar GetAccountTransactionsCount = `\n    query getAccountTransactionsCount($address: String) {\n  account_transactions_aggregate(where: {account_address: {_eq: $address}}) {\n    aggregate {\n      count\n    }\n  }\n}\n    `;\nvar GetChainTopUserTransactions = `\n    query getChainTopUserTransactions($limit: Int) {\n  user_transactions(limit: $limit, order_by: {version: desc}) {\n    version\n  }\n}\n    `;\nvar GetCollectionData = `\n    query getCollectionData($where_condition: current_collections_v2_bool_exp!) {\n  current_collections_v2(where: $where_condition) {\n    collection_id\n    collection_name\n    creator_address\n    current_supply\n    description\n    last_transaction_timestamp\n    last_transaction_version\n    max_supply\n    mutable_description\n    mutable_uri\n    table_handle_v1\n    token_standard\n    total_minted_v2\n    uri\n  }\n}\n    `;\nvar GetCurrentFungibleAssetBalances = `\n    query getCurrentFungibleAssetBalances($where_condition: current_fungible_asset_balances_bool_exp, $offset: Int, $limit: Int) {\n  current_fungible_asset_balances(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n  ) {\n    amount\n    asset_type\n    is_frozen\n    is_primary\n    last_transaction_timestamp\n    last_transaction_version\n    owner_address\n    storage_id\n    token_standard\n  }\n}\n    `;\nvar GetDelegatedStakingActivities = `\n    query getDelegatedStakingActivities($delegatorAddress: String, $poolAddress: String) {\n  delegated_staking_activities(\n    where: {delegator_address: {_eq: $delegatorAddress}, pool_address: {_eq: $poolAddress}}\n  ) {\n    amount\n    delegator_address\n    event_index\n    event_type\n    pool_address\n    transaction_version\n  }\n}\n    `;\nvar GetEvents = `\n    query getEvents($where_condition: events_bool_exp, $offset: Int, $limit: Int, $order_by: [events_order_by!]) {\n  events(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    account_address\n    creation_number\n    data\n    event_index\n    sequence_number\n    transaction_block_height\n    transaction_version\n    type\n  }\n}\n    `;\nvar GetFungibleAssetActivities = `\n    query getFungibleAssetActivities($where_condition: fungible_asset_activities_bool_exp, $offset: Int, $limit: Int) {\n  fungible_asset_activities(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n  ) {\n    amount\n    asset_type\n    block_height\n    entry_function_id_str\n    event_index\n    gas_fee_payer_address\n    is_frozen\n    is_gas_fee\n    is_transaction_success\n    owner_address\n    storage_id\n    storage_refund_amount\n    token_standard\n    transaction_timestamp\n    transaction_version\n    type\n  }\n}\n    `;\nvar GetFungibleAssetMetadata = `\n    query getFungibleAssetMetadata($where_condition: fungible_asset_metadata_bool_exp, $offset: Int, $limit: Int) {\n  fungible_asset_metadata(where: $where_condition, offset: $offset, limit: $limit) {\n    icon_uri\n    project_uri\n    supply_aggregator_table_handle_v1\n    supply_aggregator_table_key_v1\n    creator_address\n    asset_type\n    decimals\n    last_transaction_timestamp\n    last_transaction_version\n    name\n    symbol\n    token_standard\n  }\n}\n    `;\nvar GetNumberOfDelegators = `\n    query getNumberOfDelegators($where_condition: num_active_delegator_per_pool_bool_exp!, $order_by: [num_active_delegator_per_pool_order_by!]) {\n  num_active_delegator_per_pool(where: $where_condition, order_by: $order_by) {\n    num_active_delegator\n    pool_address\n  }\n}\n    `;\nvar GetProcessorStatus = `\n    query getProcessorStatus {\n  processor_status {\n    last_success_version\n    processor\n    last_updated\n  }\n}\n    `;\nvar GetTokenActivity = `\n    query getTokenActivity($where_condition: token_activities_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [token_activities_v2_order_by!]) {\n  token_activities_v2(\n    where: $where_condition\n    order_by: $order_by\n    offset: $offset\n    limit: $limit\n  ) {\n    ...TokenActivitiesFields\n  }\n}\n    ${TokenActivitiesFieldsFragmentDoc}`;\nvar GetCurrentTokenOwnership = `\n    query getCurrentTokenOwnership($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {\n  current_token_ownerships_v2(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    ...CurrentTokenOwnershipFields\n  }\n}\n    ${CurrentTokenOwnershipFieldsFragmentDoc}`;\nvar GetTokenData = `\n    query getTokenData($where_condition: current_token_datas_v2_bool_exp, $offset: Int, $limit: Int, $order_by: [current_token_datas_v2_order_by!]) {\n  current_token_datas_v2(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    collection_id\n    description\n    is_fungible_v2\n    largest_property_version_v1\n    last_transaction_timestamp\n    last_transaction_version\n    maximum\n    supply\n    token_data_id\n    token_name\n    token_properties\n    token_standard\n    token_uri\n    current_collection {\n      collection_id\n      collection_name\n      creator_address\n      current_supply\n      description\n      last_transaction_timestamp\n      last_transaction_version\n      max_supply\n      mutable_description\n      mutable_uri\n      table_handle_v1\n      token_standard\n      total_minted_v2\n      uri\n    }\n  }\n}\n    `;\n\n// src/internal/general.ts\nasync function getLedgerInfo(args) {\n  const {\n    aptosConfig\n  } = args;\n  const {\n    data\n  } = await getAptosFullNode({\n    aptosConfig,\n    originMethod: \"getLedgerInfo\",\n    path: \"\"\n  });\n  return data;\n}\nasync function getBlockByVersion(args) {\n  const {\n    aptosConfig,\n    ledgerVersion,\n    options\n  } = args;\n  const {\n    data\n  } = await getAptosFullNode({\n    aptosConfig,\n    originMethod: \"getBlockByVersion\",\n    path: `blocks/by_version/${ledgerVersion}`,\n    params: {\n      with_transactions: options == null ? void 0 : options.withTransactions\n    }\n  });\n  return data;\n}\nasync function getBlockByHeight(args) {\n  const {\n    aptosConfig,\n    blockHeight,\n    options\n  } = args;\n  const {\n    data\n  } = await getAptosFullNode({\n    aptosConfig,\n    originMethod: \"getBlockByHeight\",\n    path: `blocks/by_height/${blockHeight}`,\n    params: {\n      with_transactions: options == null ? void 0 : options.withTransactions\n    }\n  });\n  return data;\n}\nasync function getTableItem(args) {\n  const {\n    aptosConfig,\n    handle,\n    data,\n    options\n  } = args;\n  const response = await postAptosFullNode({\n    aptosConfig,\n    originMethod: \"getTableItem\",\n    path: `tables/${handle}/item`,\n    params: {\n      ledger_version: options == null ? void 0 : options.ledgerVersion\n    },\n    body: data\n  });\n  return response.data;\n}\nasync function view(args) {\n  var _a, _b;\n  const {\n    aptosConfig,\n    payload,\n    options\n  } = args;\n  const {\n    data\n  } = await postAptosFullNode({\n    aptosConfig,\n    originMethod: \"view\",\n    path: \"view\",\n    params: {\n      ledger_version: options == null ? void 0 : options.ledgerVersion\n    },\n    body: {\n      function: payload.function,\n      type_arguments: (_a = payload.typeArguments) != null ? _a : [],\n      arguments: (_b = payload.functionArguments) != null ? _b : []\n    }\n  });\n  return data;\n}\nasync function getChainTopUserTransactions(args) {\n  const {\n    aptosConfig,\n    limit\n  } = args;\n  const graphqlQuery = {\n    query: GetChainTopUserTransactions,\n    variables: {\n      limit\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getChainTopUserTransactions\"\n  });\n  return data.user_transactions;\n}\nasync function queryIndexer(args) {\n  const {\n    aptosConfig,\n    query,\n    originMethod\n  } = args;\n  const {\n    data\n  } = await postAptosIndexer({\n    aptosConfig,\n    originMethod: originMethod != null ? originMethod : \"queryIndexer\",\n    path: \"\",\n    body: query,\n    overrides: {\n      WITH_CREDENTIALS: false\n    }\n  });\n  return data;\n}\nasync function getProcessorStatuses(args) {\n  const {\n    aptosConfig\n  } = args;\n  const graphqlQuery = {\n    query: GetProcessorStatus\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getProcessorStatuses\"\n  });\n  return data.processor_status;\n}\nasync function getIndexerLastSuccessVersion(args) {\n  const response = await getProcessorStatuses({\n    aptosConfig: args.aptosConfig\n  });\n  return response[0].last_success_version;\n}\n\n// src/utils/memoize.ts\nvar cache = /* @__PURE__ */new Map();\nfunction memoizeAsync(func, key, ttlMs) {\n  return async function () {\n    if (cache.has(key)) {\n      const {\n        value,\n        timestamp\n      } = cache.get(key);\n      if (ttlMs === void 0 || Date.now() - timestamp <= ttlMs) {\n        return value;\n      }\n    }\n    const result = await func(...arguments);\n    cache.set(key, {\n      value: result,\n      timestamp: Date.now()\n    });\n    return result;\n  };\n}\n\n// src/internal/account.ts\nasync function getInfo(args) {\n  const {\n    aptosConfig,\n    accountAddress\n  } = args;\n  const {\n    data\n  } = await getAptosFullNode({\n    aptosConfig,\n    originMethod: \"getInfo\",\n    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}`\n  });\n  return data;\n}\nasync function getModules(args) {\n  var _a;\n  const {\n    aptosConfig,\n    accountAddress,\n    options\n  } = args;\n  return paginateWithCursor({\n    aptosConfig,\n    originMethod: \"getModules\",\n    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}/modules`,\n    params: {\n      ledger_version: options == null ? void 0 : options.ledgerVersion,\n      start: options == null ? void 0 : options.offset,\n      limit: (_a = options == null ? void 0 : options.limit) != null ? _a : 1e3\n    }\n  });\n}\nasync function getModule(args) {\n  var _a;\n  if (((_a = args.options) == null ? void 0 : _a.ledgerVersion) !== void 0) {\n    return getModuleInner(args);\n  }\n  return memoizeAsync(async () => getModuleInner(args), `module-${args.accountAddress}-${args.moduleName}`, 1e3 * 60 * 5)();\n}\nasync function getModuleInner(args) {\n  const {\n    aptosConfig,\n    accountAddress,\n    moduleName,\n    options\n  } = args;\n  const {\n    data\n  } = await getAptosFullNode({\n    aptosConfig,\n    originMethod: \"getModule\",\n    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}/module/${moduleName}`,\n    params: {\n      ledger_version: options == null ? void 0 : options.ledgerVersion\n    }\n  });\n  return data;\n}\nasync function getTransactions(args) {\n  const {\n    aptosConfig,\n    accountAddress,\n    options\n  } = args;\n  return paginateWithCursor({\n    aptosConfig,\n    originMethod: \"getTransactions\",\n    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}/transactions`,\n    params: {\n      start: options == null ? void 0 : options.offset,\n      limit: options == null ? void 0 : options.limit\n    }\n  });\n}\nasync function getResources(args) {\n  var _a;\n  const {\n    aptosConfig,\n    accountAddress,\n    options\n  } = args;\n  return paginateWithCursor({\n    aptosConfig,\n    originMethod: \"getResources\",\n    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}/resources`,\n    params: {\n      ledger_version: options == null ? void 0 : options.ledgerVersion,\n      start: options == null ? void 0 : options.offset,\n      limit: (_a = options == null ? void 0 : options.limit) != null ? _a : 999\n    }\n  });\n}\nasync function getResource(args) {\n  const {\n    aptosConfig,\n    accountAddress,\n    resourceType,\n    options\n  } = args;\n  const {\n    data\n  } = await getAptosFullNode({\n    aptosConfig,\n    originMethod: \"getResource\",\n    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}/resource/${resourceType}`,\n    params: {\n      ledger_version: options == null ? void 0 : options.ledgerVersion\n    }\n  });\n  return data.data;\n}\nasync function lookupOriginalAccountAddress(args) {\n  const {\n    aptosConfig,\n    authenticationKey,\n    options\n  } = args;\n  const resource = await getResource({\n    aptosConfig,\n    accountAddress: \"0x1\",\n    resourceType: \"0x1::account::OriginatingAddress\",\n    options\n  });\n  const {\n    address_map: {\n      handle\n    }\n  } = resource;\n  try {\n    const originalAddress = await getTableItem({\n      aptosConfig,\n      handle,\n      data: {\n        key: Hex.fromHexInput(authenticationKey).toString(),\n        key_type: \"address\",\n        value_type: \"address\"\n      },\n      options\n    });\n    return AccountAddress.fromHexInput(originalAddress);\n  } catch (err) {\n    if (err instanceof AptosApiError && err.data.error_code === \"table_item_not_found\") {\n      return AccountAddress.fromHexInput(authenticationKey);\n    }\n    throw err;\n  }\n}\nasync function getAccountTokensCount(args) {\n  const {\n    aptosConfig,\n    accountAddress\n  } = args;\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n  const whereCondition = {\n    owner_address: {\n      _eq: address\n    },\n    amount: {\n      _gt: \"0\"\n    }\n  };\n  const graphqlQuery = {\n    query: GetAccountTokensCount,\n    variables: {\n      where_condition: whereCondition\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountTokensCount\"\n  });\n  if (!data.current_token_ownerships_v2_aggregate.aggregate) {\n    throw Error(\"Failed to get the count of account tokens\");\n  }\n  return data.current_token_ownerships_v2_aggregate.aggregate.count;\n}\nasync function getAccountOwnedTokens(args) {\n  var _a, _b;\n  const {\n    aptosConfig,\n    accountAddress,\n    options\n  } = args;\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n  const whereCondition = {\n    owner_address: {\n      _eq: address\n    },\n    amount: {\n      _gt: 0\n    }\n  };\n  if (options == null ? void 0 : options.tokenStandard) {\n    whereCondition.token_standard = {\n      _eq: options == null ? void 0 : options.tokenStandard\n    };\n  }\n  const graphqlQuery = {\n    query: GetAccountOwnedTokens,\n    variables: {\n      where_condition: whereCondition,\n      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,\n      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,\n      order_by: options == null ? void 0 : options.orderBy\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedTokens\"\n  });\n  return data.current_token_ownerships_v2;\n}\nasync function getAccountOwnedTokensFromCollectionAddress(args) {\n  var _a, _b;\n  const {\n    aptosConfig,\n    accountAddress,\n    collectionAddress,\n    options\n  } = args;\n  const ownerAddress = AccountAddress.fromHexInput(accountAddress).toString();\n  const collAddress = Hex.fromHexInput(collectionAddress).toString();\n  const whereCondition = {\n    owner_address: {\n      _eq: ownerAddress\n    },\n    current_token_data: {\n      collection_id: {\n        _eq: collAddress\n      }\n    },\n    amount: {\n      _gt: 0\n    }\n  };\n  if (options == null ? void 0 : options.tokenStandard) {\n    whereCondition.token_standard = {\n      _eq: options == null ? void 0 : options.tokenStandard\n    };\n  }\n  const graphqlQuery = {\n    query: GetAccountOwnedTokensFromCollection,\n    variables: {\n      where_condition: whereCondition,\n      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,\n      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,\n      order_by: options == null ? void 0 : options.orderBy\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedTokensFromCollectionAddress\"\n  });\n  return data.current_token_ownerships_v2;\n}\nasync function getAccountCollectionsWithOwnedTokens(args) {\n  var _a, _b;\n  const {\n    aptosConfig,\n    accountAddress,\n    options\n  } = args;\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n  const whereCondition = {\n    owner_address: {\n      _eq: address\n    },\n    amount: {\n      _gt: 0\n    }\n  };\n  if (options == null ? void 0 : options.tokenStandard) {\n    whereCondition.current_collection = {\n      token_standard: {\n        _eq: options == null ? void 0 : options.tokenStandard\n      }\n    };\n  }\n  const graphqlQuery = {\n    query: GetAccountCollectionsWithOwnedTokens,\n    variables: {\n      where_condition: whereCondition,\n      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,\n      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,\n      order_by: options == null ? void 0 : options.orderBy\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCollectionsWithOwnedTokens\"\n  });\n  return data.current_collection_ownership_v2_view;\n}\nasync function getAccountTransactionsCount(args) {\n  const {\n    aptosConfig,\n    accountAddress\n  } = args;\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n  const graphqlQuery = {\n    query: GetAccountTransactionsCount,\n    variables: {\n      address\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountTransactionsCount\"\n  });\n  if (!data.account_transactions_aggregate.aggregate) {\n    throw Error(\"Failed to get the count of account transactions\");\n  }\n  return data.account_transactions_aggregate.aggregate.count;\n}\nasync function getAccountCoinsData(args) {\n  var _a, _b;\n  const {\n    aptosConfig,\n    accountAddress,\n    options\n  } = args;\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n  const whereCondition = {\n    owner_address: {\n      _eq: address\n    }\n  };\n  const graphqlQuery = {\n    query: GetAccountCoinsData,\n    variables: {\n      where_condition: whereCondition,\n      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,\n      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,\n      order_by: options == null ? void 0 : options.orderBy\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCoinsData\"\n  });\n  return data.current_fungible_asset_balances;\n}\nasync function getAccountCoinsCount(args) {\n  const {\n    aptosConfig,\n    accountAddress\n  } = args;\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n  const graphqlQuery = {\n    query: GetAccountCoinsCount,\n    variables: {\n      address\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCoinsCount\"\n  });\n  if (!data.current_fungible_asset_balances_aggregate.aggregate) {\n    throw Error(\"Failed to get the count of account coins\");\n  }\n  return data.current_fungible_asset_balances_aggregate.aggregate.count;\n}\nasync function getAccountOwnedObjects(args) {\n  var _a, _b;\n  const {\n    aptosConfig,\n    accountAddress,\n    options\n  } = args;\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n  const whereCondition = {\n    owner_address: {\n      _eq: address\n    }\n  };\n  const graphqlQuery = {\n    query: GetAccountOwnedObjects,\n    variables: {\n      where_condition: whereCondition,\n      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,\n      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,\n      order_by: options == null ? void 0 : options.orderBy\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedObjects\"\n  });\n  return data.current_objects;\n}\nasync function deriveAccountFromPrivateKey(args) {\n  const {\n    aptosConfig,\n    privateKey\n  } = args;\n  const publicKey = new AnyPublicKey(privateKey.publicKey());\n  if (privateKey instanceof Secp256k1PrivateKey) {\n    const authKey = AuthenticationKey.fromPublicKeyAndScheme({\n      publicKey,\n      scheme: 2 /* SingleKey */\n    });\n    const address = new AccountAddress({\n      data: authKey.toUint8Array()\n    });\n    return Account.fromPrivateKeyAndAddress({\n      privateKey,\n      address\n    });\n  }\n  if (privateKey instanceof Ed25519PrivateKey) {\n    const SingleSenderTransactionAuthenticatorAuthKey = AuthenticationKey.fromPublicKeyAndScheme({\n      publicKey,\n      scheme: 2 /* SingleKey */\n    });\n    const isSingleSenderTransactionAuthenticator = await isAccountExist({\n      authKey: SingleSenderTransactionAuthenticatorAuthKey,\n      aptosConfig\n    });\n    if (isSingleSenderTransactionAuthenticator) {\n      const address = new AccountAddress({\n        data: SingleSenderTransactionAuthenticatorAuthKey.toUint8Array()\n      });\n      return Account.fromPrivateKeyAndAddress({\n        privateKey,\n        address\n      });\n    }\n    const legacyAuthKey = AuthenticationKey.fromPublicKeyAndScheme({\n      publicKey,\n      scheme: 0 /* Ed25519 */\n    });\n    const isLegacyEd25519 = await isAccountExist({\n      authKey: legacyAuthKey,\n      aptosConfig\n    });\n    if (isLegacyEd25519) {\n      const address = new AccountAddress({\n        data: legacyAuthKey.toUint8Array()\n      });\n      return Account.fromPrivateKeyAndAddress({\n        privateKey,\n        address,\n        legacy: true\n      });\n    }\n  }\n  throw new Error(`Can't derive account from private key ${privateKey}`);\n}\nasync function isAccountExist(args) {\n  const {\n    aptosConfig,\n    authKey\n  } = args;\n  const accountAddress = await lookupOriginalAccountAddress({\n    aptosConfig,\n    authenticationKey: authKey.toString()\n  });\n  try {\n    await getInfo({\n      aptosConfig,\n      accountAddress: accountAddress.toString()\n    });\n    return true;\n  } catch (error) {\n    if (error.status === 404) {\n      return false;\n    }\n    throw new Error(`Error while looking for an account info ${accountAddress.toString()}`);\n  }\n}\n\n// src/api/account.ts\nvar Account2 = class {\n  constructor(config) {\n    this.config = config;\n  }\n  async getAccountInfo(args) {\n    return getInfo({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountModules(args) {\n    return getModules({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountModule(args) {\n    return getModule({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountTransactions(args) {\n    return getTransactions({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountResources(args) {\n    return getResources({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountResource(args) {\n    return getResource({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async lookupOriginalAccountAddress(args) {\n    return lookupOriginalAccountAddress({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountTokensCount(args) {\n    return getAccountTokensCount({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountOwnedTokens(args) {\n    return getAccountOwnedTokens({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountOwnedTokensFromCollectionAddress(args) {\n    return getAccountOwnedTokensFromCollectionAddress({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountCollectionsWithOwnedTokens(args) {\n    return getAccountCollectionsWithOwnedTokens({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountTransactionsCount(args) {\n    return getAccountTransactionsCount({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountCoinsData(args) {\n    return getAccountCoinsData({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountCoinsCount(args) {\n    return getAccountCoinsCount({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountOwnedObjects(args) {\n    return getAccountOwnedObjects({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async deriveAccountFromPrivateKey(args) {\n    return deriveAccountFromPrivateKey({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n};\n\n// src/api/aptosConfig.ts\nimport aptosClient from \"@aptos-labs/aptos-client\";\nvar AptosConfig = class {\n  constructor(settings) {\n    var _a, _b, _c;\n    this.network = (_a = settings == null ? void 0 : settings.network) != null ? _a : DEFAULT_NETWORK;\n    this.fullnode = settings == null ? void 0 : settings.fullnode;\n    this.faucet = settings == null ? void 0 : settings.faucet;\n    this.indexer = settings == null ? void 0 : settings.indexer;\n    this.client = (_b = settings == null ? void 0 : settings.client) != null ? _b : {\n      provider: aptosClient\n    };\n    this.clientConfig = (_c = settings == null ? void 0 : settings.clientConfig) != null ? _c : {};\n  }\n  getRequestUrl(apiType) {\n    switch (apiType) {\n      case 0 /* FULLNODE */:\n        if (this.fullnode !== void 0) return this.fullnode;\n        if (this.network === \"custom\" /* CUSTOM */) throw new Error(\"Please provide a custom full node url\");\n        return NetworkToNodeAPI[this.network];\n      case 2 /* FAUCET */:\n        if (this.faucet !== void 0) return this.faucet;\n        if (this.network === \"custom\" /* CUSTOM */) throw new Error(\"Please provide a custom faucet url\");\n        return NetworkToFaucetAPI[this.network];\n      case 1 /* INDEXER */:\n        if (this.indexer !== void 0) return this.indexer;\n        if (this.network === \"custom\" /* CUSTOM */) throw new Error(\"Please provide a custom indexer url\");\n        return NetworkToIndexerAPI[this.network];\n      default:\n        throw Error(`apiType ${apiType} is not supported`);\n    }\n  }\n  isIndexerRequest(url) {\n    return NetworkToIndexerAPI[this.network] === url;\n  }\n};\n\n// src/transactions/transactionBuilder/transactionBuilder.ts\nimport { sha3_256 as sha3Hash2 } from \"@noble/hashes/sha3\";\n\n// src/core/crypto/anySignature.ts\nvar AnySignature = class extends Signature {\n  constructor(signature) {\n    super();\n    this.signature = signature;\n  }\n  toUint8Array() {\n    return this.signature.toUint8Array();\n  }\n  toString() {\n    return this.signature.toString();\n  }\n  serialize(serializer) {\n    if (this.signature instanceof Ed25519Signature) {\n      serializer.serializeU32AsUleb128(0 /* Ed25519 */);\n      this.signature.serialize(serializer);\n    } else if (this.signature instanceof Secp256k1Signature) {\n      serializer.serializeU32AsUleb128(1 /* Secp256k1 */);\n      this.signature.serialize(serializer);\n    } else {\n      throw new Error(\"Unknown signature type\");\n    }\n  }\n  static deserialize(deserializer) {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case 0 /* Ed25519 */:\n        return new AnySignature(Ed25519Signature.load(deserializer));\n      case 1 /* Secp256k1 */:\n        return new AnySignature(Secp256k1Signature.load(deserializer));\n      default:\n        throw new Error(`Unknown variant index for AnySignature: ${index}`);\n    }\n  }\n};\n\n// src/utils/helpers.ts\nasync function sleep(timeMs) {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeMs);\n  });\n}\n\n// src/internal/transaction.ts\nasync function getTransactions2(args) {\n  const {\n    aptosConfig,\n    options\n  } = args;\n  return paginateWithCursor({\n    aptosConfig,\n    originMethod: \"getTransactions\",\n    path: \"transactions\",\n    params: {\n      start: options == null ? void 0 : options.offset,\n      limit: options == null ? void 0 : options.limit\n    }\n  });\n}\nasync function getGasPriceEstimation(args) {\n  const {\n    aptosConfig\n  } = args;\n  return memoizeAsync(async () => {\n    const {\n      data\n    } = await getAptosFullNode({\n      aptosConfig,\n      originMethod: \"getGasPriceEstimation\",\n      path: \"estimate_gas_price\"\n    });\n    return data;\n  }, `gas-price-${aptosConfig.network}`, 1e3 * 60 * 5)();\n}\nasync function getTransactionByVersion(args) {\n  const {\n    aptosConfig,\n    ledgerVersion\n  } = args;\n  const {\n    data\n  } = await getAptosFullNode({\n    aptosConfig,\n    originMethod: \"getTransactionByVersion\",\n    path: `transactions/by_version/${ledgerVersion}`\n  });\n  return data;\n}\nasync function getTransactionByHash(args) {\n  const {\n    aptosConfig,\n    transactionHash\n  } = args;\n  const {\n    data\n  } = await getAptosFullNode({\n    aptosConfig,\n    path: `transactions/by_hash/${transactionHash}`,\n    originMethod: \"getTransactionByHash\"\n  });\n  return data;\n}\nasync function isTransactionPending(args) {\n  const {\n    aptosConfig,\n    transactionHash\n  } = args;\n  try {\n    const transaction = await getTransactionByHash({\n      aptosConfig,\n      transactionHash\n    });\n    return transaction.type === \"pending_transaction\" /* Pending */;\n  } catch (e) {\n    if ((e == null ? void 0 : e.status) === 404) {\n      return true;\n    }\n    throw e;\n  }\n}\nasync function waitForTransaction(args) {\n  var _a, _b, _c;\n  const {\n    aptosConfig,\n    transactionHash,\n    options\n  } = args;\n  const timeoutSecs = (_a = options == null ? void 0 : options.timeoutSecs) != null ? _a : DEFAULT_TXN_TIMEOUT_SEC;\n  const checkSuccess = (_b = options == null ? void 0 : options.checkSuccess) != null ? _b : true;\n  const indexerVersionCheck = (_c = options == null ? void 0 : options.indexerVersionCheck) != null ? _c : true;\n  let isPending = true;\n  let timeElapsed = 0;\n  let lastTxn;\n  let lastError;\n  let backoffIntervalMs = 200;\n  const backoffMultiplier = 1.5;\n  while (isPending) {\n    if (timeElapsed >= timeoutSecs) {\n      break;\n    }\n    try {\n      lastTxn = await getTransactionByHash({\n        aptosConfig,\n        transactionHash\n      });\n      isPending = lastTxn.type === \"pending_transaction\" /* Pending */;\n      if (!isPending) {\n        break;\n      }\n    } catch (e) {\n      const isAptosApiError = e instanceof AptosApiError;\n      if (!isAptosApiError) {\n        throw e;\n      }\n      lastError = e;\n      const isRequestError = e.status !== 404 && e.status >= 400 && e.status < 500;\n      if (isRequestError) {\n        throw e;\n      }\n    }\n    await sleep(backoffIntervalMs);\n    timeElapsed += backoffIntervalMs / 1e3;\n    backoffIntervalMs *= backoffMultiplier;\n  }\n  if (lastTxn === void 0) {\n    if (lastError) {\n      throw lastError;\n    } else {\n      throw new WaitForTransactionError(`Fetching transaction ${transactionHash} failed and timed out after ${timeoutSecs} seconds`, lastTxn);\n    }\n  }\n  if (lastTxn.type === \"pending_transaction\" /* Pending */) {\n    throw new WaitForTransactionError(`Transaction ${transactionHash} timed out in pending state after ${timeoutSecs} seconds`, lastTxn);\n  }\n  if (!checkSuccess) {\n    return lastTxn;\n  }\n  if (!lastTxn.success) {\n    throw new FailedTransactionError(`Transaction ${transactionHash} failed with an error: ${lastTxn.vm_status}`, lastTxn);\n  }\n  if (indexerVersionCheck) {\n    try {\n      await waitForLastSuccessIndexerVersionSync({\n        aptosConfig,\n        ledgerVersion: Number(lastTxn.version)\n      });\n    } catch (_e) {\n      throw new WaitForTransactionError(`Transaction ${transactionHash} committed, but timed out waiting for indexer to sync with ledger version ${lastTxn.version}.You can disable this check by setting \\`indexerVersionCheck\\` to false in the \\`extraArgs\\` parameter.`, lastTxn);\n    }\n  }\n  return lastTxn;\n}\nasync function waitForLastSuccessIndexerVersionSync(args) {\n  const {\n    aptosConfig,\n    ledgerVersion\n  } = args;\n  const timeoutMilliseconds = 3e3;\n  const startTime = new Date().getTime();\n  let indexerVersion = -1;\n  while (indexerVersion < ledgerVersion) {\n    if (new Date().getTime() - startTime > timeoutMilliseconds) {\n      throw new Error(\"waitForLastSuccessIndexerVersionSync timeout\");\n    }\n    indexerVersion = await getIndexerLastSuccessVersion({\n      aptosConfig\n    });\n    if (indexerVersion >= ledgerVersion) {\n      break;\n    }\n    await sleep(200);\n  }\n}\nvar WaitForTransactionError = class extends Error {\n  constructor(message, lastSubmittedTransaction) {\n    super(message);\n    this.lastSubmittedTransaction = lastSubmittedTransaction;\n  }\n};\nvar FailedTransactionError = class extends Error {\n  constructor(message, transaction) {\n    super(message);\n    this.transaction = transaction;\n  }\n};\n\n// src/transactions/authenticator/account.ts\nvar AccountAuthenticator = class extends Serializable {\n  static deserialize(deserializer) {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case 0 /* Ed25519 */:\n        return AccountAuthenticatorEd25519.load(deserializer);\n      case 1 /* MultiEd25519 */:\n        return AccountAuthenticatorMultiEd25519.load(deserializer);\n      case 2 /* SingleKey */:\n        return AccountAuthenticatorSingleKey.load(deserializer);\n      case 3 /* MultiKey */:\n        return AccountAuthenticatorMultiKey.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for AccountAuthenticator: ${index}`);\n    }\n  }\n};\nvar AccountAuthenticatorEd25519 = class extends AccountAuthenticator {\n  constructor(public_key, signature) {\n    super();\n    this.public_key = public_key;\n    this.signature = signature;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(0 /* Ed25519 */);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n  static load(deserializer) {\n    const public_key = Ed25519PublicKey.deserialize(deserializer);\n    const signature = Ed25519Signature.deserialize(deserializer);\n    return new AccountAuthenticatorEd25519(public_key, signature);\n  }\n};\nvar AccountAuthenticatorMultiEd25519 = class extends AccountAuthenticator {\n  constructor(public_key, signature) {\n    super();\n    this.public_key = public_key;\n    this.signature = signature;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(1 /* MultiEd25519 */);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n  static load(deserializer) {\n    const public_key = MultiEd25519PublicKey.deserialize(deserializer);\n    const signature = MultiEd25519Signature.deserialize(deserializer);\n    return new AccountAuthenticatorMultiEd25519(public_key, signature);\n  }\n};\nvar AccountAuthenticatorSingleKey = class extends AccountAuthenticator {\n  constructor(public_key, signature) {\n    super();\n    this.public_key = public_key;\n    this.signature = signature;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(2 /* SingleKey */);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n  static load(deserializer) {\n    const public_key = AnyPublicKey.deserialize(deserializer);\n    const signature = AnySignature.deserialize(deserializer);\n    return new AccountAuthenticatorSingleKey(public_key, signature);\n  }\n};\nvar AccountAuthenticatorMultiKey = class extends AccountAuthenticator {\n  constructor(public_keys, signatures, signatures_bitmap) {\n    super();\n    this.public_keys = public_keys;\n    this.signatures = signatures;\n    this.signatures_bitmap = signatures_bitmap;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(3 /* MultiKey */);\n    this.public_keys.serialize(serializer);\n    serializer.serializeVector(this.signatures);\n    serializer.serializeBytes(this.signatures_bitmap);\n  }\n  static load(deserializer) {\n    const public_keys = MultiKey.deserialize(deserializer);\n    const signatures = deserializer.deserializeVector(AnySignature);\n    const signatures_bitmap = deserializer.deserializeBytes();\n    return new AccountAuthenticatorMultiKey(public_keys, signatures, signatures_bitmap);\n  }\n};\n\n// src/transactions/authenticator/transaction.ts\nvar TransactionAuthenticator = class extends Serializable {\n  static deserialize(deserializer) {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case 0 /* Ed25519 */:\n        return TransactionAuthenticatorEd25519.load(deserializer);\n      case 1 /* MultiEd25519 */:\n        return TransactionAuthenticatorMultiEd25519.load(deserializer);\n      case 2 /* MultiAgent */:\n        return TransactionAuthenticatorMultiAgent.load(deserializer);\n      case 3 /* FeePayer */:\n        return TransactionAuthenticatorFeePayer.load(deserializer);\n      case 4 /* SingleSender */:\n        return TransactionAuthenticatorSingleSender.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for TransactionAuthenticator: ${index}`);\n    }\n  }\n};\nvar TransactionAuthenticatorEd25519 = class extends TransactionAuthenticator {\n  constructor(public_key, signature) {\n    super();\n    this.public_key = public_key;\n    this.signature = signature;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(0 /* Ed25519 */);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n  static load(deserializer) {\n    const public_key = Ed25519PublicKey.deserialize(deserializer);\n    const signature = Ed25519Signature.deserialize(deserializer);\n    return new TransactionAuthenticatorEd25519(public_key, signature);\n  }\n};\nvar TransactionAuthenticatorMultiEd25519 = class extends TransactionAuthenticator {\n  constructor(public_key, signature) {\n    super();\n    this.public_key = public_key;\n    this.signature = signature;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(1 /* MultiEd25519 */);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n  static load(deserializer) {\n    const public_key = MultiEd25519PublicKey.deserialize(deserializer);\n    const signature = MultiEd25519Signature.deserialize(deserializer);\n    return new TransactionAuthenticatorMultiEd25519(public_key, signature);\n  }\n};\nvar TransactionAuthenticatorMultiAgent = class extends TransactionAuthenticator {\n  constructor(sender, secondary_signer_addresses, secondary_signers) {\n    super();\n    this.sender = sender;\n    this.secondary_signer_addresses = secondary_signer_addresses;\n    this.secondary_signers = secondary_signers;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(2 /* MultiAgent */);\n    this.sender.serialize(serializer);\n    serializer.serializeVector(this.secondary_signer_addresses);\n    serializer.serializeVector(this.secondary_signers);\n  }\n  static load(deserializer) {\n    const sender = AccountAuthenticator.deserialize(deserializer);\n    const secondary_signer_addresses = deserializer.deserializeVector(AccountAddress);\n    const secondary_signers = deserializer.deserializeVector(AccountAuthenticator);\n    return new TransactionAuthenticatorMultiAgent(sender, secondary_signer_addresses, secondary_signers);\n  }\n};\nvar TransactionAuthenticatorFeePayer = class extends TransactionAuthenticator {\n  constructor(sender, secondary_signer_addresses, secondary_signers, fee_payer) {\n    super();\n    this.sender = sender;\n    this.secondary_signer_addresses = secondary_signer_addresses;\n    this.secondary_signers = secondary_signers;\n    this.fee_payer = fee_payer;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(3 /* FeePayer */);\n    this.sender.serialize(serializer);\n    serializer.serializeVector(this.secondary_signer_addresses);\n    serializer.serializeVector(this.secondary_signers);\n    this.fee_payer.address.serialize(serializer);\n    this.fee_payer.authenticator.serialize(serializer);\n  }\n  static load(deserializer) {\n    const sender = AccountAuthenticator.deserialize(deserializer);\n    const secondary_signer_addresses = deserializer.deserializeVector(AccountAddress);\n    const secondary_signers = deserializer.deserializeVector(AccountAuthenticator);\n    const address = AccountAddress.deserialize(deserializer);\n    const authenticator = AccountAuthenticator.deserialize(deserializer);\n    const fee_payer = {\n      address,\n      authenticator\n    };\n    return new TransactionAuthenticatorFeePayer(sender, secondary_signer_addresses, secondary_signers, fee_payer);\n  }\n};\nvar TransactionAuthenticatorSingleSender = class extends TransactionAuthenticator {\n  constructor(sender) {\n    super();\n    this.sender = sender;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(4 /* SingleSender */);\n    this.sender.serialize(serializer);\n  }\n  static load(deserializer) {\n    const sender = AccountAuthenticator.deserialize(deserializer);\n    return new TransactionAuthenticatorSingleSender(sender);\n  }\n};\n\n// src/transactions/instances/chainId.ts\nvar ChainId = class extends Serializable {\n  constructor(chainId) {\n    super();\n    this.chainId = chainId;\n  }\n  serialize(serializer) {\n    serializer.serializeU8(this.chainId);\n  }\n  static deserialize(deserializer) {\n    const chainId = deserializer.deserializeU8();\n    return new ChainId(chainId);\n  }\n};\n\n// src/transactions/instances/identifier.ts\nvar Identifier = class extends Serializable {\n  constructor(identifier) {\n    super();\n    this.identifier = identifier;\n  }\n  serialize(serializer) {\n    serializer.serializeStr(this.identifier);\n  }\n  static deserialize(deserializer) {\n    const identifier = deserializer.deserializeStr();\n    return new Identifier(identifier);\n  }\n};\n\n// src/transactions/instances/moduleId.ts\nvar ModuleId = class extends Serializable {\n  constructor(address, name) {\n    super();\n    this.address = address;\n    this.name = name;\n  }\n  static fromStr(moduleId) {\n    const parts = moduleId.split(\"::\");\n    if (parts.length !== 2) {\n      throw new Error(\"Invalid module id.\");\n    }\n    return new ModuleId(AccountAddress.fromString(parts[0]), new Identifier(parts[1]));\n  }\n  serialize(serializer) {\n    this.address.serialize(serializer);\n    this.name.serialize(serializer);\n  }\n  static deserialize(deserializer) {\n    const address = AccountAddress.deserialize(deserializer);\n    const name = Identifier.deserialize(deserializer);\n    return new ModuleId(address, name);\n  }\n};\n\n// src/transactions/typeTag/index.ts\nvar TypeTag = class extends Serializable {\n  static deserialize(deserializer) {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case 0 /* Bool */:\n        return TypeTagBool.load(deserializer);\n      case 1 /* U8 */:\n        return TypeTagU8.load(deserializer);\n      case 2 /* U64 */:\n        return TypeTagU64.load(deserializer);\n      case 3 /* U128 */:\n        return TypeTagU128.load(deserializer);\n      case 4 /* Address */:\n        return TypeTagAddress.load(deserializer);\n      case 5 /* Signer */:\n        return TypeTagSigner.load(deserializer);\n      case 6 /* Vector */:\n        return TypeTagVector.load(deserializer);\n      case 7 /* Struct */:\n        return TypeTagStruct.load(deserializer);\n      case 8 /* U16 */:\n        return TypeTagU16.load(deserializer);\n      case 9 /* U32 */:\n        return TypeTagU32.load(deserializer);\n      case 10 /* U256 */:\n        return TypeTagU256.load(deserializer);\n      case 255 /* Generic */:\n        return TypeTagGeneric.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for TypeTag: ${index}`);\n    }\n  }\n  isBool() {\n    return this instanceof TypeTagBool;\n  }\n  isAddress() {\n    return this instanceof TypeTagAddress;\n  }\n  isGeneric() {\n    return this instanceof TypeTagGeneric;\n  }\n  isSigner() {\n    return this instanceof TypeTagSigner;\n  }\n  isVector() {\n    return this instanceof TypeTagVector;\n  }\n  isStruct() {\n    return this instanceof TypeTagStruct;\n  }\n  isU8() {\n    return this instanceof TypeTagU8;\n  }\n  isU16() {\n    return this instanceof TypeTagU16;\n  }\n  isU32() {\n    return this instanceof TypeTagU32;\n  }\n  isU64() {\n    return this instanceof TypeTagU64;\n  }\n  isU128() {\n    return this instanceof TypeTagU128;\n  }\n  isU256() {\n    return this instanceof TypeTagU256;\n  }\n};\nvar TypeTagBool = class extends TypeTag {\n  toString() {\n    return \"bool\";\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(0 /* Bool */);\n  }\n  static load(_deserializer) {\n    return new TypeTagBool();\n  }\n};\nvar TypeTagU8 = class extends TypeTag {\n  toString() {\n    return \"u8\";\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(1 /* U8 */);\n  }\n  static load(_deserializer) {\n    return new TypeTagU8();\n  }\n};\nvar TypeTagU16 = class extends TypeTag {\n  toString() {\n    return \"u16\";\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(8 /* U16 */);\n  }\n  static load(_deserializer) {\n    return new TypeTagU16();\n  }\n};\nvar TypeTagU32 = class extends TypeTag {\n  toString() {\n    return \"u32\";\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(9 /* U32 */);\n  }\n  static load(_deserializer) {\n    return new TypeTagU32();\n  }\n};\nvar TypeTagU64 = class extends TypeTag {\n  toString() {\n    return \"u64\";\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(2 /* U64 */);\n  }\n  static load(_deserializer) {\n    return new TypeTagU64();\n  }\n};\nvar TypeTagU128 = class extends TypeTag {\n  toString() {\n    return \"u128\";\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(3 /* U128 */);\n  }\n  static load(_deserializer) {\n    return new TypeTagU128();\n  }\n};\nvar TypeTagU256 = class extends TypeTag {\n  toString() {\n    return \"u256\";\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(10 /* U256 */);\n  }\n  static load(_deserializer) {\n    return new TypeTagU256();\n  }\n};\nvar TypeTagAddress = class extends TypeTag {\n  toString() {\n    return \"address\";\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(4 /* Address */);\n  }\n  static load(_deserializer) {\n    return new TypeTagAddress();\n  }\n};\nvar TypeTagSigner = class extends TypeTag {\n  toString() {\n    return \"signer\";\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(5 /* Signer */);\n  }\n  static load(_deserializer) {\n    return new TypeTagSigner();\n  }\n};\nvar TypeTagReference = class extends TypeTag {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  toString() {\n    return `&${this.value.toString()}`;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(254 /* Reference */);\n  }\n  static load(deserializer) {\n    const value = TypeTag.deserialize(deserializer);\n    return new TypeTagReference(value);\n  }\n};\nvar TypeTagGeneric = class extends TypeTag {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  toString() {\n    return `T${this.value}`;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(255 /* Generic */);\n    serializer.serializeU32(this.value);\n  }\n  static load(deserializer) {\n    const value = deserializer.deserializeU32();\n    return new TypeTagGeneric(value);\n  }\n};\nvar TypeTagVector = class extends TypeTag {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  toString() {\n    return `vector<${this.value.toString()}>`;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(6 /* Vector */);\n    this.value.serialize(serializer);\n  }\n  static load(deserializer) {\n    const value = TypeTag.deserialize(deserializer);\n    return new TypeTagVector(value);\n  }\n};\nvar TypeTagStruct = class extends TypeTag {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  toString() {\n    let typePredicate = \"\";\n    if (this.value.type_args.length > 0) {\n      typePredicate = `<${this.value.type_args.map(typeArg => typeArg.toString()).join(\", \")}>`;\n    }\n    return `${this.value.address.toString()}::${this.value.module_name.identifier}::${this.value.name.identifier}${typePredicate}`;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(7 /* Struct */);\n    this.value.serialize(serializer);\n  }\n  static load(deserializer) {\n    const value = StructTag.deserialize(deserializer);\n    return new TypeTagStruct(value);\n  }\n  isTypeTag(address, moduleName, structName) {\n    return this.value.module_name.identifier === moduleName && this.value.name.identifier === structName && this.value.address.equals(address);\n  }\n  isString() {\n    return this.isTypeTag(AccountAddress.ONE, \"string\", \"String\");\n  }\n  isOption() {\n    return this.isTypeTag(AccountAddress.ONE, \"option\", \"Option\");\n  }\n  isObject() {\n    return this.isTypeTag(AccountAddress.ONE, \"object\", \"Object\");\n  }\n};\nvar StructTag = class extends Serializable {\n  constructor(address, module_name, name, type_args) {\n    super();\n    this.address = address;\n    this.module_name = module_name;\n    this.name = name;\n    this.type_args = type_args;\n  }\n  serialize(serializer) {\n    serializer.serialize(this.address);\n    serializer.serialize(this.module_name);\n    serializer.serialize(this.name);\n    serializer.serializeVector(this.type_args);\n  }\n  static deserialize(deserializer) {\n    const address = AccountAddress.deserialize(deserializer);\n    const moduleName = Identifier.deserialize(deserializer);\n    const name = Identifier.deserialize(deserializer);\n    const typeArgs = deserializer.deserializeVector(TypeTag);\n    return new StructTag(address, moduleName, name, typeArgs);\n  }\n};\nfunction aptosCoinStructTag() {\n  return new StructTag(AccountAddress.ONE, new Identifier(\"aptos_coin\"), new Identifier(\"AptosCoin\"), []);\n}\nfunction stringStructTag() {\n  return new StructTag(AccountAddress.ONE, new Identifier(\"string\"), new Identifier(\"String\"), []);\n}\nfunction optionStructTag(typeArg) {\n  return new StructTag(AccountAddress.ONE, new Identifier(\"option\"), new Identifier(\"Option\"), [typeArg]);\n}\nfunction objectStructTag(typeArg) {\n  return new StructTag(AccountAddress.ONE, new Identifier(\"object\"), new Identifier(\"Object\"), [typeArg]);\n}\n\n// src/transactions/instances/transactionPayload.ts\nfunction deserializeFromScriptArgument(deserializer) {\n  const index = deserializer.deserializeUleb128AsU32();\n  switch (index) {\n    case 0 /* U8 */:\n      return U8.deserialize(deserializer);\n    case 1 /* U64 */:\n      return U64.deserialize(deserializer);\n    case 2 /* U128 */:\n      return U128.deserialize(deserializer);\n    case 3 /* Address */:\n      return AccountAddress.deserialize(deserializer);\n    case 4 /* U8Vector */:\n      return MoveVector.deserialize(deserializer, U8);\n    case 5 /* Bool */:\n      return Bool.deserialize(deserializer);\n    case 6 /* U16 */:\n      return U16.deserialize(deserializer);\n    case 7 /* U32 */:\n      return U32.deserialize(deserializer);\n    case 8 /* U256 */:\n      return U256.deserialize(deserializer);\n    default:\n      throw new Error(`Unknown variant index for ScriptTransactionArgument: ${index}`);\n  }\n}\nvar TransactionPayload = class extends Serializable {\n  static deserialize(deserializer) {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case 0 /* Script */:\n        return TransactionPayloadScript.load(deserializer);\n      case 2 /* EntryFunction */:\n        return TransactionPayloadEntryFunction.load(deserializer);\n      case 3 /* Multisig */:\n        return TransactionPayloadMultisig.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for TransactionPayload: ${index}`);\n    }\n  }\n};\nvar TransactionPayloadScript = class extends TransactionPayload {\n  constructor(script) {\n    super();\n    this.script = script;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(0 /* Script */);\n    this.script.serialize(serializer);\n  }\n  static load(deserializer) {\n    const script = Script.deserialize(deserializer);\n    return new TransactionPayloadScript(script);\n  }\n};\nvar TransactionPayloadEntryFunction = class extends TransactionPayload {\n  constructor(entryFunction) {\n    super();\n    this.entryFunction = entryFunction;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(2 /* EntryFunction */);\n    this.entryFunction.serialize(serializer);\n  }\n  static load(deserializer) {\n    const entryFunction = EntryFunction.deserialize(deserializer);\n    return new TransactionPayloadEntryFunction(entryFunction);\n  }\n};\nvar TransactionPayloadMultisig = class extends TransactionPayload {\n  constructor(multiSig) {\n    super();\n    this.multiSig = multiSig;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(3 /* Multisig */);\n    this.multiSig.serialize(serializer);\n  }\n  static load(deserializer) {\n    const multiSig = MultiSig.deserialize(deserializer);\n    return new TransactionPayloadMultisig(multiSig);\n  }\n};\nvar EntryFunction = class {\n  constructor(module_name, function_name, type_args, args) {\n    this.module_name = module_name;\n    this.function_name = function_name;\n    this.type_args = type_args;\n    this.args = args;\n  }\n  static build(module_id, function_name, type_args, args) {\n    return new EntryFunction(ModuleId.fromStr(module_id), new Identifier(function_name), type_args, args);\n  }\n  serialize(serializer) {\n    this.module_name.serialize(serializer);\n    this.function_name.serialize(serializer);\n    serializer.serializeVector(this.type_args);\n    serializer.serializeU32AsUleb128(this.args.length);\n    this.args.forEach(item => {\n      item.serializeForEntryFunction(serializer);\n    });\n  }\n  static deserialize(deserializer) {\n    const module_name = ModuleId.deserialize(deserializer);\n    const function_name = Identifier.deserialize(deserializer);\n    const type_args = deserializer.deserializeVector(TypeTag);\n    const length = deserializer.deserializeUleb128AsU32();\n    const args = new Array();\n    for (let i = 0; i < length; i += 1) {\n      const fixedBytesLength = deserializer.deserializeUleb128AsU32();\n      const fixedBytes = EntryFunctionBytes.deserialize(deserializer, fixedBytesLength);\n      args.push(fixedBytes);\n    }\n    return new EntryFunction(module_name, function_name, type_args, args);\n  }\n};\nvar Script = class {\n  constructor(bytecode, type_args, args) {\n    this.bytecode = bytecode;\n    this.type_args = type_args;\n    this.args = args;\n  }\n  serialize(serializer) {\n    serializer.serializeBytes(this.bytecode);\n    serializer.serializeVector(this.type_args);\n    serializer.serializeU32AsUleb128(this.args.length);\n    this.args.forEach(item => {\n      item.serializeForScriptFunction(serializer);\n    });\n  }\n  static deserialize(deserializer) {\n    const bytecode = deserializer.deserializeBytes();\n    const type_args = deserializer.deserializeVector(TypeTag);\n    const length = deserializer.deserializeUleb128AsU32();\n    const args = new Array();\n    for (let i = 0; i < length; i += 1) {\n      const scriptArgument = deserializeFromScriptArgument(deserializer);\n      args.push(scriptArgument);\n    }\n    return new Script(bytecode, type_args, args);\n  }\n};\nvar MultiSig = class {\n  constructor(multisig_address, transaction_payload) {\n    this.multisig_address = multisig_address;\n    this.transaction_payload = transaction_payload;\n  }\n  serialize(serializer) {\n    this.multisig_address.serialize(serializer);\n    if (this.transaction_payload === void 0) {\n      serializer.serializeBool(false);\n    } else {\n      serializer.serializeBool(true);\n      this.transaction_payload.serialize(serializer);\n    }\n  }\n  static deserialize(deserializer) {\n    const multisig_address = AccountAddress.deserialize(deserializer);\n    const payloadPresent = deserializer.deserializeBool();\n    let transaction_payload;\n    if (payloadPresent) {\n      transaction_payload = MultisigTransactionPayload.deserialize(deserializer);\n    }\n    return new MultiSig(multisig_address, transaction_payload);\n  }\n};\nvar MultisigTransactionPayload = class {\n  constructor(transaction_payload) {\n    this.transaction_payload = transaction_payload;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(0);\n    this.transaction_payload.serialize(serializer);\n  }\n  static deserialize(deserializer) {\n    deserializer.deserializeUleb128AsU32();\n    return new MultisigTransactionPayload(EntryFunction.deserialize(deserializer));\n  }\n};\n\n// src/transactions/instances/rawTransaction.ts\nvar RawTransaction = class extends Serializable {\n  constructor(sender, sequence_number, payload, max_gas_amount, gas_unit_price, expiration_timestamp_secs, chain_id) {\n    super();\n    this.sender = sender;\n    this.sequence_number = sequence_number;\n    this.payload = payload;\n    this.max_gas_amount = max_gas_amount;\n    this.gas_unit_price = gas_unit_price;\n    this.expiration_timestamp_secs = expiration_timestamp_secs;\n    this.chain_id = chain_id;\n  }\n  serialize(serializer) {\n    this.sender.serialize(serializer);\n    serializer.serializeU64(this.sequence_number);\n    this.payload.serialize(serializer);\n    serializer.serializeU64(this.max_gas_amount);\n    serializer.serializeU64(this.gas_unit_price);\n    serializer.serializeU64(this.expiration_timestamp_secs);\n    this.chain_id.serialize(serializer);\n  }\n  static deserialize(deserializer) {\n    const sender = AccountAddress.deserialize(deserializer);\n    const sequence_number = deserializer.deserializeU64();\n    const payload = TransactionPayload.deserialize(deserializer);\n    const max_gas_amount = deserializer.deserializeU64();\n    const gas_unit_price = deserializer.deserializeU64();\n    const expiration_timestamp_secs = deserializer.deserializeU64();\n    const chain_id = ChainId.deserialize(deserializer);\n    return new RawTransaction(sender, sequence_number, payload, max_gas_amount, gas_unit_price, expiration_timestamp_secs, chain_id);\n  }\n};\nvar RawTransactionWithData = class extends Serializable {\n  static deserialize(deserializer) {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case 0 /* MultiAgentTransaction */:\n        return MultiAgentRawTransaction.load(deserializer);\n      case 1 /* FeePayerTransaction */:\n        return FeePayerRawTransaction.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for RawTransactionWithData: ${index}`);\n    }\n  }\n};\nvar MultiAgentRawTransaction = class extends RawTransactionWithData {\n  constructor(raw_txn, secondary_signer_addresses) {\n    super();\n    this.raw_txn = raw_txn;\n    this.secondary_signer_addresses = secondary_signer_addresses;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(0 /* MultiAgentTransaction */);\n    this.raw_txn.serialize(serializer);\n    serializer.serializeVector(this.secondary_signer_addresses);\n  }\n  static load(deserializer) {\n    const rawTxn = RawTransaction.deserialize(deserializer);\n    const secondarySignerAddresses = deserializer.deserializeVector(AccountAddress);\n    return new MultiAgentRawTransaction(rawTxn, secondarySignerAddresses);\n  }\n};\nvar FeePayerRawTransaction = class extends RawTransactionWithData {\n  constructor(raw_txn, secondary_signer_addresses, fee_payer_address) {\n    super();\n    this.raw_txn = raw_txn;\n    this.secondary_signer_addresses = secondary_signer_addresses;\n    this.fee_payer_address = fee_payer_address;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(1 /* FeePayerTransaction */);\n    this.raw_txn.serialize(serializer);\n    serializer.serializeVector(this.secondary_signer_addresses);\n    this.fee_payer_address.serialize(serializer);\n  }\n  static load(deserializer) {\n    const rawTxn = RawTransaction.deserialize(deserializer);\n    const secondarySignerAddresses = deserializer.deserializeVector(AccountAddress);\n    const feePayerAddress = AccountAddress.deserialize(deserializer);\n    return new FeePayerRawTransaction(rawTxn, secondarySignerAddresses, feePayerAddress);\n  }\n};\n\n// src/transactions/instances/signedTransaction.ts\nvar SignedTransaction = class extends Serializable {\n  constructor(raw_txn, authenticator) {\n    super();\n    this.raw_txn = raw_txn;\n    this.authenticator = authenticator;\n  }\n  serialize(serializer) {\n    this.raw_txn.serialize(serializer);\n    this.authenticator.serialize(serializer);\n  }\n  static deserialize(deserializer) {\n    const raw_txn = RawTransaction.deserialize(deserializer);\n    const authenticator = TransactionAuthenticator.deserialize(deserializer);\n    return new SignedTransaction(raw_txn, authenticator);\n  }\n};\n\n// src/transactions/typeTag/parser.ts\nfunction isValidIdentifier(str) {\n  return !!str.match(/^[_a-zA-Z0-9]+$/);\n}\nfunction isValidWhitespaceCharacter(char) {\n  return !!char.match(/\\s/);\n}\nfunction consumeWhitespace(tagStr, pos) {\n  let i = pos;\n  for (; i < tagStr.length; i += 1) {\n    const innerChar = tagStr[i];\n    if (!isValidWhitespaceCharacter(innerChar)) {\n      break;\n    }\n  }\n  return i;\n}\nvar TypeTagParserErrorType = /* @__PURE__ */(TypeTagParserErrorType2 => {\n  TypeTagParserErrorType2[\"InvalidTypeTag\"] = \"unknown type\";\n  TypeTagParserErrorType2[\"UnexpectedTypeArgumentClose\"] = \"unexpected '>'\";\n  TypeTagParserErrorType2[\"UnexpectedWhitespaceCharacter\"] = \"unexpected whitespace character\";\n  TypeTagParserErrorType2[\"UnexpectedComma\"] = \"unexpected ','\";\n  TypeTagParserErrorType2[\"TypeArgumentCountMismatch\"] = \"type argument count doesn't match expected amount\";\n  TypeTagParserErrorType2[\"MissingTypeArgumentClose\"] = \"no matching '>' for '<'\";\n  TypeTagParserErrorType2[\"UnexpectedPrimitiveTypeArguments\"] = \"primitive types not expected to have type arguments\";\n  TypeTagParserErrorType2[\"UnexpectedVectorTypeArgumentCount\"] = \"vector type expected to have exactly one type argument\";\n  TypeTagParserErrorType2[\"UnexpectedStructFormat\"] = \"unexpected struct format, must be of the form 0xaddress::module_name::struct_name\";\n  TypeTagParserErrorType2[\"InvalidModuleNameCharacter\"] = \"module name must only contain alphanumeric or '_' characters\";\n  TypeTagParserErrorType2[\"InvalidStructNameCharacter\"] = \"struct name must only contain alphanumeric or '_' characters\";\n  return TypeTagParserErrorType2;\n})(TypeTagParserErrorType || {});\nvar TypeTagParserError = class extends Error {\n  constructor(typeTagStr, invalidReason) {\n    super(`Failed to parse typeTag '${typeTagStr}', ${invalidReason}`);\n  }\n};\nfunction parseTypeTag(typeStr, options) {\n  var _a;\n  const allowGenerics = (_a = options == null ? void 0 : options.allowGenerics) != null ? _a : false;\n  const saved = [];\n  let innerTypes = [];\n  let curTypes = [];\n  let cur = 0;\n  let currentStr = \"\";\n  let expectedTypes = 1;\n  while (cur < typeStr.length) {\n    const char = typeStr[cur];\n    if (char === \"<\") {\n      saved.push({\n        savedExpectedTypes: expectedTypes,\n        savedStr: currentStr,\n        savedTypes: curTypes\n      });\n      currentStr = \"\";\n      curTypes = [];\n      expectedTypes = 1;\n    } else if (char === \">\") {\n      if (currentStr !== \"\") {\n        const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);\n        curTypes.push(newType);\n      }\n      const savedPop = saved.pop();\n      if (savedPop === void 0) {\n        throw new TypeTagParserError(typeStr, \"unexpected '>'\" /* UnexpectedTypeArgumentClose */);\n      }\n      if (expectedTypes !== curTypes.length) {\n        throw new TypeTagParserError(typeStr, \"type argument count doesn't match expected amount\" /* TypeArgumentCountMismatch */);\n      }\n      const {\n        savedStr,\n        savedTypes,\n        savedExpectedTypes\n      } = savedPop;\n      innerTypes = curTypes;\n      curTypes = savedTypes;\n      currentStr = savedStr;\n      expectedTypes = savedExpectedTypes;\n    } else if (char === \",\") {\n      if (currentStr.length !== 0) {\n        const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);\n        innerTypes = [];\n        curTypes.push(newType);\n        currentStr = \"\";\n        expectedTypes += 1;\n      }\n    } else if (isValidWhitespaceCharacter(char)) {\n      let parsedTypeTag = false;\n      if (currentStr.length !== 0) {\n        const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);\n        innerTypes = [];\n        curTypes.push(newType);\n        currentStr = \"\";\n        parsedTypeTag = true;\n      }\n      cur = consumeWhitespace(typeStr, cur);\n      const nextChar = typeStr[cur];\n      if (cur < typeStr.length && parsedTypeTag && nextChar !== \",\" && nextChar !== \">\") {\n        throw new TypeTagParserError(typeStr, \"unexpected whitespace character\" /* UnexpectedWhitespaceCharacter */);\n      }\n      continue;\n    } else {\n      currentStr += char;\n    }\n    cur += 1;\n  }\n  if (saved.length > 0) {\n    throw new TypeTagParserError(typeStr, \"no matching '>' for '<'\" /* MissingTypeArgumentClose */);\n  }\n  switch (curTypes.length) {\n    case 0:\n      return parseTypeTagInner(currentStr, innerTypes, allowGenerics);\n    case 1:\n      if (currentStr === \"\") {\n        return curTypes[0];\n      }\n      throw new TypeTagParserError(typeStr, \"unexpected ','\" /* UnexpectedComma */);\n    default:\n      throw new TypeTagParserError(typeStr, \"unexpected whitespace character\" /* UnexpectedWhitespaceCharacter */);\n  }\n}\nfunction parseTypeTagInner(str, types, allowGenerics) {\n  switch (str) {\n    case \"&signer\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, \"primitive types not expected to have type arguments\" /* UnexpectedPrimitiveTypeArguments */);\n      }\n      return new TypeTagReference(new TypeTagSigner());\n    case \"signer\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, \"primitive types not expected to have type arguments\" /* UnexpectedPrimitiveTypeArguments */);\n      }\n      return new TypeTagSigner();\n    case \"bool\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, \"primitive types not expected to have type arguments\" /* UnexpectedPrimitiveTypeArguments */);\n      }\n      return new TypeTagBool();\n    case \"address\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, \"primitive types not expected to have type arguments\" /* UnexpectedPrimitiveTypeArguments */);\n      }\n      return new TypeTagAddress();\n    case \"u8\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, \"primitive types not expected to have type arguments\" /* UnexpectedPrimitiveTypeArguments */);\n      }\n      return new TypeTagU8();\n    case \"u16\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, \"primitive types not expected to have type arguments\" /* UnexpectedPrimitiveTypeArguments */);\n      }\n      return new TypeTagU16();\n    case \"u32\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, \"primitive types not expected to have type arguments\" /* UnexpectedPrimitiveTypeArguments */);\n      }\n      return new TypeTagU32();\n    case \"u64\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, \"primitive types not expected to have type arguments\" /* UnexpectedPrimitiveTypeArguments */);\n      }\n      return new TypeTagU64();\n    case \"u128\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, \"primitive types not expected to have type arguments\" /* UnexpectedPrimitiveTypeArguments */);\n      }\n      return new TypeTagU128();\n    case \"u256\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, \"primitive types not expected to have type arguments\" /* UnexpectedPrimitiveTypeArguments */);\n      }\n      return new TypeTagU256();\n    case \"vector\":\n      if (types.length !== 1) {\n        throw new TypeTagParserError(str, \"vector type expected to have exactly one type argument\" /* UnexpectedVectorTypeArgumentCount */);\n      }\n      return new TypeTagVector(types[0]);\n    default:\n      if (allowGenerics && str.match(/^T[0-9]+$/)) {\n        return new TypeTagGeneric(Number(str.split(\"T\")[1]));\n      }\n      if (!str.match(/.*:.*/)) {\n        throw new TypeTagParserError(str, \"unknown type\" /* InvalidTypeTag */);\n      }\n      const structParts = str.split(\"::\");\n      if (structParts.length !== 3) {\n        throw new TypeTagParserError(str, \"unexpected struct format, must be of the form 0xaddress::module_name::struct_name\" /* UnexpectedStructFormat */);\n      }\n      if (!isValidIdentifier(structParts[1])) {\n        throw new TypeTagParserError(str, \"module name must only contain alphanumeric or '_' characters\" /* InvalidModuleNameCharacter */);\n      }\n      if (!isValidIdentifier(structParts[2])) {\n        throw new TypeTagParserError(str, \"struct name must only contain alphanumeric or '_' characters\" /* InvalidStructNameCharacter */);\n      }\n      return new TypeTagStruct(new StructTag(AccountAddress.fromString(structParts[0]), new Identifier(structParts[1]), new Identifier(structParts[2]), types));\n  }\n}\n\n// src/transactions/transactionBuilder/helpers.ts\nfunction isBool(arg) {\n  return typeof arg === \"boolean\";\n}\nfunction isString(arg) {\n  return typeof arg === \"string\";\n}\nfunction isNumber(arg) {\n  return typeof arg === \"number\";\n}\nfunction isLargeNumber(arg) {\n  return typeof arg === \"number\" || typeof arg === \"bigint\" || typeof arg === \"string\";\n}\nfunction isNull(arg) {\n  return arg === null || arg === void 0;\n}\nfunction isBcsBool(arg) {\n  return arg instanceof Bool;\n}\nfunction isBcsAddress(arg) {\n  return arg instanceof AccountAddress;\n}\nfunction isBcsString(arg) {\n  return arg instanceof MoveString;\n}\nfunction isBcsFixedBytes(arg) {\n  return arg instanceof FixedBytes;\n}\nfunction isBcsU8(arg) {\n  return arg instanceof U8;\n}\nfunction isBcsU16(arg) {\n  return arg instanceof U16;\n}\nfunction isBcsU32(arg) {\n  return arg instanceof U32;\n}\nfunction isBcsU64(arg) {\n  return arg instanceof U64;\n}\nfunction isBcsU128(arg) {\n  return arg instanceof U128;\n}\nfunction isBcsU256(arg) {\n  return arg instanceof U256;\n}\nfunction isScriptDataInput(arg) {\n  return \"bytecode\" in arg;\n}\nfunction throwTypeMismatch(expectedType, position) {\n  throw new Error(`Type mismatch for argument ${position}, expected '${expectedType}'`);\n}\nfunction findFirstNonSignerArg(functionAbi) {\n  return functionAbi.params.findIndex(param => param !== \"signer\" && param !== \"&signer\");\n}\nfunction getFunctionParts(functionArg) {\n  const funcNameParts = functionArg.split(\"::\");\n  if (funcNameParts.length !== 3) {\n    throw new Error(`Invalid function ${functionArg}`);\n  }\n  const moduleAddress = funcNameParts[0];\n  const moduleName = funcNameParts[1];\n  const functionName = funcNameParts[2];\n  return {\n    moduleAddress,\n    moduleName,\n    functionName\n  };\n}\n\n// src/transactions/transactionBuilder/remoteAbi.ts\nfunction standardizeTypeTags(typeArguments) {\n  var _a;\n  return (_a = typeArguments == null ? void 0 : typeArguments.map(typeArg => {\n    if (isString(typeArg)) {\n      return parseTypeTag(typeArg);\n    }\n    return typeArg;\n  })) != null ? _a : [];\n}\nasync function fetchEntryFunctionAbi(moduleAddress, moduleName, functionName, aptosConfig) {\n  var _a;\n  const module = await getModule({\n    aptosConfig,\n    accountAddress: moduleAddress,\n    moduleName\n  });\n  const functionAbi = (_a = module.abi) == null ? void 0 : _a.exposed_functions.find(func => func.name === functionName);\n  if (!functionAbi) {\n    throw new Error(`Could not find entry function ABI for '${moduleAddress}::${moduleName}::${functionName}'`);\n  }\n  if (!functionAbi.is_entry) {\n    throw new Error(`'${moduleAddress}::${moduleName}::${functionName}' is not an entry function`);\n  }\n  const first = findFirstNonSignerArg(functionAbi);\n  const params = [];\n  for (let i = first; i < functionAbi.params.length; i += 1) {\n    params.push(parseTypeTag(functionAbi.params[i], {\n      allowGenerics: true\n    }));\n  }\n  return {\n    typeParameters: functionAbi.generic_type_params,\n    parameters: params\n  };\n}\nfunction convertArgument(functionName, functionAbi, arg, position, genericTypeParams) {\n  if (position >= functionAbi.parameters.length) {\n    throw new Error(`Too many arguments for '${functionName}', expected ${functionAbi.parameters.length}`);\n  }\n  if (isBcsBool(arg) || isBcsU8(arg) || isBcsU16(arg) || isBcsU32(arg) || isBcsU64(arg) || isBcsU128(arg) || isBcsU256(arg) || isBcsAddress(arg) || isBcsString(arg) || isBcsFixedBytes(arg) || arg instanceof MoveVector || arg instanceof MoveOption) {\n    checkType(functionAbi, arg, position);\n    return arg;\n  }\n  return parseArg(arg, functionAbi.parameters[position], position, genericTypeParams);\n}\nfunction parseArg(arg, param, position, genericTypeParams) {\n  if (param.isBool()) {\n    if (isBool(arg)) {\n      return new Bool(arg);\n    }\n    throwTypeMismatch(\"boolean\", position);\n  }\n  if (param.isAddress()) {\n    if (isString(arg)) {\n      return AccountAddress.fromString(arg);\n    }\n    throwTypeMismatch(\"string\", position);\n  }\n  if (param.isU8()) {\n    if (isNumber(arg)) {\n      return new U8(arg);\n    }\n    throwTypeMismatch(\"number\", position);\n  }\n  if (param.isU16()) {\n    if (isNumber(arg)) {\n      return new U16(arg);\n    }\n    throwTypeMismatch(\"number\", position);\n  }\n  if (param.isU32()) {\n    if (isNumber(arg)) {\n      return new U32(arg);\n    }\n    throwTypeMismatch(\"number\", position);\n  }\n  if (param.isU64()) {\n    if (isLargeNumber(arg)) {\n      return new U64(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n  if (param.isU128()) {\n    if (isLargeNumber(arg)) {\n      return new U128(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n  if (param.isU256()) {\n    if (isLargeNumber(arg)) {\n      return new U256(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n  if (param.isGeneric()) {\n    const genericIndex = param.value;\n    if (genericIndex < 0 || genericIndex >= genericTypeParams.length) {\n      throw new Error(`Generic argument ${param.toString()} is invalid for argument ${position}`);\n    }\n    parseArg(arg, genericTypeParams[genericIndex], position, genericTypeParams);\n  }\n  if (param.isVector()) {\n    if (param.value.isU8() && isString(arg)) {\n      return MoveVector.U8(Hex.fromHexInput(arg).toUint8Array());\n    }\n    if (Array.isArray(arg)) {\n      return new MoveVector(arg.map(item => parseArg(item, param.value, position, genericTypeParams)));\n    }\n    throw new Error(`Type mismatch for argument ${position}, type '${param.toString()}'`);\n  }\n  if (param.isStruct()) {\n    if (param.isString()) {\n      if (isString(arg)) {\n        return new MoveString(arg);\n      }\n      throwTypeMismatch(\"string\", position);\n    }\n    if (param.isObject()) {\n      if (isString(arg)) {\n        return AccountAddress.fromString(arg);\n      }\n      throwTypeMismatch(\"string\", position);\n    }\n    if (param.isOption()) {\n      if (isNull(arg)) {\n        return new MoveOption(null);\n      }\n      return new MoveOption(parseArg(arg, param.value.type_args[0], position, genericTypeParams));\n    }\n    throw new Error(`Unsupported struct input type for argument ${position}, type '${param.toString()}'`);\n  }\n  throw new Error(`Type mismatch for argument ${position}, type '${param.toString()}'`);\n}\nfunction checkType(functionAbi, arg, position) {\n  const param = functionAbi.parameters[position];\n  if (param.isBool()) {\n    if (isBcsBool(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"Bool\", position);\n  }\n  if (param.isAddress()) {\n    if (isBcsAddress(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"AccountAddress\", position);\n  }\n  if (param.isU8()) {\n    if (isBcsU8(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U8\", position);\n  }\n  if (param.isU16()) {\n    if (isBcsU16(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U16\", position);\n  }\n  if (param.isU32()) {\n    if (isBcsU32(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U32\", position);\n  }\n  if (param.isU64()) {\n    if (isBcsU64(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U64\", position);\n  }\n  if (param.isU128()) {\n    if (isBcsU128(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U128\", position);\n  }\n  if (param.isU256()) {\n    if (isBcsU256(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U256\", position);\n  }\n  if (param.isVector()) {\n    if (arg instanceof MoveVector) {\n      return;\n    }\n    throwTypeMismatch(\"MoveVector\", position);\n  }\n  if (param instanceof TypeTagStruct) {\n    if (param.isString()) {\n      if (isBcsString(arg)) {\n        return;\n      }\n      throwTypeMismatch(\"MoveString\", position);\n    }\n    if (param.isObject()) {\n      if (isBcsAddress(arg)) {\n        return;\n      }\n      throwTypeMismatch(\"AccountAddress\", position);\n    }\n    if (param.isOption()) {\n      if (arg instanceof MoveOption) {\n        return;\n      }\n      throwTypeMismatch(\"MoveOption\", position);\n    }\n  }\n  throw new Error(`Type mismatch for argument ${position}, expected '${param.toString()}'`);\n}\n\n// src/transactions/transactionBuilder/transactionBuilder.ts\nasync function generateTransactionPayload(args) {\n  if (isScriptDataInput(args)) {\n    return generateTransactionPayloadScript(args);\n  }\n  const {\n    moduleAddress,\n    moduleName,\n    functionName\n  } = getFunctionParts(args.function);\n  const functionAbi = await memoizeAsync(async () => fetchEntryFunctionAbi(moduleAddress, moduleName, functionName, args.aptosConfig), `entry-function-${args.aptosConfig.network}-${moduleAddress}-${moduleName}-${functionName}`, 1e3 * 60 * 5)();\n  return generateTransactionPayloadWithABI(args, functionAbi);\n}\nfunction generateTransactionPayloadWithABI(args, functionAbi) {\n  if (isScriptDataInput(args)) {\n    return generateTransactionPayloadScript(args);\n  }\n  const {\n    moduleAddress,\n    moduleName,\n    functionName\n  } = getFunctionParts(args.function);\n  const typeArguments = standardizeTypeTags(args.typeArguments);\n  if (typeArguments.length !== functionAbi.typeParameters.length) {\n    throw new Error(`Type argument count mismatch, expected ${functionAbi.typeParameters.length}, received ${typeArguments.length}`);\n  }\n  const functionArguments = args.functionArguments.map((arg, i) => convertArgument(args.function, functionAbi, arg, i, typeArguments));\n  if (functionArguments.length !== functionAbi.parameters.length) {\n    throw new Error(`Too few arguments for '${moduleAddress}::${moduleName}::${functionName}', expected ${functionAbi.parameters.length} but got ${functionArguments.length}`);\n  }\n  const entryFunctionPayload = EntryFunction.build(`${moduleAddress}::${moduleName}`, functionName, typeArguments, functionArguments);\n  if (\"multisigAddress\" in args) {\n    let multisigAddress;\n    if (typeof args.multisigAddress === \"string\") {\n      multisigAddress = AccountAddress.fromString(args.multisigAddress);\n    } else {\n      multisigAddress = args.multisigAddress;\n    }\n    return new TransactionPayloadMultisig(new MultiSig(multisigAddress, new MultisigTransactionPayload(entryFunctionPayload)));\n  }\n  return new TransactionPayloadEntryFunction(entryFunctionPayload);\n}\nfunction generateTransactionPayloadScript(args) {\n  var _a;\n  return new TransactionPayloadScript(new Script(Hex.fromHexInput(args.bytecode).toUint8Array(), (_a = args.typeArguments) != null ? _a : [], args.functionArguments));\n}\nasync function generateRawTransaction(args) {\n  const {\n    aptosConfig,\n    sender,\n    payload,\n    options\n  } = args;\n  const getSequenceNumber = (options == null ? void 0 : options.accountSequenceNumber) ? Promise.resolve({\n    sequence_number: options.accountSequenceNumber\n  }) : getInfo({\n    aptosConfig,\n    accountAddress: sender\n  });\n  const getChainId = NetworkToChainId[aptosConfig.network] ? Promise.resolve({\n    chain_id: NetworkToChainId[aptosConfig.network]\n  }) : getLedgerInfo({\n    aptosConfig\n  });\n  const getGasUnitPrice = (options == null ? void 0 : options.gasUnitPrice) ? Promise.resolve({\n    gas_estimate: options.gasUnitPrice\n  }) : getGasPriceEstimation({\n    aptosConfig\n  });\n  const [{\n    sequence_number: sequenceNumber\n  }, {\n    chain_id: chainId\n  }, {\n    gas_estimate: gasEstimate\n  }] = await Promise.all([getSequenceNumber, getChainId, getGasUnitPrice]);\n  const {\n    maxGasAmount,\n    gasUnitPrice,\n    expireTimestamp\n  } = {\n    maxGasAmount: BigInt(DEFAULT_MAX_GAS_AMOUNT),\n    gasUnitPrice: BigInt(gasEstimate),\n    expireTimestamp: BigInt(Math.floor(Date.now() / 1e3) + DEFAULT_TXN_EXP_SEC_FROM_NOW),\n    ...options\n  };\n  return new RawTransaction(AccountAddress.fromHexInput(sender), BigInt(sequenceNumber), payload, BigInt(maxGasAmount), BigInt(gasUnitPrice), BigInt(expireTimestamp), new ChainId(chainId));\n}\nasync function buildTransaction(args) {\n  const {\n    aptosConfig,\n    sender,\n    payload,\n    options,\n    secondarySignerAddresses,\n    feePayerAddress\n  } = args;\n  const rawTxn = await generateRawTransaction({\n    aptosConfig,\n    sender,\n    payload,\n    options\n  });\n  if (feePayerAddress) {\n    const signers = secondarySignerAddresses ? secondarySignerAddresses.map(signer => AccountAddress.fromHexInput(signer)) : [];\n    return {\n      rawTransaction: rawTxn.bcsToBytes(),\n      secondarySignerAddresses: signers,\n      feePayerAddress: AccountAddress.fromHexInput(feePayerAddress)\n    };\n  }\n  if (secondarySignerAddresses) {\n    const signers = secondarySignerAddresses.map(signer => AccountAddress.fromHexInput(signer));\n    return {\n      rawTransaction: rawTxn.bcsToBytes(),\n      secondarySignerAddresses: signers\n    };\n  }\n  return {\n    rawTransaction: rawTxn.bcsToBytes()\n  };\n}\nfunction generateSignedTransactionForSimulation(args) {\n  var _a, _b;\n  const {\n    signerPublicKey,\n    transaction,\n    secondarySignersPublicKeys,\n    feePayerPublicKey\n  } = args;\n  const deserializer = new Deserializer(transaction.rawTransaction);\n  const deserializedTransaction = RawTransaction.deserialize(deserializer);\n  const accountAuthenticator = getAuthenticatorForSimulation(signerPublicKey);\n  if (transaction.feePayerAddress) {\n    const transactionToSign = new FeePayerRawTransaction(deserializedTransaction, (_a = transaction.secondarySignerAddresses) != null ? _a : [], transaction.feePayerAddress);\n    let secondaryAccountAuthenticators = [];\n    if (secondarySignersPublicKeys) {\n      secondaryAccountAuthenticators = secondarySignersPublicKeys.map(publicKey => getAuthenticatorForSimulation(publicKey));\n    }\n    const feePayerAuthenticator = getAuthenticatorForSimulation(feePayerPublicKey);\n    const transactionAuthenticator2 = new TransactionAuthenticatorFeePayer(accountAuthenticator, (_b = transaction.secondarySignerAddresses) != null ? _b : [], secondaryAccountAuthenticators, {\n      address: transaction.feePayerAddress,\n      authenticator: feePayerAuthenticator\n    });\n    return new SignedTransaction(transactionToSign.raw_txn, transactionAuthenticator2).bcsToBytes();\n  }\n  if (transaction.secondarySignerAddresses) {\n    const transactionToSign = new MultiAgentRawTransaction(deserializedTransaction, transaction.secondarySignerAddresses);\n    let secondaryAccountAuthenticators = [];\n    secondaryAccountAuthenticators = secondarySignersPublicKeys.map(publicKey => getAuthenticatorForSimulation(publicKey));\n    const transactionAuthenticator2 = new TransactionAuthenticatorMultiAgent(accountAuthenticator, transaction.secondarySignerAddresses, secondaryAccountAuthenticators);\n    return new SignedTransaction(transactionToSign.raw_txn, transactionAuthenticator2).bcsToBytes();\n  }\n  let transactionAuthenticator;\n  if (accountAuthenticator instanceof AccountAuthenticatorEd25519) {\n    transactionAuthenticator = new TransactionAuthenticatorEd25519(accountAuthenticator.public_key, accountAuthenticator.signature);\n  } else if (accountAuthenticator instanceof AccountAuthenticatorSingleKey) {\n    transactionAuthenticator = new TransactionAuthenticatorSingleSender(accountAuthenticator);\n  } else {\n    throw new Error(\"Invalid public key\");\n  }\n  return new SignedTransaction(deserializedTransaction, transactionAuthenticator).bcsToBytes();\n}\nfunction getAuthenticatorForSimulation(publicKey) {\n  if (publicKey instanceof AnyPublicKey) {\n    if (publicKey.publicKey instanceof Ed25519PublicKey) {\n      return new AccountAuthenticatorSingleKey(publicKey, new AnySignature(new Ed25519Signature(new Uint8Array(64))));\n    }\n    if (publicKey.publicKey instanceof Secp256k1PublicKey) {\n      return new AccountAuthenticatorSingleKey(publicKey, new AnySignature(new Secp256k1Signature(new Uint8Array(64))));\n    }\n  }\n  return new AccountAuthenticatorEd25519(new Ed25519PublicKey(publicKey.toUint8Array()), new Ed25519Signature(new Uint8Array(64)));\n}\nfunction sign(args) {\n  const {\n    signer,\n    transaction\n  } = args;\n  const transactionToSign = deriveTransactionType(transaction);\n  const message = getSigningMessage(transactionToSign);\n  const signerSignature = signer.sign(message);\n  switch (signer.signingScheme) {\n    case 0 /* Ed25519 */:\n      return new AccountAuthenticatorEd25519(new Ed25519PublicKey(signer.publicKey.toUint8Array()), new Ed25519Signature(signerSignature.toUint8Array()));\n    case 2 /* SingleKey */:\n      return new AccountAuthenticatorSingleKey(signer.publicKey, new AnySignature(signerSignature));\n    default:\n      throw new Error(`Cannot sign transaction, signing scheme ${signer.signingScheme} not supported`);\n  }\n}\nfunction generateSignedTransaction(args) {\n  const {\n    transaction,\n    senderAuthenticator,\n    secondarySignerAuthenticators\n  } = args;\n  const transactionToSubmit = deriveTransactionType(transaction);\n  if (secondarySignerAuthenticators) {\n    return generateMultiSignersSignedTransaction(transactionToSubmit, senderAuthenticator, secondarySignerAuthenticators);\n  }\n  if (senderAuthenticator instanceof AccountAuthenticatorEd25519) {\n    const transactionAuthenticator = new TransactionAuthenticatorEd25519(senderAuthenticator.public_key, senderAuthenticator.signature);\n    return new SignedTransaction(transactionToSubmit, transactionAuthenticator).bcsToBytes();\n  }\n  if (senderAuthenticator instanceof AccountAuthenticatorSingleKey || senderAuthenticator instanceof AccountAuthenticatorMultiKey) {\n    const transactionAuthenticator = new TransactionAuthenticatorSingleSender(senderAuthenticator);\n    return new SignedTransaction(transactionToSubmit, transactionAuthenticator).bcsToBytes();\n  }\n  throw new Error(`Cannot generate a signed transaction, ${senderAuthenticator} is not a supported account authentication scheme`);\n}\nfunction deriveTransactionType(transaction) {\n  var _a;\n  const deserializer = new Deserializer(transaction.rawTransaction);\n  const deserializedTransaction = RawTransaction.deserialize(deserializer);\n  if (transaction.feePayerAddress) {\n    return new FeePayerRawTransaction(deserializedTransaction, (_a = transaction.secondarySignerAddresses) != null ? _a : [], transaction.feePayerAddress);\n  }\n  if (transaction.secondarySignerAddresses) {\n    return new MultiAgentRawTransaction(deserializedTransaction, transaction.secondarySignerAddresses);\n  }\n  return deserializedTransaction;\n}\nfunction generateMultiSignersSignedTransaction(transaction, senderAuthenticator, secondarySignerAuthenticators) {\n  if (transaction instanceof FeePayerRawTransaction) {\n    if (!secondarySignerAuthenticators.feePayerAuthenticator) {\n      throw new Error(\"Must provide a feePayerAuthenticator argument to generate a signed fee payer transaction\");\n    }\n    const {\n      feePayerAuthenticator,\n      additionalSignersAuthenticators\n    } = secondarySignerAuthenticators;\n    const txAuthenticatorFeePayer = new TransactionAuthenticatorFeePayer(senderAuthenticator, transaction.secondary_signer_addresses, additionalSignersAuthenticators != null ? additionalSignersAuthenticators : [], {\n      address: transaction.fee_payer_address,\n      authenticator: feePayerAuthenticator\n    });\n    return new SignedTransaction(transaction.raw_txn, txAuthenticatorFeePayer).bcsToBytes();\n  }\n  if (transaction instanceof MultiAgentRawTransaction) {\n    if (!secondarySignerAuthenticators.additionalSignersAuthenticators) {\n      throw new Error(\"Must provide a additionalSignersAuthenticators argument to generate a signed multi agent transaction\");\n    }\n    const {\n      additionalSignersAuthenticators\n    } = secondarySignerAuthenticators;\n    const multiAgentAuthenticator = new TransactionAuthenticatorMultiAgent(senderAuthenticator, transaction.secondary_signer_addresses, additionalSignersAuthenticators != null ? additionalSignersAuthenticators : []);\n    return new SignedTransaction(transaction.raw_txn, multiAgentAuthenticator).bcsToBytes();\n  }\n  throw new Error(`Cannot prepare multi signers transaction to submission, ${typeof transaction} transaction is not supported`);\n}\nfunction getSigningMessage(rawTxn) {\n  const hash = sha3Hash2.create();\n  if (rawTxn instanceof RawTransaction) {\n    hash.update(RAW_TRANSACTION_SALT);\n  } else if (rawTxn instanceof MultiAgentRawTransaction) {\n    hash.update(RAW_TRANSACTION_WITH_DATA_SALT);\n  } else if (rawTxn instanceof FeePayerRawTransaction) {\n    hash.update(RAW_TRANSACTION_WITH_DATA_SALT);\n  } else {\n    throw new Error(`Unknown transaction type to sign on: ${rawTxn}`);\n  }\n  const prefix = hash.digest();\n  const body = rawTxn.bcsToBytes();\n  const mergedArray = new Uint8Array(prefix.length + body.length);\n  mergedArray.set(prefix);\n  mergedArray.set(body, prefix.length);\n  return mergedArray;\n}\n\n// src/internal/transactionSubmission.ts\nasync function generateTransaction(args) {\n  const {\n    aptosConfig,\n    sender,\n    data,\n    options,\n    secondarySignerAddresses,\n    feePayerAddress\n  } = args;\n  let generateTransactionPayloadData;\n  if (\"bytecode\" in data) {\n    generateTransactionPayloadData = data;\n  } else if (\"multisigAddress\" in data) {\n    generateTransactionPayloadData = {\n      aptosConfig,\n      multisigAddress: data.multisigAddress,\n      function: data.function,\n      functionArguments: data.functionArguments,\n      typeArguments: data.typeArguments\n    };\n  } else {\n    generateTransactionPayloadData = {\n      aptosConfig,\n      function: data.function,\n      functionArguments: data.functionArguments,\n      typeArguments: data.typeArguments\n    };\n  }\n  const payload = await generateTransactionPayload(generateTransactionPayloadData);\n  return buildTransaction({\n    aptosConfig,\n    sender,\n    payload,\n    options,\n    secondarySignerAddresses,\n    feePayerAddress\n  });\n}\nfunction signTransaction(args) {\n  const accountAuthenticator = sign({\n    ...args\n  });\n  return accountAuthenticator;\n}\nasync function simulateTransaction(args) {\n  var _a, _b, _c, _d, _e, _f;\n  const {\n    aptosConfig,\n    transaction,\n    signerPublicKey,\n    secondarySignersPublicKeys,\n    feePayerPublicKey,\n    options\n  } = args;\n  const signedTransaction = generateSignedTransactionForSimulation({\n    transaction,\n    signerPublicKey,\n    secondarySignersPublicKeys,\n    feePayerPublicKey,\n    options\n  });\n  const {\n    data\n  } = await postAptosFullNode({\n    aptosConfig,\n    body: signedTransaction,\n    path: \"transactions/simulate\",\n    params: {\n      estimate_gas_unit_price: (_b = (_a = args.options) == null ? void 0 : _a.estimateGasUnitPrice) != null ? _b : false,\n      estimate_max_gas_amount: (_d = (_c = args.options) == null ? void 0 : _c.estimateMaxGasAmount) != null ? _d : false,\n      estimate_prioritized_gas_unit_price: (_f = (_e = args.options) == null ? void 0 : _e.estimatePrioritizedGasUnitPrice) != null ? _f : false\n    },\n    originMethod: \"simulateTransaction\",\n    contentType: \"application/x.aptos.signed_transaction+bcs\" /* BCS_SIGNED_TRANSACTION */\n  });\n  return data;\n}\nasync function submitTransaction(args) {\n  const {\n    aptosConfig\n  } = args;\n  const signedTransaction = generateSignedTransaction({\n    ...args\n  });\n  const {\n    data\n  } = await postAptosFullNode({\n    aptosConfig,\n    body: signedTransaction,\n    path: \"transactions\",\n    originMethod: \"submitTransaction\",\n    contentType: \"application/x.aptos.signed_transaction+bcs\" /* BCS_SIGNED_TRANSACTION */\n  });\n  return data;\n}\nasync function signAndSubmitTransaction(args) {\n  const {\n    aptosConfig,\n    signer,\n    transaction\n  } = args;\n  const authenticator = signTransaction({\n    signer,\n    transaction\n  });\n  return submitTransaction({\n    aptosConfig,\n    transaction,\n    senderAuthenticator: authenticator\n  });\n}\nasync function publicPackageTransaction(args) {\n  const {\n    aptosConfig,\n    account,\n    metadataBytes,\n    moduleBytecode,\n    options\n  } = args;\n  const totalByteCode = moduleBytecode.map(bytecode => MoveVector.U8(bytecode));\n  const transaction = await generateTransaction({\n    aptosConfig,\n    sender: account,\n    data: {\n      function: \"0x1::code::publish_package_txn\",\n      functionArguments: [MoveVector.U8(metadataBytes), new MoveVector(totalByteCode)]\n    },\n    options\n  });\n  return transaction;\n}\n\n// src/internal/coin.ts\nasync function transferCoinTransaction(args) {\n  const {\n    aptosConfig,\n    sender,\n    recipient,\n    amount,\n    coinType,\n    options\n  } = args;\n  const coinStructType = coinType != null ? coinType : APTOS_COIN;\n  const transaction = await generateTransaction({\n    aptosConfig,\n    sender: sender.accountAddress.toString(),\n    data: {\n      function: \"0x1::aptos_account::transfer_coins\",\n      typeArguments: [parseTypeTag(coinStructType)],\n      functionArguments: [AccountAddress.fromHexInput(recipient), new U64(amount)]\n    },\n    options\n  });\n  return transaction;\n}\n\n// src/api/coin.ts\nvar Coin = class {\n  constructor(config) {\n    this.config = config;\n  }\n  async transferCoinTransaction(args) {\n    return transferCoinTransaction({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n};\n\n// src/internal/digitalAsset.ts\nasync function mintTokenTransaction(args) {\n  const {\n    aptosConfig,\n    options,\n    creator\n  } = args;\n  const transaction = await generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress.toString(),\n    data: {\n      function: \"0x4::aptos_token::mint\",\n      functionArguments: [new MoveString(args.collection), new MoveString(args.description), new MoveString(args.name), new MoveString(args.uri), MoveVector.MoveString([]), MoveVector.MoveString([]), new MoveVector([])]\n    },\n    options\n  });\n  return transaction;\n}\nasync function getTokenData(args) {\n  const {\n    aptosConfig,\n    tokenAddress\n  } = args;\n  const whereCondition = {\n    token_data_id: {\n      _eq: Hex.fromHexInput(tokenAddress).toString()\n    }\n  };\n  const graphqlQuery = {\n    query: GetTokenData,\n    variables: {\n      where_condition: whereCondition\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getTokenData\"\n  });\n  return data.current_token_datas_v2[0];\n}\nasync function getCurrentTokenOwnership(args) {\n  const {\n    aptosConfig,\n    tokenAddress\n  } = args;\n  const whereCondition = {\n    token_data_id: {\n      _eq: Hex.fromHexInput(tokenAddress).toString()\n    }\n  };\n  const graphqlQuery = {\n    query: GetCurrentTokenOwnership,\n    variables: {\n      where_condition: whereCondition\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getCurrentTokenOwnership\"\n  });\n  return data.current_token_ownerships_v2[0];\n}\nasync function getOwnedTokens(args) {\n  var _a, _b;\n  const {\n    aptosConfig,\n    ownerAddress,\n    options\n  } = args;\n  const whereCondition = {\n    owner_address: {\n      _eq: Hex.fromHexInput(ownerAddress).toString()\n    }\n  };\n  const graphqlQuery = {\n    query: GetCurrentTokenOwnership,\n    variables: {\n      where_condition: whereCondition,\n      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,\n      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,\n      order_by: options == null ? void 0 : options.orderBy\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getOwnedTokens\"\n  });\n  return data.current_token_ownerships_v2;\n}\nasync function getTokenActivity(args) {\n  var _a, _b;\n  const {\n    aptosConfig,\n    tokenAddress,\n    options\n  } = args;\n  const whereCondition = {\n    token_data_id: {\n      _eq: Hex.fromHexInput(tokenAddress).toString()\n    }\n  };\n  const graphqlQuery = {\n    query: GetTokenActivity,\n    variables: {\n      where_condition: whereCondition,\n      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,\n      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,\n      order_by: options == null ? void 0 : options.orderBy\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getTokenActivity\"\n  });\n  return data.token_activities_v2;\n}\nasync function createCollectionTransaction(args) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;\n  const {\n    aptosConfig,\n    options,\n    creator\n  } = args;\n  const transaction = await generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress.toString(),\n    data: {\n      function: \"0x4::aptos_token::create_collection\",\n      functionArguments: [new MoveString(args.description), new U64((_a = args.maxSupply) != null ? _a : MAX_U64_BIG_INT), new MoveString(args.name), new MoveString(args.uri), new Bool((_b = args.mutableDescription) != null ? _b : true), new Bool((_c = args.mutableRoyalty) != null ? _c : true), new Bool((_d = args.mutableURI) != null ? _d : true), new Bool((_e = args.mutableTokenDescription) != null ? _e : true), new Bool((_f = args.mutableTokenName) != null ? _f : true), new Bool((_g = args.mutableTokenProperties) != null ? _g : true), new Bool((_h = args.mutableTokenURI) != null ? _h : true), new Bool((_i = args.tokensBurnableByCreator) != null ? _i : true), new Bool((_j = args.tokensFreezableByCreator) != null ? _j : true), new U64((_k = args.royaltyNumerator) != null ? _k : 0), new U64((_l = args.royaltyDenominator) != null ? _l : 1)]\n    },\n    options\n  });\n  return transaction;\n}\nasync function getCollectionData(args) {\n  var _a;\n  const {\n    aptosConfig,\n    creatorAddress,\n    collectionName,\n    options\n  } = args;\n  const address = Hex.fromHexInput(creatorAddress).toString();\n  const whereCondition = {\n    collection_name: {\n      _eq: collectionName\n    },\n    creator_address: {\n      _eq: address\n    }\n  };\n  if (options == null ? void 0 : options.tokenStandard) {\n    whereCondition.token_standard = {\n      _eq: (_a = options == null ? void 0 : options.tokenStandard) != null ? _a : \"v2\"\n    };\n  }\n  const graphqlQuery = {\n    query: GetCollectionData,\n    variables: {\n      where_condition: whereCondition\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getCollectionData\"\n  });\n  return data.current_collections_v2[0];\n}\nasync function getCollectionId(args) {\n  return (await getCollectionData(args)).collection_id;\n}\n\n// src/api/digitalAsset.ts\nvar DigitalAsset = class {\n  constructor(config) {\n    this.config = config;\n  }\n  async createCollectionTransaction(args) {\n    return createCollectionTransaction({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getCollectionData(args) {\n    return getCollectionData({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getCollectionId(args) {\n    return getCollectionId({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async mintTokenTransaction(args) {\n    return mintTokenTransaction({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getTokenData(args) {\n    return getTokenData({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getCurrentTokenOwnership(args) {\n    return getCurrentTokenOwnership({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getOwnedTokens(args) {\n    return getOwnedTokens({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getTokenActivity(args) {\n    return getTokenActivity({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n};\n\n// src/internal/event.ts\nasync function getAccountEventsByCreationNumber(args) {\n  const {\n    accountAddress,\n    aptosConfig,\n    creationNumber\n  } = args;\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n  const whereCondition = {\n    account_address: {\n      _eq: address\n    },\n    creation_number: {\n      _eq: creationNumber\n    }\n  };\n  return getEvents({\n    aptosConfig,\n    options: {\n      where: whereCondition\n    }\n  });\n}\nasync function getAccountEventsByEventType(args) {\n  const {\n    accountAddress,\n    aptosConfig,\n    eventType,\n    options\n  } = args;\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n  const whereCondition = {\n    account_address: {\n      _eq: address\n    },\n    type: {\n      _eq: eventType\n    }\n  };\n  const customOptions = {\n    where: whereCondition,\n    pagination: options == null ? void 0 : options.pagination,\n    orderBy: options == null ? void 0 : options.orderBy\n  };\n  return getEvents({\n    aptosConfig,\n    options: customOptions\n  });\n}\nasync function getEvents(args) {\n  var _a, _b;\n  const {\n    aptosConfig,\n    options\n  } = args;\n  const graphqlQuery = {\n    query: GetEvents,\n    variables: {\n      where_condition: options == null ? void 0 : options.where,\n      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,\n      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,\n      order_by: options == null ? void 0 : options.orderBy\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getEvents\"\n  });\n  return data.events;\n}\n\n// src/api/event.ts\nvar Event = class {\n  constructor(config) {\n    this.config = config;\n  }\n  async getAccountEventsByCreationNumber(args) {\n    return getAccountEventsByCreationNumber({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountEventsByEventType(args) {\n    return getAccountEventsByEventType({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getEvents(args) {\n    return getEvents({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n};\n\n// src/internal/faucet.ts\nasync function fundAccount(args) {\n  const {\n    aptosConfig,\n    accountAddress,\n    amount,\n    options\n  } = args;\n  const timeout = (options == null ? void 0 : options.timeoutSecs) || DEFAULT_TXN_TIMEOUT_SEC;\n  const {\n    data\n  } = await postAptosFaucet({\n    aptosConfig,\n    path: \"fund\",\n    body: {\n      address: AccountAddress.fromHexInput(accountAddress).toString(),\n      amount\n    },\n    originMethod: \"fundAccount\"\n  });\n  const txnHash = data.txn_hashes[0];\n  await waitForTransaction({\n    aptosConfig,\n    transactionHash: txnHash,\n    options: {\n      timeoutSecs: timeout,\n      checkSuccess: options == null ? void 0 : options.checkSuccess,\n      indexerVersionCheck: options == null ? void 0 : options.indexerVersionCheck\n    }\n  });\n  return txnHash;\n}\n\n// src/api/faucet.ts\nvar Faucet = class {\n  constructor(config) {\n    this.config = config;\n  }\n  async fundAccount(args) {\n    return fundAccount({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n};\n\n// src/internal/fungibleAsset.ts\nasync function getFungibleAssetMetadata(args) {\n  var _a, _b;\n  const {\n    aptosConfig,\n    options\n  } = args;\n  const graphqlQuery = {\n    query: GetFungibleAssetMetadata,\n    variables: {\n      where_condition: options == null ? void 0 : options.where,\n      limit: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.limit,\n      offset: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.offset\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getFungibleAssetMetadata\"\n  });\n  return data.fungible_asset_metadata;\n}\nasync function getFungibleAssetActivities(args) {\n  var _a, _b;\n  const {\n    aptosConfig,\n    options\n  } = args;\n  const graphqlQuery = {\n    query: GetFungibleAssetActivities,\n    variables: {\n      where_condition: options == null ? void 0 : options.where,\n      limit: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.limit,\n      offset: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.offset\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getFungibleAssetActivities\"\n  });\n  return data.fungible_asset_activities;\n}\nasync function getCurrentFungibleAssetBalances(args) {\n  var _a, _b;\n  const {\n    aptosConfig,\n    options\n  } = args;\n  const graphqlQuery = {\n    query: GetCurrentFungibleAssetBalances,\n    variables: {\n      where_condition: options == null ? void 0 : options.where,\n      limit: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.limit,\n      offset: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.offset\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getCurrentFungibleAssetBalances\"\n  });\n  return data.current_fungible_asset_balances;\n}\n\n// src/api/fungibleAsset.ts\nvar FungibleAsset = class {\n  constructor(config) {\n    this.config = config;\n  }\n  async getFungibleAssetMetadata(args) {\n    return getFungibleAssetMetadata({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getFungibleAssetMetadataByAssetType(assetType) {\n    const data = await getFungibleAssetMetadata({\n      aptosConfig: this.config,\n      options: {\n        where: {\n          asset_type: {\n            _eq: assetType\n          }\n        }\n      }\n    });\n    return data[0];\n  }\n  async getFungibleAssetActivities(args) {\n    return getFungibleAssetActivities({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getCurrentFungibleAssetBalances(args) {\n    return getCurrentFungibleAssetBalances({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n};\n\n// src/api/general.ts\nvar General = class {\n  constructor(config) {\n    this.config = config;\n  }\n  async getLedgerInfo() {\n    return getLedgerInfo({\n      aptosConfig: this.config\n    });\n  }\n  async getChainId() {\n    const result = await this.getLedgerInfo();\n    return result.chain_id;\n  }\n  async getBlockByVersion(args) {\n    return getBlockByVersion({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getBlockByHeight(args) {\n    return getBlockByHeight({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getTableItem(args) {\n    return getTableItem({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async view(args) {\n    return view({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getChainTopUserTransactions(args) {\n    return getChainTopUserTransactions({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async queryIndexer(args) {\n    return queryIndexer({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getIndexerLastSuccessVersion() {\n    return getIndexerLastSuccessVersion({\n      aptosConfig: this.config\n    });\n  }\n};\n\n// src/internal/staking.ts\nasync function getNumberOfDelegators(args) {\n  const {\n    aptosConfig,\n    poolAddress\n  } = args;\n  const address = Hex.fromHexInput(poolAddress).toString();\n  const query = {\n    query: GetNumberOfDelegators,\n    variables: {\n      where_condition: {\n        pool_address: {\n          _eq: address\n        }\n      }\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query\n  });\n  if (data.num_active_delegator_per_pool.length === 0) {\n    throw Error(\"Delegator pool not found\");\n  }\n  return data.num_active_delegator_per_pool[0].num_active_delegator;\n}\nasync function getNumberOfDelegatorsForAllPools(args) {\n  const {\n    aptosConfig,\n    options\n  } = args;\n  const query = {\n    query: GetNumberOfDelegators,\n    variables: {\n      where_condition: {},\n      order_by: options == null ? void 0 : options.orderBy\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query\n  });\n  return data.num_active_delegator_per_pool;\n}\nasync function getDelegatedStakingActivities(args) {\n  const {\n    aptosConfig,\n    delegatorAddress,\n    poolAddress\n  } = args;\n  const query = {\n    query: GetDelegatedStakingActivities,\n    variables: {\n      delegatorAddress: Hex.fromHexInput(delegatorAddress).toString(),\n      poolAddress: Hex.fromHexInput(poolAddress).toString()\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query\n  });\n  return data.delegated_staking_activities;\n}\n\n// src/api/staking.ts\nvar Staking = class {\n  constructor(config) {\n    this.config = config;\n  }\n  async getNumberOfDelegators(args) {\n    return getNumberOfDelegators({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getNumberOfDelegatorsForAllPools(args) {\n    return getNumberOfDelegatorsForAllPools({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getDelegatedStakingActivities(args) {\n    return getDelegatedStakingActivities({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n};\n\n// src/api/transaction.ts\nvar Transaction = class {\n  constructor(config) {\n    this.config = config;\n  }\n  async getTransactions(args) {\n    return getTransactions2({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getTransactionByVersion(args) {\n    return getTransactionByVersion({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getTransactionByHash(args) {\n    return getTransactionByHash({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async isPendingTransaction(args) {\n    return isTransactionPending({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async waitForTransaction(args) {\n    return waitForTransaction({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getGasPriceEstimation() {\n    return getGasPriceEstimation({\n      aptosConfig: this.config\n    });\n  }\n};\n\n// src/api/transactionSubmission.ts\nvar TransactionSubmission = class {\n  constructor(config) {\n    this.config = config;\n  }\n  async generateTransaction(args) {\n    return generateTransaction({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  signTransaction(args) {\n    return signTransaction({\n      ...args\n    });\n  }\n  async simulateTransaction(args) {\n    return simulateTransaction({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async submitTransaction(args) {\n    return submitTransaction({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async signAndSubmitTransaction(args) {\n    const {\n      signer,\n      transaction\n    } = args;\n    return signAndSubmitTransaction({\n      aptosConfig: this.config,\n      signer,\n      transaction\n    });\n  }\n  async publishPackageTransaction(args) {\n    return publicPackageTransaction({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n};\n\n// src/api/aptos.ts\nvar Aptos = class {\n  constructor(settings) {\n    this.config = new AptosConfig(settings);\n    this.account = new Account2(this.config);\n    this.coin = new Coin(this.config);\n    this.digitalAsset = new DigitalAsset(this.config);\n    this.event = new Event(this.config);\n    this.faucet = new Faucet(this.config);\n    this.fungibleAsset = new FungibleAsset(this.config);\n    this.general = new General(this.config);\n    this.staking = new Staking(this.config);\n    this.transaction = new Transaction(this.config);\n    this.transactionSubmission = new TransactionSubmission(this.config);\n  }\n};\nfunction applyMixin(targetClass, baseClass, baseClassProp) {\n  Object.getOwnPropertyNames(baseClass.prototype).forEach(propertyName => {\n    const propertyDescriptor = Object.getOwnPropertyDescriptor(baseClass.prototype, propertyName);\n    if (!propertyDescriptor) return;\n    propertyDescriptor.value = function () {\n      return this[baseClassProp][propertyName](...arguments);\n    };\n    Object.defineProperty(targetClass.prototype, propertyName, propertyDescriptor);\n  });\n}\napplyMixin(Aptos, Account2, \"account\");\napplyMixin(Aptos, Coin, \"coin\");\napplyMixin(Aptos, DigitalAsset, \"digitalAsset\");\napplyMixin(Aptos, Event, \"event\");\napplyMixin(Aptos, Faucet, \"faucet\");\napplyMixin(Aptos, FungibleAsset, \"fungibleAsset\");\napplyMixin(Aptos, General, \"general\");\napplyMixin(Aptos, Staking, \"staking\");\napplyMixin(Aptos, Transaction, \"transaction\");\napplyMixin(Aptos, TransactionSubmission, \"transactionSubmission\");\nexport { APTOS_PATH_REGEX, Account, AccountAddress, AccountAuthenticator, AccountAuthenticatorEd25519, AccountAuthenticatorMultiEd25519, AccountAuthenticatorMultiKey, AccountAuthenticatorSingleKey, AccountAuthenticatorVariant, AddressInvalidReason, AnyPublicKeyVariant, AnySignatureVariant, Aptos, AptosApiError, AptosConfig, AuthenticationKey, Bool, ChainId, DeriveScheme, Deserializer, Ed25519PrivateKey, Ed25519PublicKey, Ed25519Signature, EntryFunction, EntryFunctionBytes, FeePayerRawTransaction, FixedBytes, Hex, HexInvalidReason, Identifier, KeyType, MimeType, ModuleId, MoveAbility, MoveFunctionVisibility, MoveOption, MoveString, MoveVector, MultiAgentRawTransaction, MultiEd25519PublicKey, MultiEd25519Signature, MultiKey, MultiSig, MultisigTransactionPayload, Network, NetworkToChainId, NetworkToFaucetAPI, NetworkToIndexerAPI, NetworkToNodeAPI, ParsingError, PrivateKey, PublicKey, RawTransaction, RawTransactionWithData, RoleType, Script, ScriptTransactionArgumentVariants, Secp256k1PrivateKey, Secp256k1PublicKey, Secp256k1Signature, Serializable, Serializer, Signature, SignedTransaction, SigningScheme, SigningSchemeInput, StructTag, TransactionAuthenticator, TransactionAuthenticatorEd25519, TransactionAuthenticatorFeePayer, TransactionAuthenticatorMultiAgent, TransactionAuthenticatorMultiEd25519, TransactionAuthenticatorSingleSender, TransactionAuthenticatorVariant, TransactionPayload, TransactionPayloadEntryFunction, TransactionPayloadMultisig, TransactionPayloadScript, TransactionPayloadVariants, TransactionResponseType, TransactionVariants, TypeTag, TypeTagAddress, TypeTagBool, TypeTagGeneric, TypeTagParserError, TypeTagParserErrorType, TypeTagReference, TypeTagSigner, TypeTagStruct, TypeTagU128, TypeTagU16, TypeTagU256, TypeTagU32, TypeTagU64, TypeTagU8, TypeTagVariants, TypeTagVector, U128, U16, U256, U32, U64, U8, aptosCoinStructTag, aptosRequest, buildTransaction, convertArgument, derivePrivateKeyFromMnemonic, deriveTransactionType, deserializeFromScriptArgument, ensureBoolean, fetchEntryFunctionAbi, findFirstNonSignerArg, generateMultiSignersSignedTransaction, generateRawTransaction, generateSignedTransaction, generateSignedTransactionForSimulation, generateTransactionPayload, generateTransactionPayloadWithABI, get, getAptosFullNode, getAuthenticatorForSimulation, getFunctionParts, getSigningMessage, isBcsAddress, isBcsBool, isBcsFixedBytes, isBcsString, isBcsU128, isBcsU16, isBcsU256, isBcsU32, isBcsU64, isBcsU8, isBool, isLargeNumber, isNull, isNumber, isScriptDataInput, isString, isValidPath, objectStructTag, optionStructTag, outOfRangeErrorMessage, paginateWithCursor, parseTypeTag, post, postAptosFaucet, postAptosFullNode, postAptosIndexer, request, sign, standardizeTypeTags, stringStructTag, throwTypeMismatch, validateNumberInRange };","map":{"version":3,"names":["AptosApiError","Error","constructor","request2","response","message","name","url","status","statusText","data","request","VERSION","MimeType","MimeType2","TypeTagVariants","TypeTagVariants2","ScriptTransactionArgumentVariants","ScriptTransactionArgumentVariants2","TransactionPayloadVariants","TransactionPayloadVariants2","TransactionVariants","TransactionVariants2","TransactionAuthenticatorVariant","TransactionAuthenticatorVariant2","AccountAuthenticatorVariant","AccountAuthenticatorVariant2","AnyPublicKeyVariant","AnyPublicKeyVariant2","AnySignatureVariant","AnySignatureVariant2","TransactionResponseType","TransactionResponseType2","MoveFunctionVisibility","MoveFunctionVisibility2","MoveAbility","MoveAbility2","RoleType","RoleType2","SigningScheme","SigningScheme2","SigningSchemeInput","SigningSchemeInput2","DeriveScheme","DeriveScheme2","errors","options","client","method","body","contentType","params","overrides","headers","HEADERS","TOKEN","Authorization","provider","aptosRequest","aptosConfig","_a","path","fullUrl","result","config","isIndexerRequest","indexerResponse","errorMessage","NetworkToIndexerAPI","mainnet","testnet","devnet","local","NetworkToNodeAPI","NetworkToFaucetAPI","Network","Network2","NetworkToChainId","DEFAULT_NETWORK","DEFAULT_MAX_GAS_AMOUNT","DEFAULT_TXN_EXP_SEC_FROM_NOW","DEFAULT_TXN_TIMEOUT_SEC","APTOS_COIN","RAW_TRANSACTION_SALT","RAW_TRANSACTION_WITH_DATA_SALT","get","acceptType","originMethod","type","getRequestUrl","valueOf","clientConfig","getAptosFullNode","paginateWithCursor","out","cursor","requestParams","start","push","post","postAptosFullNode","postAptosIndexer","postAptosFaucet","bytesToHex","bytesToHex2","hexToBytes","hexToBytes2","MAX_U8_NUMBER","MAX_U16_NUMBER","MAX_U32_NUMBER","MAX_U64_BIG_INT","BigInt","MAX_U128_BIG_INT","MAX_U256_BIG_INT","ParsingError","invalidReason","HexInvalidReason","HexInvalidReason2","Hex","toUint8Array","toStringWithoutPrefix","toString","fromString","str","input","startsWith","slice","length","e","error","fromHexInput","hexInput","Uint8Array","isValid","valid","invalidReasonMessage","equals","other","every","value","index","Serializable","bcsToBytes","serializer","Serializer","serialize","bcsToHex","bcsBytes","arguments","undefined","buffer","ArrayBuffer","offset","ensureBufferWillHandleSize","bytes","byteLength","newBuffer","set","appendToBuffer","values","serializeWithFunction","fn","bytesLength","dv","DataView","apply","serializeStr","textEncoder","TextEncoder","serializeBytes","encode","serializeU32AsUleb128","serializeFixedBytes","serializeBool","ensureBoolean","byteValue","serializeU8","serializeU16","prototype","setUint16","serializeU32","setUint32","serializeU64","low","high","Number","serializeU128","serializeU256","val","valueArray","serializeVector","forEach","item","__decorateClass","checkNumberRange","outOfRangeErrorMessage","min","max","validateNumberInRange","minValue","maxValue","valueBigInt","target","propertyKey","descriptor","childFunction","deco","AddressInvalidReason","AddressInvalidReason2","_AccountAddress","args","LENGTH","isSpecial","byte","hex","toStringLong","toStringLongWithoutPrefix","serializeForEntryFunction","serializeForScriptFunction","deserialize","deserializer","deserializeFixedBytes","address","fromStringRelaxed","LONG_STRING_LENGTH","parsedInput","addressBytes","padStart","fromHexInputRelaxed","relaxed","AccountAddress","ZERO","ONE","TWO","THREE","FOUR","sha3_256","sha3Hash","nacl","Deserializer","read","deserializeStr","deserializeBytes","textDecoder","TextDecoder","decode","len","deserializeUleb128AsU32","deserializeBool","bool","deserializeU8","getUint8","deserializeU16","getUint16","deserializeU32","getUint32","deserializeU64","deserializeU128","deserializeU256","shift","cls","deserializeVector","vector","Array","i","FixedBytes","EntryFunctionBytes","fixedBytes","Bool","U8","U16","U32","U64","U128","U256","MoveVector","isU8","numbers","isArray","from","map","v","MoveString","vectorU8","MoveOption","vec","unwrap","isSome","PublicKey","PrivateKey","Signature","_Ed25519PublicKey","key","verifySignature","signature","rawMessage","rawSignature","sign","detached","verify","load","Ed25519PublicKey","_Ed25519PrivateKey","privateKeyHex","signingKeyPair","keyPair","fromSeed","secretKey","Ed25519Signature","generate","publicKey","Ed25519PrivateKey","_Ed25519Signature","_MultiEd25519PublicKey","publicKeys","threshold","MAX_KEYS","MIN_KEYS","MIN_THRESHOLD","k","keys","begin","subarray","MultiEd25519PublicKey","_MultiEd25519Signature","signatures","bitmap","BITMAP_LEN","MAX_SIGNATURES_SUPPORTED","createBitmap","bits","firstBitInByte","dupCheckSet","Set","bit","has","add","byteOffset","Math","floor","MultiEd25519Signature","secp256k1","_Secp256k1PublicKey","msgHex","sha3Message","Secp256k1PublicKey","_Secp256k1PrivateKey","Secp256k1Signature","toCompactRawBytes","utils","randomPrivateKey","getPublicKey","Secp256k1PrivateKey","_Secp256k1Signature","AnyPublicKey","MultiKey","signaturesRequired","idx","_AuthenticationKey","fromPublicKeyAndScheme","scheme","authKeyBytes","singleKeyBytes","ed25519PublicKeyBytes","inputBytes","hash","create","update","hashDigest","digest","fromPublicKey","derivedAddress","AuthenticationKey","hmac","sha512","bip39","APTOS_PATH_REGEX","KeyType","KeyType2","HARDENED_OFFSET","deriveKey","hashSeed","chainCode","CKDPriv","_ref","indexBytes","zero","removeApostrophes","replace","splitPath","split","isValidPath","test","some","isNaN","mnemonicToSeed","mnemonic","normalizedMnemonic","trim","part","toLowerCase","join","mnemonicToSeedSync","derivePrivateKeyFromMnemonic","keyType","seedPhrase","segments","el","parseInt","reduce","parentKeys","segment","Account","privateKey","legacy","signingScheme","accountAddress","authKey","fromPrivateKeyAndAddress","fromDerivationPath","CurrentTokenOwnershipFieldsFragmentDoc","TokenActivitiesFieldsFragmentDoc","GetAccountCoinsCount","GetAccountCoinsData","GetAccountCollectionsWithOwnedTokens","GetAccountOwnedObjects","GetAccountOwnedTokens","GetAccountOwnedTokensByTokenData","GetAccountOwnedTokensFromCollection","GetAccountTokensCount","GetAccountTransactionsCount","GetChainTopUserTransactions","GetCollectionData","GetCurrentFungibleAssetBalances","GetDelegatedStakingActivities","GetEvents","GetFungibleAssetActivities","GetFungibleAssetMetadata","GetNumberOfDelegators","GetProcessorStatus","GetTokenActivity","GetCurrentTokenOwnership","GetTokenData","getLedgerInfo","getBlockByVersion","ledgerVersion","with_transactions","withTransactions","getBlockByHeight","blockHeight","getTableItem","handle","ledger_version","view","_b","payload","function","type_arguments","typeArguments","functionArguments","getChainTopUserTransactions","limit","graphqlQuery","query","variables","queryIndexer","user_transactions","WITH_CREDENTIALS","getProcessorStatuses","processor_status","getIndexerLastSuccessVersion","last_success_version","cache","Map","memoizeAsync","func","ttlMs","timestamp","Date","now","getInfo","getModules","getModule","getModuleInner","moduleName","getTransactions","getResources","getResource","resourceType","lookupOriginalAccountAddress","authenticationKey","resource","address_map","originalAddress","key_type","value_type","err","error_code","getAccountTokensCount","whereCondition","owner_address","_eq","amount","_gt","where_condition","current_token_ownerships_v2_aggregate","aggregate","count","getAccountOwnedTokens","tokenStandard","token_standard","pagination","order_by","orderBy","current_token_ownerships_v2","getAccountOwnedTokensFromCollectionAddress","collectionAddress","ownerAddress","collAddress","current_token_data","collection_id","getAccountCollectionsWithOwnedTokens","current_collection","current_collection_ownership_v2_view","getAccountTransactionsCount","account_transactions_aggregate","getAccountCoinsData","current_fungible_asset_balances","getAccountCoinsCount","current_fungible_asset_balances_aggregate","getAccountOwnedObjects","current_objects","deriveAccountFromPrivateKey","SingleSenderTransactionAuthenticatorAuthKey","isSingleSenderTransactionAuthenticator","isAccountExist","legacyAuthKey","isLegacyEd25519","Account2","getAccountInfo","getAccountModules","getAccountModule","getAccountTransactions","getAccountResources","getAccountResource","aptosClient","AptosConfig","settings","_c","network","fullnode","faucet","indexer","apiType","sha3Hash2","AnySignature","sleep","timeMs","Promise","resolve","setTimeout","getTransactions2","getGasPriceEstimation","getTransactionByVersion","getTransactionByHash","transactionHash","isTransactionPending","transaction","waitForTransaction","timeoutSecs","checkSuccess","indexerVersionCheck","isPending","timeElapsed","lastTxn","lastError","backoffIntervalMs","backoffMultiplier","isAptosApiError","isRequestError","WaitForTransactionError","success","FailedTransactionError","vm_status","waitForLastSuccessIndexerVersionSync","version","_e","timeoutMilliseconds","startTime","getTime","indexerVersion","lastSubmittedTransaction","AccountAuthenticator","AccountAuthenticatorEd25519","AccountAuthenticatorMultiEd25519","AccountAuthenticatorSingleKey","AccountAuthenticatorMultiKey","public_key","public_keys","signatures_bitmap","TransactionAuthenticator","TransactionAuthenticatorEd25519","TransactionAuthenticatorMultiEd25519","TransactionAuthenticatorMultiAgent","TransactionAuthenticatorFeePayer","TransactionAuthenticatorSingleSender","sender","secondary_signer_addresses","secondary_signers","fee_payer","authenticator","ChainId","chainId","Identifier","identifier","ModuleId","fromStr","moduleId","parts","TypeTag","TypeTagBool","TypeTagU8","TypeTagU64","TypeTagU128","TypeTagAddress","TypeTagSigner","TypeTagVector","TypeTagStruct","TypeTagU16","TypeTagU32","TypeTagU256","TypeTagGeneric","isBool","isAddress","isGeneric","isSigner","isVector","isStruct","isU16","isU32","isU64","isU128","isU256","_deserializer","TypeTagReference","typePredicate","type_args","typeArg","module_name","StructTag","isTypeTag","structName","isString","isOption","isObject","typeArgs","aptosCoinStructTag","stringStructTag","optionStructTag","objectStructTag","deserializeFromScriptArgument","TransactionPayload","TransactionPayloadScript","TransactionPayloadEntryFunction","TransactionPayloadMultisig","script","Script","entryFunction","EntryFunction","multiSig","MultiSig","function_name","build","module_id","fixedBytesLength","bytecode","scriptArgument","multisig_address","transaction_payload","payloadPresent","MultisigTransactionPayload","RawTransaction","sequence_number","max_gas_amount","gas_unit_price","expiration_timestamp_secs","chain_id","RawTransactionWithData","MultiAgentRawTransaction","FeePayerRawTransaction","raw_txn","rawTxn","secondarySignerAddresses","fee_payer_address","feePayerAddress","SignedTransaction","isValidIdentifier","match","isValidWhitespaceCharacter","char","consumeWhitespace","tagStr","pos","innerChar","TypeTagParserErrorType","TypeTagParserErrorType2","TypeTagParserError","typeTagStr","parseTypeTag","typeStr","allowGenerics","saved","innerTypes","curTypes","cur","currentStr","expectedTypes","savedExpectedTypes","savedStr","savedTypes","newType","parseTypeTagInner","savedPop","pop","parsedTypeTag","nextChar","types","structParts","arg","isNumber","isLargeNumber","isNull","isBcsBool","isBcsAddress","isBcsString","isBcsFixedBytes","isBcsU8","isBcsU16","isBcsU32","isBcsU64","isBcsU128","isBcsU256","isScriptDataInput","throwTypeMismatch","expectedType","position","findFirstNonSignerArg","functionAbi","findIndex","param","getFunctionParts","functionArg","funcNameParts","moduleAddress","functionName","standardizeTypeTags","fetchEntryFunctionAbi","module","abi","exposed_functions","find","is_entry","first","typeParameters","generic_type_params","parameters","convertArgument","genericTypeParams","checkType","parseArg","genericIndex","generateTransactionPayload","generateTransactionPayloadScript","generateTransactionPayloadWithABI","entryFunctionPayload","multisigAddress","generateRawTransaction","getSequenceNumber","accountSequenceNumber","getChainId","getGasUnitPrice","gasUnitPrice","gas_estimate","sequenceNumber","gasEstimate","all","maxGasAmount","expireTimestamp","buildTransaction","signers","signer","rawTransaction","generateSignedTransactionForSimulation","signerPublicKey","secondarySignersPublicKeys","feePayerPublicKey","deserializedTransaction","accountAuthenticator","getAuthenticatorForSimulation","transactionToSign","secondaryAccountAuthenticators","feePayerAuthenticator","transactionAuthenticator2","transactionAuthenticator","deriveTransactionType","getSigningMessage","signerSignature","generateSignedTransaction","senderAuthenticator","secondarySignerAuthenticators","transactionToSubmit","generateMultiSignersSignedTransaction","additionalSignersAuthenticators","txAuthenticatorFeePayer","multiAgentAuthenticator","prefix","mergedArray","generateTransaction","generateTransactionPayloadData","signTransaction","simulateTransaction","_d","_f","signedTransaction","estimate_gas_unit_price","estimateGasUnitPrice","estimate_max_gas_amount","estimateMaxGasAmount","estimate_prioritized_gas_unit_price","estimatePrioritizedGasUnitPrice","submitTransaction","signAndSubmitTransaction","publicPackageTransaction","account","metadataBytes","moduleBytecode","totalByteCode","transferCoinTransaction","recipient","coinType","coinStructType","Coin","mintTokenTransaction","creator","collection","description","uri","getTokenData","tokenAddress","token_data_id","current_token_datas_v2","getCurrentTokenOwnership","getOwnedTokens","getTokenActivity","token_activities_v2","createCollectionTransaction","_g","_h","_i","_j","_k","_l","maxSupply","mutableDescription","mutableRoyalty","mutableURI","mutableTokenDescription","mutableTokenName","mutableTokenProperties","mutableTokenURI","tokensBurnableByCreator","tokensFreezableByCreator","royaltyNumerator","royaltyDenominator","getCollectionData","creatorAddress","collectionName","collection_name","creator_address","current_collections_v2","getCollectionId","DigitalAsset","getAccountEventsByCreationNumber","creationNumber","account_address","creation_number","getEvents","where","getAccountEventsByEventType","eventType","customOptions","events","Event","fundAccount","timeout","txnHash","txn_hashes","Faucet","getFungibleAssetMetadata","fungible_asset_metadata","getFungibleAssetActivities","fungible_asset_activities","getCurrentFungibleAssetBalances","FungibleAsset","getFungibleAssetMetadataByAssetType","assetType","asset_type","General","getNumberOfDelegators","poolAddress","pool_address","num_active_delegator_per_pool","num_active_delegator","getNumberOfDelegatorsForAllPools","getDelegatedStakingActivities","delegatorAddress","delegated_staking_activities","Staking","Transaction","isPendingTransaction","TransactionSubmission","publishPackageTransaction","Aptos","coin","digitalAsset","event","fungibleAsset","general","staking","transactionSubmission","applyMixin","targetClass","baseClass","baseClassProp","Object","getOwnPropertyNames","propertyName","propertyDescriptor","getOwnPropertyDescriptor","defineProperty"],"sources":["/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/client/types.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/version.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/types/index.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/client/core.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/utils/apiEndpoints.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/utils/const.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/client/get.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/client/post.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/core/accountAddress.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/bcs/consts.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/core/hex.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/core/common.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/bcs/serializer.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/core/authenticationKey.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/core/crypto/ed25519.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/bcs/deserializer.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/bcs/serializable/fixedBytes.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/bcs/serializable/entryFunctionBytes.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/bcs/serializable/movePrimitives.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/bcs/serializable/moveStructs.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/core/crypto/asymmetricCrypto.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/core/crypto/multiEd25519.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/core/crypto/secp256k1.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/core/crypto/anyPublicKey.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/core/crypto/multiKey.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/utils/hdKey.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/core/account.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/types/generated/queries.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/internal/general.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/utils/memoize.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/internal/account.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/api/account.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/api/aptosConfig.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/transactions/transactionBuilder/transactionBuilder.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/core/crypto/anySignature.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/utils/helpers.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/internal/transaction.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/transactions/authenticator/account.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/transactions/authenticator/transaction.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/transactions/instances/chainId.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/transactions/instances/identifier.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/transactions/instances/moduleId.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/transactions/typeTag/index.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/transactions/instances/transactionPayload.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/transactions/instances/rawTransaction.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/transactions/instances/signedTransaction.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/transactions/typeTag/parser.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/transactions/transactionBuilder/helpers.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/transactions/transactionBuilder/remoteAbi.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/internal/transactionSubmission.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/internal/coin.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/api/coin.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/internal/digitalAsset.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/api/digitalAsset.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/internal/event.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/api/event.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/internal/faucet.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/api/faucet.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/internal/fungibleAsset.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/api/fungibleAsset.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/api/general.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/internal/staking.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/api/staking.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/api/transaction.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/api/transactionSubmission.ts","/home/ck/compoundefi/client/node_modules/@aptos-labs/ts-sdk/src/api/aptos.ts"],"sourcesContent":["// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AptosRequest } from \"../types\";\n\n/**\n * The API response type\n *\n * @param status - the response status. i.e. 200\n * @param statusText - the response message\n * @param data the response data\n * @param url the url the request was made to\n * @param headers the response headers\n * @param config (optional) - the request object\n * @param request (optional) - the request object\n */\nexport interface AptosResponse<Req, Res> {\n  status: number;\n  statusText: string;\n  data: Res;\n  url: string;\n  headers: any;\n  config?: any;\n  request?: Req;\n}\n\n/**\n * The type returned from an API error\n *\n * @param name - the error name \"AptosApiError\"\n * @param url the url the request was made to\n * @param status - the response status. i.e. 400\n * @param statusText - the response message\n * @param data the response data\n * @param request - the AptosRequest\n */\nexport class AptosApiError extends Error {\n  readonly url: string;\n\n  readonly status: number;\n\n  readonly statusText: string;\n\n  readonly data: any;\n\n  readonly request: AptosRequest;\n\n  constructor(request: AptosRequest, response: AptosResponse<any, any>, message: string) {\n    super(message);\n\n    this.name = \"AptosApiError\";\n    this.url = response.url;\n    this.status = response.status;\n    this.statusText = response.statusText;\n    this.data = response.data;\n    this.request = request;\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * The current version of the SDK\n *\n * hardcoded for now, we would want to have it injected dynamically\n */\nexport const VERSION = \"2.0.0\";\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Network } from \"../utils/apiEndpoints\";\n\nexport * from \"./indexer\";\n\nexport enum MimeType {\n  /**\n   * JSON representation, used for transaction submission and accept type JSON output\n   */\n  JSON = \"application/json\",\n  /**\n   * BCS representation, used for accept type BCS output\n   */\n  BCS = \"application/x-bcs\",\n  /**\n   * BCS representation, used for transaction submission in BCS input\n   */\n  BCS_SIGNED_TRANSACTION = \"application/x.aptos.signed_transaction+bcs\",\n}\n\n/**\n * Hex data as input to a function\n */\nexport type HexInput = string | Uint8Array;\n\n/**\n * TypeTag enum as they are represented in Rust\n * {@link https://github.com/aptos-labs/aptos-core/blob/main/third_party/move/move-core/types/src/language_storage.rs#L27}\n */\nexport enum TypeTagVariants {\n  Bool = 0,\n  U8 = 1,\n  U64 = 2,\n  U128 = 3,\n  Address = 4,\n  Signer = 5,\n  Vector = 6,\n  Struct = 7,\n  U16 = 8,\n  U32 = 9,\n  U256 = 10,\n  Reference = 254, // This is specifically a placeholder and does not represent a real type\n  Generic = 255, // This is specifically a placeholder and does not represent a real type\n}\n\n/**\n * Script transaction arguments enum as they are represented in Rust\n * {@link https://github.com/aptos-labs/aptos-core/blob/main/third_party/move/move-core/types/src/transaction_argument.rs#L11}\n */\nexport enum ScriptTransactionArgumentVariants {\n  U8 = 0,\n  U64 = 1,\n  U128 = 2,\n  Address = 3,\n  U8Vector = 4,\n  Bool = 5,\n  U16 = 6,\n  U32 = 7,\n  U256 = 8,\n}\n\n/**\n * Transaction payload enum as they are represented in Rust\n * {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/mod.rs#L478}\n */\nexport enum TransactionPayloadVariants {\n  Script = 0,\n  EntryFunction = 2,\n  Multisig = 3,\n}\n\n/**\n * Transaction variants enum as they are represented in Rust\n * {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/mod.rs#L440}\n */\nexport enum TransactionVariants {\n  MultiAgentTransaction = 0,\n  FeePayerTransaction = 1,\n}\n\n/**\n * Transaction Authenticator enum as they are represented in Rust\n * {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/authenticator.rs#L44}\n */\nexport enum TransactionAuthenticatorVariant {\n  Ed25519 = 0,\n  MultiEd25519 = 1,\n  MultiAgent = 2,\n  FeePayer = 3,\n  SingleSender = 4,\n}\n\n/**\n * Transaction Authenticator enum as they are represented in Rust\n * {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/authenticator.rs#L414}\n */\nexport enum AccountAuthenticatorVariant {\n  Ed25519 = 0,\n  MultiEd25519 = 1,\n  SingleKey = 2,\n  MultiKey = 3,\n}\n\nexport enum AnyPublicKeyVariant {\n  Ed25519 = 0,\n  Secp256k1 = 1,\n}\n\nexport enum AnySignatureVariant {\n  Ed25519 = 0,\n  Secp256k1 = 1,\n}\n\n/**\n * BCS types\n */\nexport type Uint8 = number;\nexport type Uint16 = number;\nexport type Uint32 = number;\nexport type Uint64 = bigint;\nexport type Uint128 = bigint;\nexport type Uint256 = bigint;\nexport type AnyNumber = number | bigint;\n\n/**\n * Set of configuration options that can be provided when initializing the SDK.\n * The purpose of these options is to configure various aspects of the SDK's\n * behavior and interaction with the Aptos network\n */\nexport type AptosSettings = {\n  readonly network?: Network;\n\n  readonly fullnode?: string;\n\n  readonly faucet?: string;\n\n  readonly indexer?: string;\n\n  readonly clientConfig?: ClientConfig;\n\n  readonly client?: Client;\n};\n\n/**\n *\n * Controls the number of results that are returned and the starting position of those results.\n * @param offset parameter specifies the starting position of the query result within the set of data. Default is 0.\n * @param limit specifies the maximum number of items or records to return in a query result. Default is 25.\n */\nexport interface PaginationArgs {\n  offset?: AnyNumber;\n  limit?: number;\n}\n\n/**\n * QUERY TYPES\n */\n\n/**\n * A configuration object we can pass with the request to the server.\n *\n * @param TOKEN - an auth token to send with the request\n * @param HEADERS - extra headers we want to send with the request\n * @param WITH_CREDENTIALS - whether to carry cookies. By default, it is set to true and cookies will be sent\n */\nexport type ClientConfig = {\n  TOKEN?: string;\n  HEADERS?: Record<string, string | number | boolean>;\n  WITH_CREDENTIALS?: boolean;\n};\n\nexport interface ClientRequest<Req> {\n  url: string;\n  method: \"GET\" | \"POST\";\n  body?: Req;\n  contentType?: string;\n  params?: any;\n  overrides?: ClientConfig;\n  headers?: Record<string, any>;\n}\n\nexport interface ClientResponse<Res> {\n  status: number;\n  statusText: string;\n  data: Res;\n  config?: any;\n  request?: any;\n  response?: any;\n  headers?: any;\n}\n\nexport interface Client {\n  provider<Req, Res>(requestOptions: ClientRequest<Req>): Promise<ClientResponse<Res>>;\n}\n\n/**\n * The API request type\n *\n * @param url - the url to make the request to, i.e https://fullnode.aptoslabs.devnet.com/v1\n * @param method - the request method \"GET\" | \"POST\"\n * @param endpoint (optional) - the endpoint to make the request to, i.e transactions\n * @param body (optional) - the body of the request\n * @param contentType (optional) - the content type to set the `content-type` header to,\n * by default is set to `application/json`\n * @param params (optional) - query params to add to the request\n * @param originMethod (optional) - the local method the request came from\n * @param overrides (optional) - a `ClientConfig` object type to override request data\n */\nexport type AptosRequest = {\n  url: string;\n  method: \"GET\" | \"POST\";\n  path?: string;\n  body?: any;\n  contentType?: string;\n  acceptType?: string;\n  params?: Record<string, string | AnyNumber | boolean | undefined>;\n  originMethod?: string;\n  overrides?: ClientConfig;\n};\n\n/**\n * Specifies ledger version of transactions. By default latest version will be used\n */\nexport type LedgerVersion = {\n  ledgerVersion?: AnyNumber;\n};\n\n/**\n * RESPONSE TYPES\n */\n\n/**\n * Type holding the outputs of the estimate gas API\n */\nexport type GasEstimation = {\n  /**\n   * The deprioritized estimate for the gas unit price\n   */\n  deprioritized_gas_estimate?: number;\n  /**\n   * The current estimate for the gas unit price\n   */\n  gas_estimate: number;\n  /**\n   * The prioritized estimate for the gas unit price\n   */\n  prioritized_gas_estimate?: number;\n};\n\nexport type MoveResource = {\n  type: MoveStructType;\n  data: {};\n};\n\nexport type AccountData = {\n  sequence_number: string;\n  authentication_key: string;\n};\n\nexport type MoveModuleBytecode = {\n  bytecode: string;\n  abi?: MoveModule;\n};\n\n/**\n * TRANSACTION TYPES\n */\n\nexport enum TransactionResponseType {\n  Pending = \"pending_transaction\",\n  User = \"user_transaction\",\n  Genesis = \"genesis_transaction\",\n  BlockMetadata = \"block_metadata_transaction\",\n  StateCheckpoint = \"state_checkpoint_transaction\",\n}\n\nexport type TransactionResponse =\n  | PendingTransactionResponse\n  | UserTransactionResponse\n  | GenesisTransactionResponse\n  | BlockMetadataTransactionResponse\n  | StateCheckpointTransactionResponse;\n\nexport type PendingTransactionResponse = {\n  type: TransactionResponseType.Pending;\n  hash: string;\n  sender: string;\n  sequence_number: string;\n  max_gas_amount: string;\n  gas_unit_price: string;\n  expiration_timestamp_secs: string;\n  payload: TransactionPayloadResponse;\n  signature?: TransactionSignature;\n};\n\nexport type UserTransactionResponse = {\n  type: TransactionResponseType.User;\n  version: string;\n  hash: string;\n  state_change_hash: string;\n  event_root_hash: string;\n  state_checkpoint_hash?: string;\n  gas_used: string;\n  /**\n   * Whether the transaction was successful\n   */\n  success: boolean;\n  /**\n   * The VM status of the transaction, can tell useful information in a failure\n   */\n  vm_status: string;\n  accumulator_root_hash: string;\n  /**\n   * Final state of resources changed by the transaction\n   */\n  changes: Array<WriteSetChange>;\n  sender: string;\n  sequence_number: string;\n  max_gas_amount: string;\n  gas_unit_price: string;\n  expiration_timestamp_secs: string;\n  payload: TransactionPayloadResponse;\n  signature?: TransactionSignature;\n  /**\n   * Events generated by the transaction\n   */\n  events: Array<Event>;\n  timestamp: string;\n};\n\nexport type GenesisTransactionResponse = {\n  type: TransactionResponseType.Genesis;\n  version: string;\n  hash: string;\n  state_change_hash: string;\n  event_root_hash: string;\n  state_checkpoint_hash?: string;\n  gas_used: string;\n  /**\n   * Whether the transaction was successful\n   */\n  success: boolean;\n  /**\n   * The VM status of the transaction, can tell useful information in a failure\n   */\n  vm_status: string;\n  accumulator_root_hash: string;\n  /**\n   * Final state of resources changed by the transaction\n   */\n  changes: Array<WriteSetChange>;\n  payload: GenesisPayload;\n  /**\n   * Events emitted during genesis\n   */\n  events: Array<Event>;\n};\n\nexport type BlockMetadataTransactionResponse = {\n  type: TransactionResponseType.BlockMetadata;\n  version: string;\n  hash: string;\n  state_change_hash: string;\n  event_root_hash: string;\n  state_checkpoint_hash?: string;\n  gas_used: string;\n  /**\n   * Whether the transaction was successful\n   */\n  success: boolean;\n  /**\n   * The VM status of the transaction, can tell useful information in a failure\n   */\n  vm_status: string;\n  accumulator_root_hash: string;\n  /**\n   * Final state of resources changed by the transaction\n   */\n  changes: Array<WriteSetChange>;\n  id: string;\n  epoch: string;\n  round: string;\n  /**\n   * The events emitted at the block creation\n   */\n  events: Array<Event>;\n  /**\n   * Previous block votes\n   */\n  previous_block_votes_bitvec: Array<number>;\n  proposer: string;\n  /**\n   * The indices of the proposers who failed to propose\n   */\n  failed_proposer_indices: Array<number>;\n  timestamp: string;\n};\n\nexport type StateCheckpointTransactionResponse = {\n  type: TransactionResponseType.StateCheckpoint;\n  version: string;\n  hash: string;\n  state_change_hash: string;\n  event_root_hash: string;\n  state_checkpoint_hash?: string;\n  gas_used: string;\n  /**\n   * Whether the transaction was successful\n   */\n  success: boolean;\n  /**\n   * The VM status of the transaction, can tell useful information in a failure\n   */\n  vm_status: string;\n  accumulator_root_hash: string;\n  /**\n   * Final state of resources changed by the transaction\n   */\n  changes: Array<WriteSetChange>;\n  timestamp: string;\n};\n\n/**\n * WRITESET CHANGE TYPES\n */\n\nexport type WriteSetChange =\n  | WriteSetChangeDeleteModule\n  | WriteSetChangeDeleteResource\n  | WriteSetChangeDeleteTableItem\n  | WriteSetChangeWriteModule\n  | WriteSetChangeWriteResource\n  | WriteSetChangeWriteTableItem;\n\nexport type WriteSetChangeDeleteModule = {\n  type: string;\n  address: string;\n  /**\n   * State key hash\n   */\n  state_key_hash: string;\n  module: MoveModuleId;\n};\n\nexport type WriteSetChangeDeleteResource = {\n  type: string;\n  address: string;\n  state_key_hash: string;\n  resource: string;\n};\n\nexport type WriteSetChangeDeleteTableItem = {\n  type: string;\n  state_key_hash: string;\n  handle: string;\n  key: string;\n  data?: DeletedTableData;\n};\n\nexport type WriteSetChangeWriteModule = {\n  type: string;\n  address: string;\n  state_key_hash: string;\n  data: MoveModuleBytecode;\n};\n\nexport type WriteSetChangeWriteResource = {\n  type: string;\n  address: string;\n  state_key_hash: string;\n  data: MoveResource;\n};\n\nexport type WriteSetChangeWriteTableItem = {\n  type: string;\n  state_key_hash: string;\n  handle: string;\n  key: string;\n  value: string;\n  data?: DecodedTableData;\n};\n\nexport type DecodedTableData = {\n  /**\n   * Key of table in JSON\n   */\n  key: any;\n  /**\n   * Type of key\n   */\n  key_type: string;\n  /**\n   * Value of table in JSON\n   */\n  value: any;\n  /**\n   * Type of value\n   */\n  value_type: string;\n};\n\n/**\n * Deleted table data\n */\nexport type DeletedTableData = {\n  /**\n   * Deleted key\n   */\n  key: any;\n  /**\n   * Deleted key type\n   */\n  key_type: string;\n};\n\nexport type TransactionPayloadResponse = EntryFunctionPayloadResponse | ScriptPayloadResponse | MultisigPayloadResponse;\n\nexport type EntryFunctionPayloadResponse = {\n  type: string;\n  function: MoveStructType;\n  /**\n   * Type arguments of the function\n   */\n  type_arguments: Array<string>;\n  /**\n   * Arguments of the function\n   */\n  arguments: Array<any>;\n};\n\nexport type ScriptPayloadResponse = {\n  type: string;\n  code: MoveScriptBytecode;\n  /**\n   * Type arguments of the function\n   */\n  type_arguments: Array<string>;\n  /**\n   * Arguments of the function\n   */\n  arguments: Array<any>;\n};\n\nexport type MultisigPayloadResponse = {\n  type: string;\n  multisig_address: string;\n  transaction_payload?: EntryFunctionPayloadResponse;\n};\n\nexport type GenesisPayload = {\n  type: string;\n  write_set: WriteSet;\n};\n\n/**\n * Move script bytecode\n */\nexport type MoveScriptBytecode = {\n  bytecode: string;\n  abi?: MoveFunction;\n};\n\n/**\n * These are the JSON representations of transaction signatures returned from the node API.\n */\nexport type TransactionSignature =\n  | TransactionEd25519Signature\n  | TransactionSecp256k1Signature\n  | TransactionMultiEd25519Signature\n  | TransactionMultiAgentSignature\n  | TransactionFeePayerSignature;\n\nexport type TransactionEd25519Signature = {\n  type: string;\n  public_key: string;\n  signature: \"ed25519_signature\";\n};\n\nexport type TransactionSecp256k1Signature = {\n  type: string;\n  public_key: string;\n  signature: \"secp256k1_ecdsa_signature\";\n};\n\nexport type TransactionMultiEd25519Signature = {\n  type: \"multi_ed25519_signature\";\n  /**\n   * The public keys for the Ed25519 signature\n   */\n  public_keys: Array<string>;\n  /**\n   * Signature associated with the public keys in the same order\n   */\n  signatures: Array<string>;\n  /**\n   * The number of signatures required for a successful transaction\n   */\n  threshold: number;\n  bitmap: string;\n};\n\nexport type TransactionMultiAgentSignature = {\n  type: \"multi_agent_signature\";\n  sender: AccountSignature;\n  /**\n   * The other involved parties' addresses\n   */\n  secondary_signer_addresses: Array<string>;\n  /**\n   * The associated signatures, in the same order as the secondary addresses\n   */\n  secondary_signers: Array<AccountSignature>;\n};\n\nexport type TransactionFeePayerSignature = {\n  type: \"fee_payer_signature\";\n  sender: AccountSignature;\n  /**\n   * The other involved parties' addresses\n   */\n  secondary_signer_addresses: Array<string>;\n  /**\n   * The associated signatures, in the same order as the secondary addresses\n   */\n  secondary_signers: Array<AccountSignature>;\n  fee_payer_address: string;\n  fee_payer_signer: AccountSignature;\n};\n\n/**\n * The union of all single account signatures.\n */\nexport type AccountSignature = AccountEd25519Signature | AccountSecp256k1Signature | AccountMultiEd25519Signature;\n\nexport type AccountEd25519Signature = TransactionEd25519Signature;\n\nexport type AccountSecp256k1Signature = TransactionSecp256k1Signature;\n\nexport type AccountMultiEd25519Signature = TransactionMultiEd25519Signature;\n\nexport type WriteSet = ScriptWriteSet | DirectWriteSet;\n\nexport type ScriptWriteSet = {\n  type: string;\n  execute_as: string;\n  script: ScriptPayloadResponse;\n};\n\nexport type DirectWriteSet = {\n  type: string;\n  changes: Array<WriteSetChange>;\n  events: Array<Event>;\n};\n\nexport type EventGuid = {\n  creation_number: string;\n  account_address: string;\n};\n\nexport type Event = {\n  guid: EventGuid;\n  sequence_number: string;\n  type: string;\n  /**\n   * The JSON representation of the event\n   */\n  data: any;\n};\n\n/**\n * Map of Move types to local TypeScript types\n */\nexport type MoveUint8Type = number;\nexport type MoveUint16Type = number;\nexport type MoveUint32Type = number;\nexport type MoveUint64Type = string;\nexport type MoveUint128Type = string;\nexport type MoveUint256Type = string;\nexport type MoveAddressType = string;\nexport type MoveObjectType = string;\nexport type MoveOptionType = MoveType | null | undefined;\n/**\n * This is the format for a fully qualified struct, resource, or entry function in Move.\n */\nexport type MoveStructType = `${string}::${string}::${string}`;\n\nexport type MoveType =\n  | boolean\n  | string\n  | MoveUint8Type\n  | MoveUint16Type\n  | MoveUint32Type\n  | MoveUint64Type\n  | MoveUint128Type\n  | MoveUint256Type\n  | MoveAddressType\n  | MoveObjectType\n  | MoveStructType\n  | Array<MoveType>;\n\n/**\n * Possible Move values acceptable by move functions (entry, view)\n *\n * Map of a Move value to the corresponding TypeScript value\n *\n * `Bool -> boolean`\n *\n * `u8, u16, u32 -> number`\n *\n * `u64, u128, u256 -> string`\n *\n * `String -> string`\n *\n * `Address -> 0x${string}`\n *\n * `Struct - 0x${string}::${string}::${string}`\n *\n * `Object -> 0x${string}`\n *\n * `Vector -> Array<MoveValue>`\n *\n * `Option -> MoveValue | null | undefined`\n */\nexport type MoveValue =\n  | boolean\n  | string\n  | MoveUint8Type\n  | MoveUint16Type\n  | MoveUint32Type\n  | MoveUint64Type\n  | MoveUint128Type\n  | MoveUint256Type\n  | MoveAddressType\n  | MoveObjectType\n  | MoveStructType\n  | MoveOptionType\n  | Array<MoveValue>;\n\n/**\n * Move module id is a string representation of Move module.\n * Module name is case-sensitive.\n */\nexport type MoveModuleId = `${string}::${string}`;\n\n/**\n * Move function visibility\n */\nexport enum MoveFunctionVisibility {\n  PRIVATE = \"private\",\n  PUBLIC = \"public\",\n  FRIEND = \"friend\",\n}\n\n/**\n * Move function ability\n */\nexport enum MoveAbility {\n  STORE = \"store\",\n  DROP = \"drop\",\n  KEY = \"key\",\n  COPY = \"copy\",\n}\n\n/**\n * Move abilities tied to the generic type param and associated with the function that uses it\n */\nexport type MoveFunctionGenericTypeParam = {\n  constraints: Array<MoveAbility>;\n};\n\n/**\n * Move struct field\n */\nexport type MoveStructField = {\n  name: string;\n  type: string;\n};\n\n/**\n * A Move module\n */\nexport type MoveModule = {\n  address: string;\n  name: string;\n  /**\n   * Friends of the module\n   */\n  friends: Array<MoveModuleId>;\n  /**\n   * Public functions of the module\n   */\n  exposed_functions: Array<MoveFunction>;\n  /**\n   * Structs of the module\n   */\n  structs: Array<MoveStruct>;\n};\n\n/**\n * A move struct\n */\nexport type MoveStruct = {\n  name: string;\n  /**\n   * Whether the struct is a native struct of Move\n   */\n  is_native: boolean;\n  /**\n   * Abilities associated with the struct\n   */\n  abilities: Array<MoveAbility>;\n  /**\n   * Generic types associated with the struct\n   */\n  generic_type_params: Array<MoveFunctionGenericTypeParam>;\n  /**\n   * Fields associated with the struct\n   */\n  fields: Array<MoveStructField>;\n};\n\n/**\n * Move function\n */\nexport type MoveFunction = {\n  name: string;\n  visibility: MoveFunctionVisibility;\n  /**\n   * Whether the function can be called as an entry function directly in a transaction\n   */\n  is_entry: boolean;\n  /**\n   * Whether the function is a view function or not\n   */\n  is_view: boolean;\n  /**\n   * Generic type params associated with the Move function\n   */\n  generic_type_params: Array<MoveFunctionGenericTypeParam>;\n  /**\n   * Parameters associated with the move function\n   */\n  params: Array<string>;\n  /**\n   * Return type of the function\n   */\n  return: Array<string>;\n};\n\nexport enum RoleType {\n  VALIDATOR = \"validator\",\n  FULL_NODE = \"full_node\",\n}\n\nexport type LedgerInfo = {\n  /**\n   * Chain ID of the current chain\n   */\n  chain_id: number;\n  epoch: string;\n  ledger_version: string;\n  oldest_ledger_version: string;\n  ledger_timestamp: string;\n  node_role: RoleType;\n  oldest_block_height: string;\n  block_height: string;\n  /**\n   * Git hash of the build of the API endpoint.  Can be used to determine the exact\n   * software version used by the API endpoint.\n   */\n  git_hash?: string;\n};\n\n/**\n * A Block type\n */\nexport type Block = {\n  block_height: string;\n  block_hash: string;\n  block_timestamp: string;\n  first_version: string;\n  last_version: string;\n  /**\n   * The transactions in the block in sequential order\n   */\n  transactions?: Array<TransactionResponse>;\n};\n\n/**\n * The data needed to generate a View Request payload\n */\nexport type ViewRequestData = {\n  function: MoveStructType;\n  typeArguments?: Array<MoveStructType>;\n  functionArguments?: Array<MoveValue>;\n};\n\n// REQUEST TYPES\n\n/**\n * View request for the Move view function API\n *\n * `type MoveStructType = ${string}::${string}::${string}`;\n */\nexport type ViewRequest = {\n  function: MoveStructType;\n  /**\n   * Type arguments of the function\n   */\n  type_arguments: Array<MoveStructType>;\n  /**\n   * Arguments of the function\n   */\n  functionArguments: Array<MoveValue>;\n};\n\n/**\n * Table Item request for the GetTableItem API\n */\nexport type TableItemRequest = {\n  key_type: MoveValue;\n  value_type: MoveValue;\n  /**\n   * The value of the table item's key\n   */\n  key: any;\n};\n\n/**\n * A list of Authentication Key schemes that are supported by Aptos.\n *\n * They are combinations of signing schemes and derive schemes.\n */\nexport type AuthenticationKeyScheme = SigningScheme | DeriveScheme;\n\nexport enum SigningScheme {\n  /**\n   * For Ed25519PublicKey\n   */\n  Ed25519 = 0,\n  /**\n   * For MultiEd25519PublicKey\n   */\n  MultiEd25519 = 1,\n  /**\n   * For SingleKey ecdsa\n   */\n  SingleKey = 2,\n\n  MultiKey = 3,\n}\n\nexport enum SigningSchemeInput {\n  /**\n   * For Ed25519PublicKey\n   */\n  Ed25519 = 0,\n  /**\n   * For Secp256k1Ecdsa\n   */\n  Secp256k1Ecdsa = 2,\n}\n\n/**\n * Scheme used for deriving account addresses from other data\n */\nexport enum DeriveScheme {\n  /**\n   * Derives an address using an AUID, used for objects\n   */\n  DeriveAuid = 251,\n  /**\n   * Derives an address from another object address\n   */\n  DeriveObjectAddressFromObject = 252,\n  /**\n   * Derives an address from a GUID, used for objects\n   */\n  DeriveObjectAddressFromGuid = 253,\n  /**\n   * Derives an address from seed bytes, used for named objects\n   */\n  DeriveObjectAddressFromSeed = 254,\n  /**\n   * Derives an address from seed bytes, used for resource accounts\n   */\n  DeriveResourceAccountAddress = 255,\n}\n\n/**\n * Option properties to pass for waitForTransaction() function\n */\nexport type WaitForTransactionOptions = {\n  timeoutSecs?: number;\n  checkSuccess?: boolean;\n  indexerVersionCheck?: boolean;\n};\n/**\n * Account input type to generate an account using Legacy\n * Ed25519 or MultiEd25519 keys or without a specified `scheme`.\n * If `scheme` is not specified, we default to ED25519\n * In this case `legacy` is always true\n */\nexport type GenerateAccountWithLegacyKey = {\n  scheme?: SigningSchemeInput.Ed25519;\n  legacy: true;\n};\n\n/**\n * Account input type to generate an account using Unified\n * Secp256k1Ecdsa key\n * In this case `legacy` is always false\n */\nexport type GenerateAccountWithUnifiedKey = {\n  scheme: SigningSchemeInput.Secp256k1Ecdsa | SigningSchemeInput.Ed25519;\n  legacy?: false;\n};\n\n/**\n * Unify GenerateAccount type for Legacy and Unified keys\n */\nexport type GenerateAccount = GenerateAccountWithLegacyKey | GenerateAccountWithUnifiedKey;\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { AptosApiError, AptosResponse } from \"./types\";\nimport { VERSION } from \"../version\";\nimport { AptosRequest, MimeType, ClientRequest, ClientResponse, Client, AnyNumber } from \"../types\";\n\n/**\n * Meaningful errors map\n */\nconst errors: Record<number, string> = {\n  400: \"Bad Request\",\n  401: \"Unauthorized\",\n  403: \"Forbidden\",\n  404: \"Not Found\",\n  429: \"Too Many Requests\",\n  500: \"Internal Server Error\",\n  502: \"Bad Gateway\",\n  503: \"Service Unavailable\",\n};\n\n/**\n * Given a url and method, sends the request with axios and\n * returns the response.\n */\nexport async function request<Req, Res>(options: ClientRequest<Req>, client: Client): Promise<ClientResponse<Res>> {\n  const { url, method, body, contentType, params, overrides } = options;\n  const headers: Record<string, string | AnyNumber | boolean | undefined> = {\n    ...overrides?.HEADERS,\n    \"x-aptos-client\": `aptos-ts-sdk/${VERSION}`,\n    \"content-type\": contentType ?? MimeType.JSON,\n  };\n\n  if (overrides?.TOKEN) {\n    headers.Authorization = `Bearer ${overrides?.TOKEN}`;\n  }\n\n  /*\n   * make a call using the @aptos-labs/aptos-client package\n   * {@link https://www.npmjs.com/package/@aptos-labs/aptos-client}\n   */\n  return client.provider<Req, Res>({\n    url,\n    method,\n    body,\n    params,\n    headers,\n    overrides,\n  });\n}\n\n/**\n * The main function to use when doing an API request.\n *\n * @param options AptosRequest\n * @param aptosConfig The config information for the SDK client instance\n * @returns the response or AptosApiError\n */\nexport async function aptosRequest<Req, Res>(\n  options: AptosRequest,\n  aptosConfig: AptosConfig,\n): Promise<AptosResponse<Req, Res>> {\n  const { url, path } = options;\n  const fullUrl = `${url}/${path ?? \"\"}`;\n  const response = await request<Req, Res>({ ...options, url: fullUrl }, aptosConfig.client);\n\n  const result: AptosResponse<Req, Res> = {\n    status: response.status,\n    statusText: response.statusText!,\n    data: response.data,\n    headers: response.headers,\n    config: response.config,\n    request: response.request,\n    url: fullUrl,\n  };\n\n  // to support both fullnode and indexer responses,\n  // check if it is an indexer query, and adjust response.data\n  if (aptosConfig.isIndexerRequest(url)) {\n    const indexerResponse = result.data as any;\n    // errors from indexer\n    if (indexerResponse.errors) {\n      throw new AptosApiError(\n        options,\n        result,\n        indexerResponse.errors[0].message ?? `Unhandled Error ${response.status} : ${response.statusText}`,\n      );\n    }\n    result.data = indexerResponse.data as Res;\n  }\n\n  if (result.status >= 200 && result.status < 300) {\n    return result;\n  }\n\n  const errorMessage = errors[result.status];\n\n  throw new AptosApiError(\n    options,\n    result,\n    errorMessage ?? `Unhandled Error ${response.status} : ${response.statusText}`,\n  );\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nexport const NetworkToIndexerAPI: Record<string, string> = {\n  mainnet: \"https://indexer.mainnet.aptoslabs.com/v1/graphql\",\n  testnet: \"https://indexer-testnet.staging.gcp.aptosdev.com/v1/graphql\",\n  devnet: \"https://indexer-devnet.staging.gcp.aptosdev.com/v1/graphql\",\n  local: \"http://127.0.0.1:8090/v1/graphql\",\n};\n\nexport const NetworkToNodeAPI: Record<string, string> = {\n  mainnet: \"https://fullnode.mainnet.aptoslabs.com/v1\",\n  testnet: \"https://fullnode.testnet.aptoslabs.com/v1\",\n  devnet: \"https://fullnode.devnet.aptoslabs.com/v1\",\n  local: \"http://127.0.0.1:8080/v1\",\n};\n\nexport const NetworkToFaucetAPI: Record<string, string> = {\n  mainnet: \"https://faucet.mainnet.aptoslabs.com\",\n  testnet: \"https://faucet.testnet.aptoslabs.com\",\n  devnet: \"https://faucet.devnet.aptoslabs.com\",\n  local: \"http://127.0.0.1:8081\",\n};\n\nexport enum Network {\n  MAINNET = \"mainnet\",\n  TESTNET = \"testnet\",\n  DEVNET = \"devnet\",\n  LOCAL = \"local\",\n  CUSTOM = \"custom\",\n}\n\nexport const NetworkToChainId: Record<string, number> = {\n  mainnet: 1,\n  testnet: 2,\n};\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Network } from \"./apiEndpoints\";\n\n/**\n * Type of API endpoint for request routing\n */\nexport enum AptosApiType {\n  FULLNODE,\n  INDEXER,\n  FAUCET,\n}\n\nexport const DEFAULT_NETWORK = Network.DEVNET;\n\n/**\n * The default max gas amount when none is given.\n *\n * This is the maximum number of gas units that will be used by a transaction before being rejected.\n *\n * Note that max gas amount varies based on the transaction.  A larger transaction will go over this\n * default gas amount, and the value will need to be changed for the specific transaction.\n */\nexport const DEFAULT_MAX_GAS_AMOUNT = 200000;\n\n/**\n * The default transaction expiration seconds from now.\n *\n * This time is how long until the blockchain nodes will reject the transaction.\n *\n * Note that the transaction expiration time varies based on network connection and network load.  It may need to be\n * increased for the transaction to be processed.\n */\nexport const DEFAULT_TXN_EXP_SEC_FROM_NOW = 20;\n\n/**\n * The default number of seconds to wait for a transaction to be processed.\n *\n * This time is the amount of time that the SDK will wait for a transaction to be processed when waiting for\n * the results of the transaction.  It may take longer based on network connection and network load.\n */\nexport const DEFAULT_TXN_TIMEOUT_SEC = 20;\n\n/**\n * The default gas currency for the network.\n */\nexport const APTOS_COIN = \"0x1::aptos_coin::AptosCoin\";\n\nexport const RAW_TRANSACTION_SALT = \"APTOS::RawTransaction\";\nexport const RAW_TRANSACTION_WITH_DATA_SALT = \"APTOS::RawTransactionWithData\";\n","import { AptosConfig } from \"../api/aptosConfig\";\nimport { aptosRequest } from \"./core\";\nimport { AptosResponse } from \"./types\";\nimport { AnyNumber, ClientConfig, MimeType } from \"../types\";\nimport { AptosApiType } from \"../utils/const\";\n\nexport type GetRequestOptions = {\n  /**\n   * The config for the API client\n   */\n  aptosConfig: AptosConfig;\n  /**\n   * The type of API endpoint to call e.g. fullnode, indexer, etc\n   */\n  type: AptosApiType;\n  /**\n   * The name of the API method\n   */\n  originMethod: string;\n  /**\n   * The URL path to the API method\n   */\n  path: string;\n  /**\n   * The content type of the request body\n   */\n  contentType?: MimeType;\n  /**\n   * The accepted content type of the response of the API\n   */\n  acceptType?: MimeType;\n  /**\n   * The query parameters for the request\n   */\n  params?: Record<string, string | AnyNumber | boolean | undefined>;\n  /**\n   * Specific client overrides for this request to override aptosConfig\n   */\n  overrides?: ClientConfig;\n};\n\nexport type GetAptosRequestOptions = Omit<GetRequestOptions, \"type\">;\n\n/**\n * Main function to do a Get request\n *\n * @param options GetRequestOptions\n * @returns\n */\nexport async function get<Req, Res>(options: GetRequestOptions): Promise<AptosResponse<Req, Res>> {\n  const { aptosConfig, overrides, params, contentType, acceptType, path, originMethod, type } = options;\n  const url = aptosConfig.getRequestUrl(type);\n\n  return aptosRequest<Req, Res>(\n    {\n      url,\n      method: \"GET\",\n      originMethod,\n      path,\n      contentType: contentType?.valueOf(),\n      acceptType: acceptType?.valueOf(),\n      params,\n      overrides: {\n        ...aptosConfig.clientConfig,\n        ...overrides,\n      },\n    },\n    aptosConfig,\n  );\n}\n\nexport async function getAptosFullNode<Req, Res>(options: GetAptosRequestOptions): Promise<AptosResponse<Req, Res>> {\n  return get<Req, Res>({ ...options, type: AptosApiType.FULLNODE });\n}\n\n/// This function is a helper for paginating using a function wrapping an API\nexport async function paginateWithCursor<Req extends Record<string, any>, Res extends any[]>(\n  options: GetAptosRequestOptions,\n): Promise<Res> {\n  const out = [];\n  let cursor: string | undefined;\n  const requestParams = options.params as Req & { start?: string; limit?: number };\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    requestParams.start = cursor;\n    // eslint-disable-next-line no-await-in-loop\n    const response = await getAptosFullNode<Req, Res>({\n      aptosConfig: options.aptosConfig,\n      originMethod: options.originMethod,\n      path: options.path,\n      params: requestParams,\n      overrides: options.overrides,\n    });\n    /**\n     * the cursor is a \"state key\" from the API perspective. Client\n     * should not need to \"care\" what it represents but just use it\n     * to query the next chunk of data.\n     */\n    cursor = response.headers[\"x-aptos-cursor\"];\n    // Now that we have the cursor (if any), we remove the headers before\n    // adding these to the output of this function.\n    delete (response as any).headers;\n    out.push(...response.data);\n    if (cursor === null || cursor === undefined) {\n      break;\n    }\n  }\n  return out as any;\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { aptosRequest } from \"./core\";\nimport { AptosResponse } from \"./types\";\nimport { AnyNumber, ClientConfig, MimeType } from \"../types\";\nimport { AptosApiType } from \"../utils/const\";\n\nexport type PostRequestOptions = {\n  /**\n   * The config for the API client\n   */\n  aptosConfig: AptosConfig;\n  /**\n   * The type of API endpoint to call e.g. fullnode, indexer, etc\n   */\n  type: AptosApiType;\n  /**\n   * The name of the API method\n   */\n  originMethod: string;\n  /**\n   * The URL path to the API method\n   */\n  path: string;\n  /**\n   * The content type of the request body\n   */\n  contentType?: MimeType;\n  /**\n   * The accepted content type of the response of the API\n   */\n  acceptType?: MimeType;\n  /**\n   * The query parameters for the request\n   */\n  params?: Record<string, string | AnyNumber | boolean | undefined>;\n  /**\n   * The body of the request, should match the content type of the request\n   */\n  body?: any;\n  /**\n   * Specific client overrides for this request to override aptosConfig\n   */\n  overrides?: ClientConfig;\n};\n\nexport type PostAptosRequestOptions = Omit<PostRequestOptions, \"type\">;\n\n/**\n * Main function to do a Post request\n *\n * @param options PostRequestOptions\n * @returns\n */\nexport async function post<Req, Res>(options: PostRequestOptions): Promise<AptosResponse<Req, Res>> {\n  const { type, originMethod, path, body, acceptType, contentType, params, aptosConfig, overrides } = options;\n  const url = aptosConfig.getRequestUrl(type);\n\n  return aptosRequest<Req, Res>(\n    {\n      url,\n      method: \"POST\",\n      originMethod,\n      path,\n      body,\n      contentType: contentType?.valueOf(),\n      acceptType: acceptType?.valueOf(),\n      params,\n      overrides: {\n        ...aptosConfig.clientConfig,\n        ...overrides,\n      },\n    },\n    aptosConfig,\n  );\n}\n\nexport async function postAptosFullNode<Req, Res>(options: PostAptosRequestOptions): Promise<AptosResponse<Req, Res>> {\n  return post<Req, Res>({ ...options, type: AptosApiType.FULLNODE });\n}\n\nexport async function postAptosIndexer<Req, Res>(options: PostAptosRequestOptions): Promise<AptosResponse<Req, Res>> {\n  return post<Req, Res>({ ...options, type: AptosApiType.INDEXER });\n}\n\nexport async function postAptosFaucet<Req, Res>(options: PostAptosRequestOptions): Promise<AptosResponse<Req, Res>> {\n  return post<Req, Res>({ ...options, type: AptosApiType.FAUCET });\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bytesToHex, hexToBytes } from \"@noble/hashes/utils\";\nimport { Serializable, Serializer } from \"../bcs/serializer\";\nimport { Deserializer } from \"../bcs/deserializer\";\nimport { ParsingError, ParsingResult } from \"./common\";\nimport { TransactionArgument } from \"../transactions/instances/transactionArgument\";\nimport { HexInput, ScriptTransactionArgumentVariants } from \"../types\";\n\n/**\n * This enum is used to explain why an address was invalid.\n */\nexport enum AddressInvalidReason {\n  INCORRECT_NUMBER_OF_BYTES = \"incorrect_number_of_bytes\",\n  INVALID_HEX_CHARS = \"invalid_hex_chars\",\n  TOO_SHORT = \"too_short\",\n  TOO_LONG = \"too_long\",\n  LEADING_ZERO_X_REQUIRED = \"leading_zero_x_required\",\n  LONG_FORM_REQUIRED_UNLESS_SPECIAL = \"long_form_required_unless_special\",\n  INVALID_PADDING_ZEROES = \"INVALID_PADDING_ZEROES\",\n}\n\n/**\n * NOTE: Only use this class for account addresses. For other hex data, e.g. transaction\n * hashes, use the Hex class.\n *\n * AccountAddress is used for working with account addresses. Account addresses, when\n * represented as a string, generally look like these examples:\n * - 0x1\n * - 0xaa86fe99004361f747f91342ca13c426ca0cccb0c1217677180c9493bad6ef0c\n *\n * Proper formatting and parsing of account addresses is defined by AIP-40.\n * To learn more about the standard, read the AIP here:\n * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.\n *\n * The comments in this class make frequent reference to the LONG and SHORT formats,\n * as well as \"special\" addresses. To learn what these refer to see AIP-40.\n */\nexport class AccountAddress extends Serializable implements TransactionArgument {\n  /**\n   * This is the internal representation of an account address.\n   */\n  readonly data: Uint8Array;\n\n  /**\n   * The number of bytes that make up an account address.\n   */\n  static readonly LENGTH: number = 32;\n\n  /**\n   * The length of an address string in LONG form without a leading 0x.\n   */\n  static readonly LONG_STRING_LENGTH: number = 64;\n\n  static ZERO: AccountAddress = AccountAddress.fromString(\"0x0\");\n\n  static ONE: AccountAddress = AccountAddress.fromString(\"0x1\");\n\n  static TWO: AccountAddress = AccountAddress.fromString(\"0x2\");\n\n  static THREE: AccountAddress = AccountAddress.fromString(\"0x3\");\n\n  static FOUR: AccountAddress = AccountAddress.fromString(\"0x4\");\n\n  /**\n   * Creates an instance of AccountAddress from a Uint8Array.\n   *\n   * @param args.data A Uint8Array representing an account address.\n   */\n  constructor(args: { data: Uint8Array }) {\n    super();\n    if (args.data.length !== AccountAddress.LENGTH) {\n      throw new ParsingError(\n        \"AccountAddress data should be exactly 32 bytes long\",\n        AddressInvalidReason.INCORRECT_NUMBER_OF_BYTES,\n      );\n    }\n    this.data = args.data;\n  }\n\n  /**\n   * Returns whether an address is special, where special is defined as 0x0 to 0xf\n   * inclusive. In other words, the last byte of the address must be < 0b10000 (16)\n   * and every other byte must be zero.\n   *\n   * For more information on how special addresses are defined see AIP-40:\n   * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.\n   *\n   * @returns true if the address is special, false if not.\n   */\n  isSpecial(): boolean {\n    return (\n      this.data.slice(0, this.data.length - 1).every((byte) => byte === 0) && this.data[this.data.length - 1] < 0b10000\n    );\n  }\n\n  // ===\n  // Methods for representing an instance of AccountAddress as other types.\n  // ===\n\n  /**\n   * Return the AccountAddress as a string as per AIP-40.\n   * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.\n   *\n   * In short, it means that special addresses are represented in SHORT form, meaning\n   * 0x0 through to 0xf inclusive, and every other address is represented in LONG form,\n   * meaning 0x + 64 hex characters.\n   *\n   * @returns AccountAddress as a string conforming to AIP-40.\n   */\n  toString(): `0x${string}` {\n    return `0x${this.toStringWithoutPrefix()}`;\n  }\n\n  /**\n   * NOTE: Prefer to use `toString` where possible.\n   *\n   * Return the AccountAddress as a string as per AIP-40 but without the leading 0x.\n   *\n   * Learn more by reading the docstring of `toString`.\n   *\n   * @returns AccountAddress as a string conforming to AIP-40 but without the leading 0x.\n   */\n  toStringWithoutPrefix(): string {\n    let hex = bytesToHex(this.data);\n    if (this.isSpecial()) {\n      hex = hex[hex.length - 1];\n    }\n    return hex;\n  }\n\n  /**\n   * NOTE: Prefer to use `toString` where possible.\n   *\n   * Whereas toString will format special addresses (as defined by isSpecial) using the\n   * SHORT form (no leading 0s), this format the address in the LONG format\n   * unconditionally.\n   *\n   * This means it will be 0x + 64 hex characters.\n   *\n   * @returns AccountAddress as a string in LONG form.\n   */\n  toStringLong(): `0x${string}` {\n    return `0x${this.toStringLongWithoutPrefix()}`;\n  }\n\n  /**\n   * NOTE: Prefer to use `toString` where possible.\n   *\n   * Whereas toString will format special addresses (as defined by isSpecial) using the\n   * SHORT form (no leading 0s), this function will include leading zeroes. The string\n   * will not have a leading zero.\n   *\n   * This means it will be 64 hex characters without a leading 0x.\n   *\n   * @returns AccountAddress as a string in LONG form without a leading 0x.\n   */\n  toStringLongWithoutPrefix(): string {\n    return bytesToHex(this.data);\n  }\n\n  /**\n   * Get the inner hex data. The inner data is already a Uint8Array so no conversion\n   * is taking place here, it just returns the inner data.\n   *\n   * @returns Hex data as Uint8Array\n   */\n  toUint8Array(): Uint8Array {\n    return this.data;\n  }\n\n  /**\n   * Serialize the AccountAddress to a Serializer instance's data buffer.\n   * @param serializer The serializer to serialize the AccountAddress to.\n   * @returns void\n   * @example\n   * const serializer = new Serializer();\n   * const address = AccountAddress.fromString(\"0x1\");\n   * address.serialize(serializer);\n   * const bytes = serializer.toUint8Array();\n   * // `bytes` is now the BCS-serialized address.\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeFixedBytes(this.data);\n  }\n\n  serializeForEntryFunction(serializer: Serializer): void {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n\n  serializeForScriptFunction(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(ScriptTransactionArgumentVariants.Address);\n    serializer.serialize(this);\n  }\n\n  /**\n   * Deserialize an AccountAddress from the byte buffer in a Deserializer instance.\n   * @param deserializer The deserializer to deserialize the AccountAddress from.\n   * @returns An instance of AccountAddress.\n   * @example\n   * const bytes = hexToBytes(\"0x0102030405060708091011121314151617181920212223242526272829303132\");\n   * const deserializer = new Deserializer(bytes);\n   * const address = AccountAddress.deserialize(deserializer);\n   * // `address` is now an instance of AccountAddress.\n   */\n  static deserialize(deserializer: Deserializer): AccountAddress {\n    const bytes = deserializer.deserializeFixedBytes(AccountAddress.LENGTH);\n    return new AccountAddress({ data: bytes });\n  }\n\n  // ===\n  // Methods for creating an instance of AccountAddress from other types.\n  // ===\n\n  /**\n   * NOTE: This function has strict parsing behavior. For relaxed behavior, please use\n   * the `fromStringRelaxed` function.\n   *\n   * Creates an instance of AccountAddress from a hex string.\n   *\n   * This function allows only the strictest formats defined by AIP-40. In short this\n   * means only the following formats are accepted:\n   *\n   * - LONG\n   * - SHORT for special addresses\n   *\n   * Where:\n   * - LONG is defined as 0x + 64 hex characters.\n   * - SHORT for special addresses is 0x0 to 0xf inclusive without padding zeroes.\n   *\n   * This means the following are not accepted:\n   * - SHORT for non-special addresses.\n   * - Any address without a leading 0x.\n   *\n   * Learn more about the different address formats by reading AIP-40:\n   * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.\n   *\n   * @param input A hex string representing an account address.\n   *\n   * @returns An instance of AccountAddress.\n   */\n  static fromString(input: string): AccountAddress {\n    // Assert the string starts with 0x.\n    if (!input.startsWith(\"0x\")) {\n      throw new ParsingError(\"Hex string must start with a leading 0x.\", AddressInvalidReason.LEADING_ZERO_X_REQUIRED);\n    }\n\n    const address = AccountAddress.fromStringRelaxed(input);\n\n    // Check if the address is in LONG form. If it is not, this is only allowed for\n    // special addresses, in which case we check it is in proper SHORT form.\n    if (input.length !== AccountAddress.LONG_STRING_LENGTH + 2) {\n      if (!address.isSpecial()) {\n        throw new ParsingError(\n          `The given hex string ${address} is not a special address, it must be represented as 0x + 64 chars.`,\n          AddressInvalidReason.LONG_FORM_REQUIRED_UNLESS_SPECIAL,\n        );\n      } else if (input.length !== 3) {\n        // 0x + one hex char is the only valid SHORT form for special addresses.\n        throw new ParsingError(\n          // eslint-disable-next-line max-len\n          `The given hex string ${input} is a special address not in LONG form, it must be 0x0 to 0xf without padding zeroes.`,\n          AddressInvalidReason.INVALID_PADDING_ZEROES,\n        );\n      }\n    }\n\n    return address;\n  }\n\n  /**\n   * NOTE: This function has relaxed parsing behavior. For strict behavior, please use\n   * the `fromString` function. Where possible use `fromString` rather than this\n   * function, `fromStringRelaxed` is only provided for backwards compatibility.\n   *\n   * Creates an instance of AccountAddress from a hex string.\n   *\n   * This function allows all formats defined by AIP-40. In short this means the\n   * following formats are accepted:\n   *\n   * - LONG, with or without leading 0x\n   * - SHORT, with or without leading 0x\n   *\n   * Where:\n   * - LONG is 64 hex characters.\n   * - SHORT is 1 to 63 hex characters inclusive.\n   * - Padding zeroes are allowed, e.g. 0x0123 is valid.\n   *\n   * Learn more about the different address formats by reading AIP-40:\n   * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.\n   *\n   * @param input A hex string representing an account address.\n   *\n   * @returns An instance of AccountAddress.\n   */\n  static fromStringRelaxed(input: string): AccountAddress {\n    let parsedInput = input;\n    // Remove leading 0x for parsing.\n    if (input.startsWith(\"0x\")) {\n      parsedInput = input.slice(2);\n    }\n\n    // Ensure the address string is at least 1 character long.\n    if (parsedInput.length === 0) {\n      throw new ParsingError(\n        \"Hex string is too short, must be 1 to 64 chars long, excluding the leading 0x.\",\n        AddressInvalidReason.TOO_SHORT,\n      );\n    }\n\n    // Ensure the address string is not longer than 64 characters.\n    if (parsedInput.length > 64) {\n      throw new ParsingError(\n        \"Hex string is too long, must be 1 to 64 chars long, excluding the leading 0x.\",\n        AddressInvalidReason.TOO_LONG,\n      );\n    }\n\n    let addressBytes: Uint8Array;\n    try {\n      // Pad the address with leading zeroes, so it is 64 chars long and then convert\n      // the hex string to bytes. Every two characters in a hex string constitutes a\n      // single byte. So a 64 length hex string becomes a 32 byte array.\n      addressBytes = hexToBytes(parsedInput.padStart(64, \"0\"));\n    } catch (e) {\n      const error = e as Error;\n      // At this point the only way this can fail is if the hex string contains\n      // invalid characters.\n      throw new ParsingError(`Hex characters are invalid: ${error.message}`, AddressInvalidReason.INVALID_HEX_CHARS);\n    }\n\n    return new AccountAddress({ data: addressBytes });\n  }\n\n  /**\n   * Convenience method for creating an AccountAddress from HexInput. For\n   * more information on how this works, see the constructor and fromString.\n   *\n   * @param input A hex string or Uint8Array representing an account address.\n   *\n   * @returns An instance of AccountAddress.\n   */\n  static fromHexInput(input: HexInput): AccountAddress {\n    if (input instanceof Uint8Array) {\n      return new AccountAddress({ data: input });\n    }\n    return AccountAddress.fromString(input);\n  }\n\n  /**\n   * Convenience method for creating an AccountAddress from HexInput. For\n   * more information on how this works, see the constructor and fromStringRelaxed.\n   *\n   * @param hexInput A hex string or Uint8Array representing an account address.\n   *\n   * @returns An instance of AccountAddress.\n   */\n  static fromHexInputRelaxed(hexInput: HexInput): AccountAddress {\n    if (hexInput instanceof Uint8Array) {\n      return new AccountAddress({ data: hexInput });\n    }\n    return AccountAddress.fromStringRelaxed(hexInput);\n  }\n\n  // ===\n  // Methods for checking validity.\n  // ===\n\n  /**\n   * Check if the string is a valid AccountAddress.\n   *\n   * @param args.input A hex string representing an account address.\n   * @param args.relaxed If true, use relaxed parsing behavior. If false, use strict parsing behavior.\n   *\n   * @returns valid = true if the string is valid, valid = false if not. If the string\n   * is not valid, invalidReason will be set explaining why it is invalid.\n   */\n  static isValid(args: { input: string; relaxed?: boolean }): ParsingResult<AddressInvalidReason> {\n    try {\n      if (args.relaxed) {\n        AccountAddress.fromStringRelaxed(args.input);\n      } else {\n        AccountAddress.fromString(args.input);\n      }\n      return { valid: true };\n    } catch (e) {\n      const error = e as ParsingError<AddressInvalidReason>;\n      return {\n        valid: false,\n        invalidReason: error.invalidReason,\n        invalidReasonMessage: error.message,\n      };\n    }\n  }\n\n  /**\n   * Return whether AccountAddresses are equal. AccountAddresses are considered equal\n   * if their underlying byte data is identical.\n   *\n   * @param other The AccountAddress to compare to.\n   * @returns true if the AccountAddresses are equal, false if not.\n   */\n  equals(other: AccountAddress): boolean {\n    if (this.data.length !== other.data.length) return false;\n    return this.data.every((value, index) => value === other.data[index]);\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Uint8, Uint16, Uint32, Uint64, Uint128, Uint256 } from \"../types\";\n\n// Upper bound values for uint8, uint16, uint64 and uint128\nexport const MAX_U8_NUMBER: Uint8 = 2 ** 8 - 1;\nexport const MAX_U16_NUMBER: Uint16 = 2 ** 16 - 1;\nexport const MAX_U32_NUMBER: Uint32 = 2 ** 32 - 1;\nexport const MAX_U64_BIG_INT: Uint64 = BigInt(2) ** BigInt(64) - BigInt(1);\nexport const MAX_U128_BIG_INT: Uint128 = BigInt(2) ** BigInt(128) - BigInt(1);\nexport const MAX_U256_BIG_INT: Uint256 = BigInt(2) ** BigInt(256) - BigInt(1);\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bytesToHex, hexToBytes } from \"@noble/hashes/utils\";\nimport { ParsingError, ParsingResult } from \"./common\";\nimport { HexInput } from \"../types\";\n\n/**\n * This enum is used to explain why parsing might have failed.\n */\nexport enum HexInvalidReason {\n  TOO_SHORT = \"too_short\",\n  INVALID_LENGTH = \"invalid_length\",\n  INVALID_HEX_CHARS = \"invalid_hex_chars\",\n}\n\n/**\n * NOTE: Do not use this class when working with account addresses, use AccountAddress.\n *\n * NOTE: When accepting hex data as input to a function, prefer to accept HexInput and\n * then use the static helper methods of this class to convert it into the desired\n * format. This enables the greatest flexibility for the developer.\n *\n * Hex is a helper class for working with hex data. Hex data, when represented as a\n * string, generally looks like this, for example: 0xaabbcc, 45cd32, etc.\n *\n * You might use this class like this:\n *\n * ```ts\n * getTransactionByHash(txnHash: HexInput): Promise<Transaction> {\n *   const txnHashString = Hex.fromHexInput(txnHash).toString();\n *   return await getTransactionByHashInner(txnHashString);\n * }\n * ```\n *\n * This call to `Hex.fromHexInput().toString()` converts the HexInput to a hex string\n * with a leading 0x prefix, regardless of what the input format was.\n *\n * These are some other ways to chain the functions together:\n * - `Hex.fromString({ hexInput: \"0x1f\" }).toUint8Array()`\n * - `new Hex([1, 3]).toStringWithoutPrefix()`\n */\nexport class Hex {\n  private readonly data: Uint8Array;\n\n  /**\n   * Create a new Hex instance from a Uint8Array.\n   *\n   * @param data Uint8Array\n   */\n  constructor(data: Uint8Array) {\n    this.data = data;\n  }\n\n  // ===\n  // Methods for representing an instance of Hex as other types.\n  // ===\n\n  /**\n   * Get the inner hex data. The inner data is already a Uint8Array so no conversion\n   * is taking place here, it just returns the inner data.\n   *\n   * @returns Hex data as Uint8Array\n   */\n  toUint8Array(): Uint8Array {\n    return this.data;\n  }\n\n  /**\n   * Get the hex data as a string without the 0x prefix.\n   *\n   * @returns Hex string without 0x prefix\n   */\n  toStringWithoutPrefix(): string {\n    return bytesToHex(this.data);\n  }\n\n  /**\n   * Get the hex data as a string with the 0x prefix.\n   *\n   * @returns Hex string with 0x prefix\n   */\n  toString(): string {\n    return `0x${this.toStringWithoutPrefix()}`;\n  }\n\n  // ===\n  // Methods for creating an instance of Hex from other types.\n  // ===\n\n  /**\n   * Static method to convert a hex string to Hex\n   *\n   * @param str A hex string, with or without the 0x prefix\n   *\n   * @returns Hex\n   */\n  static fromString(str: string): Hex {\n    let input = str;\n\n    if (input.startsWith(\"0x\")) {\n      input = input.slice(2);\n    }\n\n    if (input.length === 0) {\n      throw new ParsingError(\n        \"Hex string is too short, must be at least 1 char long, excluding the optional leading 0x.\",\n        HexInvalidReason.TOO_SHORT,\n      );\n    }\n\n    if (input.length % 2 !== 0) {\n      throw new ParsingError(\"Hex string must be an even number of hex characters.\", HexInvalidReason.INVALID_LENGTH);\n    }\n\n    try {\n      return new Hex(hexToBytes(input));\n    } catch (e) {\n      const error = e as Error;\n      throw new ParsingError(\n        `Hex string contains invalid hex characters: ${error.message}`,\n        HexInvalidReason.INVALID_HEX_CHARS,\n      );\n    }\n  }\n\n  /**\n   * Static method to convert an instance of HexInput to Hex\n   *\n   * @param hexInput A HexInput (string or Uint8Array)\n   *\n   * @returns Hex\n   */\n  static fromHexInput(hexInput: HexInput): Hex {\n    if (hexInput instanceof Uint8Array) return new Hex(hexInput);\n    return Hex.fromString(hexInput);\n  }\n\n  // ===\n  // Methods for checking validity.\n  // ===\n\n  /**\n   * Check if the string is valid hex.\n   *\n   * @param str A hex string representing byte data.\n   *\n   * @returns valid = true if the string is valid, false if not. If the string is not\n   * valid, invalidReason and invalidReasonMessage will be set explaining why it is\n   * invalid.\n   */\n  static isValid(str: string): ParsingResult<HexInvalidReason> {\n    try {\n      Hex.fromString(str);\n      return { valid: true };\n    } catch (e) {\n      const error = e as ParsingError<HexInvalidReason>;\n      return {\n        valid: false,\n        invalidReason: error.invalidReason,\n        invalidReasonMessage: error.message,\n      };\n    }\n  }\n\n  /**\n   * Return whether Hex instances are equal. Hex instances are considered equal if\n   * their underlying byte data is identical.\n   *\n   * @param other The Hex instance to compare to.\n   * @returns true if the Hex instances are equal, false if not.\n   */\n  equals(other: Hex): boolean {\n    if (this.data.length !== other.data.length) return false;\n    return this.data.every((value, index) => value === other.data[index]);\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This error is used to explain why parsing failed.\n */\nexport class ParsingError<T> extends Error {\n  /**\n   * This provides a programmatic way to access why parsing failed. Downstream devs\n   * might want to use this to build their own error messages if the default error\n   * messages are not suitable for their use case. This should be an enum.\n   */\n  public invalidReason: T;\n\n  constructor(message: string, invalidReason: T) {\n    super(message);\n    this.invalidReason = invalidReason;\n  }\n}\n\n/**\n * Whereas ParsingError is thrown when parsing fails, e.g. in a fromString function,\n * this type is returned from \"defensive\" functions like isValid.\n */\nexport type ParsingResult<T> = {\n  /**\n   * True if valid, false otherwise.\n   */\n  valid: boolean;\n\n  /**\n   * If valid is false, this will be a code explaining why parsing failed.\n   */\n  invalidReason?: T;\n\n  /**\n   * If valid is false, this will be a string explaining why parsing failed.\n   */\n  invalidReasonMessage?: string;\n};\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable no-bitwise */\nimport {\n  MAX_U128_BIG_INT,\n  MAX_U16_NUMBER,\n  MAX_U32_NUMBER,\n  MAX_U64_BIG_INT,\n  MAX_U8_NUMBER,\n  MAX_U256_BIG_INT,\n} from \"./consts\";\nimport { Hex } from \"../core/hex\";\nimport { AnyNumber, Uint16, Uint32, Uint8 } from \"../types\";\n\n// This class is intended to be used as a base class for all serializable types.\n// It can be used to facilitate composable serialization of a complex type and\n// in general to serialize a type to its BCS representation.\nexport abstract class Serializable {\n  abstract serialize(serializer: Serializer): void;\n\n  /**\n   * Serializes a `Serializable` value to its BCS representation.\n   * This function is the Typescript SDK equivalent of `bcs::to_bytes` in Move.\n   * @returns the BCS representation of the Serializable instance as a byte buffer\n   */\n  bcsToBytes(): Uint8Array {\n    const serializer = new Serializer();\n    this.serialize(serializer);\n    return serializer.toUint8Array();\n  }\n\n  /**\n   * Helper function to get a value's BCS-serialized bytes as a Hex instance.\n   * @returns a Hex instance with the BCS-serialized bytes loaded into its underlying Uint8Array\n   */\n  bcsToHex(): Hex {\n    const bcsBytes = this.bcsToBytes();\n    return Hex.fromHexInput(bcsBytes);\n  }\n}\n\nexport class Serializer {\n  private buffer: ArrayBuffer;\n\n  private offset: number;\n\n  // Constructs a serializer with a buffer of size `length` bytes, 64 bytes by default.\n  // `length` must be greater than 0.\n  constructor(length: number = 64) {\n    if (length <= 0) {\n      throw new Error(\"Length needs to be greater than 0\");\n    }\n    this.buffer = new ArrayBuffer(length);\n    this.offset = 0;\n  }\n\n  private ensureBufferWillHandleSize(bytes: number) {\n    while (this.buffer.byteLength < this.offset + bytes) {\n      const newBuffer = new ArrayBuffer(this.buffer.byteLength * 2);\n      new Uint8Array(newBuffer).set(new Uint8Array(this.buffer));\n      this.buffer = newBuffer;\n    }\n  }\n\n  protected appendToBuffer(values: Uint8Array) {\n    this.ensureBufferWillHandleSize(values.length);\n    new Uint8Array(this.buffer, this.offset).set(values);\n    this.offset += values.length;\n  }\n\n  private serializeWithFunction(\n    fn: (byteOffset: number, value: number, littleEndian?: boolean) => void,\n    bytesLength: number,\n    value: number,\n  ) {\n    this.ensureBufferWillHandleSize(bytesLength);\n    const dv = new DataView(this.buffer, this.offset);\n    fn.apply(dv, [0, value, true]);\n    this.offset += bytesLength;\n  }\n\n  /**\n   * Serializes a string. UTF8 string is supported.\n   *\n   * The number of bytes in the string content is serialized first, as a uleb128-encoded u32 integer.\n   * Then the string content is serialized as UTF8 encoded bytes.\n   *\n   * BCS layout for \"string\": string_length | string_content\n   * where string_length is a u32 integer encoded as a uleb128 integer, equal to the number of bytes in string_content.\n   *\n   * @example\n   * ```ts\n   * const serializer = new Serializer();\n   * serializer.serializeStr(\"1234abcd\");\n   * assert(serializer.toUint8Array() === new Uint8Array([8, 49, 50, 51, 52, 97, 98, 99, 100]));\n   * ```\n   */\n  serializeStr(value: string) {\n    const textEncoder = new TextEncoder();\n    this.serializeBytes(textEncoder.encode(value));\n  }\n\n  /**\n   * Serializes an array of bytes.\n   *\n   * BCS layout for \"bytes\": bytes_length | bytes\n   * where bytes_length is a u32 integer encoded as a uleb128 integer, equal to the length of the bytes array.\n   */\n  serializeBytes(value: Uint8Array) {\n    this.serializeU32AsUleb128(value.length);\n    this.appendToBuffer(value);\n  }\n\n  /**\n   * Serializes an array of bytes with known length. Therefore, length doesn't need to be\n   * serialized to help deserialization.\n   *\n   * When deserializing, the number of bytes to deserialize needs to be passed in.\n   */\n  serializeFixedBytes(value: Uint8Array) {\n    this.appendToBuffer(value);\n  }\n\n  /**\n   * Serializes a boolean value.\n   *\n   * BCS layout for \"boolean\": One byte. \"0x01\" for true and \"0x00\" for false.\n   */\n  serializeBool(value: boolean) {\n    ensureBoolean(value);\n    const byteValue = value ? 1 : 0;\n    this.appendToBuffer(new Uint8Array([byteValue]));\n  }\n\n  /**\n   * Serializes a uint8 number.\n   *\n   * BCS layout for \"uint8\": One byte. Binary format in little-endian representation.\n   */\n  @checkNumberRange(0, MAX_U8_NUMBER)\n  serializeU8(value: Uint8) {\n    this.appendToBuffer(new Uint8Array([value]));\n  }\n\n  /**\n   * Serializes a uint16 number.\n   *\n   * BCS layout for \"uint16\": Two bytes. Binary format in little-endian representation.\n   * @example\n   * ```ts\n   * const serializer = new Serializer();\n   * serializer.serializeU16(4660);\n   * assert(serializer.toUint8Array() === new Uint8Array([0x34, 0x12]));\n   * ```\n   */\n  @checkNumberRange(0, MAX_U16_NUMBER)\n  serializeU16(value: Uint16) {\n    this.serializeWithFunction(DataView.prototype.setUint16, 2, value);\n  }\n\n  /**\n   * Serializes a uint32 number.\n   *\n   * BCS layout for \"uint32\": Four bytes. Binary format in little-endian representation.\n   * @example\n   * ```ts\n   * const serializer = new Serializer();\n   * serializer.serializeU32(305419896);\n   * assert(serializer.toUint8Array() === new Uint8Array([0x78, 0x56, 0x34, 0x12]));\n   * ```\n   */\n  @checkNumberRange(0, MAX_U32_NUMBER)\n  serializeU32(value: Uint32) {\n    this.serializeWithFunction(DataView.prototype.setUint32, 4, value);\n  }\n\n  /**\n   * Serializes a uint64 number.\n   *\n   * BCS layout for \"uint64\": Eight bytes. Binary format in little-endian representation.\n   * @example\n   * ```ts\n   * const serializer = new Serializer();\n   * serializer.serializeU64(1311768467750121216);\n   * assert(serializer.toUint8Array() === new Uint8Array([0x00, 0xEF, 0xCD, 0xAB, 0x78, 0x56, 0x34, 0x12]));\n   * ```\n   */\n  @checkNumberRange(BigInt(0), MAX_U64_BIG_INT)\n  serializeU64(value: AnyNumber) {\n    const low = BigInt(value) & BigInt(MAX_U32_NUMBER);\n    const high = BigInt(value) >> BigInt(32);\n\n    // write little endian number\n    this.serializeU32(Number(low));\n    this.serializeU32(Number(high));\n  }\n\n  /**\n   * Serializes a uint128 number.\n   *\n   * BCS layout for \"uint128\": Sixteen bytes. Binary format in little-endian representation.\n   */\n  @checkNumberRange(BigInt(0), MAX_U128_BIG_INT)\n  serializeU128(value: AnyNumber) {\n    const low = BigInt(value) & MAX_U64_BIG_INT;\n    const high = BigInt(value) >> BigInt(64);\n\n    // write little endian number\n    this.serializeU64(low);\n    this.serializeU64(high);\n  }\n\n  /**\n   * Serializes a uint256 number.\n   *\n   * BCS layout for \"uint256\": Sixteen bytes. Binary format in little-endian representation.\n   */\n  @checkNumberRange(BigInt(0), MAX_U256_BIG_INT)\n  serializeU256(value: AnyNumber) {\n    const low = BigInt(value) & MAX_U128_BIG_INT;\n    const high = BigInt(value) >> BigInt(128);\n\n    // write little endian number\n    this.serializeU128(low);\n    this.serializeU128(high);\n  }\n\n  /**\n   * Serializes a uint32 number with uleb128.\n   *\n   * BCS uses uleb128 encoding in two cases: (1) lengths of variable-length sequences and (2) tags of enum values\n   */\n  @checkNumberRange(0, MAX_U32_NUMBER)\n  serializeU32AsUleb128(val: Uint32) {\n    let value = val;\n    const valueArray = [];\n    while (value >>> 7 !== 0) {\n      valueArray.push((value & 0x7f) | 0x80);\n      value >>>= 7;\n    }\n    valueArray.push(value);\n    this.appendToBuffer(new Uint8Array(valueArray));\n  }\n\n  /**\n   * Returns the buffered bytes\n   */\n  toUint8Array(): Uint8Array {\n    return new Uint8Array(this.buffer).slice(0, this.offset);\n  }\n\n  /**\n   * Serializes a `Serializable` value, facilitating composable serialization.\n   *\n   * @param value The Serializable value to serialize\n   *\n   * @example\n   * // Define the MoveStruct class that implements the Serializable interface\n   * class MoveStruct extends Serializable {\n   *     constructor(\n   *         public creatorAddress: AccountAddress, // where AccountAddress extends Serializable\n   *         public collectionName: string,\n   *         public tokenName: string\n   *     ) {}\n   *\n   *     serialize(serializer: Serializer): void {\n   *         serializer.serialize(this.creatorAddress);  // Composable serialization of another Serializable object\n   *         serializer.serializeStr(this.collectionName);\n   *         serializer.serializeStr(this.tokenName);\n   *     }\n   * }\n   *\n   * // Construct a MoveStruct\n   * const moveStruct = new MoveStruct(new AccountAddress(...), \"MyCollection\", \"TokenA\");\n   *\n   * // Serialize a string, a u64 number, and a MoveStruct instance.\n   * const serializer = new Serializer();\n   * serializer.serializeStr(\"ExampleString\");\n   * serializer.serializeU64(12345678);\n   * serializer.serialize(moveStruct);\n   *\n   * // Get the bytes from the Serializer instance\n   * const serializedBytes = serializer.toUint8Array();\n   *\n   * @returns the serializer instance\n   */\n  serialize<T extends Serializable>(value: T): void {\n    // NOTE: The `serialize` method called by `value` is defined in `value`'s\n    // Serializable interface, not the one defined in this class.\n    value.serialize(this);\n  }\n\n  /**\n   * Serializes an array of BCS Serializable values to a serializer instance.\n   * Note that this does not return anything. The bytes are added to the serializer instance's byte buffer.\n   *\n   * @param values The array of BCS Serializable values\n   * @example\n   * const addresses = new Array<AccountAddress>(\n   *   AccountAddress.fromHexInputRelaxed(\"0x1\"),\n   *   AccountAddress.fromHexInputRelaxed(\"0x2\"),\n   *   AccountAddress.fromHexInputRelaxed(\"0xa\"),\n   *   AccountAddress.fromHexInputRelaxed(\"0xb\"),\n   * );\n   * const serializer = new Serializer();\n   * serializer.serializeVector(addresses);\n   * const serializedBytes = serializer.toUint8Array();\n   * // serializedBytes is now the BCS-serialized bytes\n   * // The equivalent value in Move would be:\n   * // `bcs::to_bytes(&vector<address> [@0x1, @0x2, @0xa, @0xb])`;\n   */\n  serializeVector<T extends Serializable>(values: Array<T>): void {\n    this.serializeU32AsUleb128(values.length);\n    values.forEach((item) => {\n      item.serialize(this);\n    });\n  }\n}\n\nexport function ensureBoolean(value: unknown): asserts value is boolean {\n  if (typeof value !== \"boolean\") {\n    throw new Error(`${value} is not a boolean value`);\n  }\n}\n\nexport const outOfRangeErrorMessage = (value: AnyNumber, min: AnyNumber, max: AnyNumber) =>\n  `${value} is out of range: [${min}, ${max}]`;\n\nexport function validateNumberInRange<T extends AnyNumber>(value: T, minValue: T, maxValue: T) {\n  const valueBigInt = BigInt(value);\n  if (valueBigInt > BigInt(maxValue) || valueBigInt < BigInt(minValue)) {\n    throw new Error(outOfRangeErrorMessage(value, minValue, maxValue));\n  }\n}\n\n/**\n * A decorator to ensure the input argument for a function is within a range.\n * @param minValue The input argument must be >= minValue\n * @param maxValue The input argument must be <= maxValue\n */\nfunction checkNumberRange<T extends AnyNumber>(minValue: T, maxValue: T) {\n  return (target: unknown, propertyKey: string, descriptor: PropertyDescriptor) => {\n    const childFunction = descriptor.value;\n    // eslint-disable-next-line no-param-reassign\n    descriptor.value = function deco(value: AnyNumber) {\n      validateNumberInRange(value, minValue, maxValue);\n      return childFunction.apply(this, [value]);\n    };\n\n    return descriptor;\n  };\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { sha3_256 as sha3Hash } from \"@noble/hashes/sha3\";\nimport { AccountAddress } from \"./accountAddress\";\nimport { PublicKey } from \"./crypto/asymmetricCrypto\";\nimport { Ed25519PublicKey } from \"./crypto/ed25519\";\nimport { MultiEd25519PublicKey } from \"./crypto/multiEd25519\";\nimport { Hex } from \"./hex\";\nimport { AuthenticationKeyScheme, HexInput, SigningScheme } from \"../types\";\nimport { AnyPublicKey } from \"./crypto/anyPublicKey\";\nimport { MultiKey } from \"./crypto/multiKey\";\nimport { Serializable, Serializer } from \"../bcs/serializer\";\nimport { Deserializer } from \"../bcs/deserializer\";\n\n/**\n * Each account stores an authentication key. Authentication key enables account owners to rotate\n * their private key(s) associated with the account without changing the address that hosts their account.\n * @see {@link https://aptos.dev/concepts/accounts | Account Basics}\n *\n * Note: AuthenticationKey only supports Ed25519 and MultiEd25519 public keys for now.\n *\n * Account addresses can be derived from AuthenticationKey\n */\nexport class AuthenticationKey extends Serializable {\n  /**\n   * An authentication key is always a SHA3-256 hash of data, and is always 32 bytes.\n   */\n  static readonly LENGTH: number = 32;\n\n  /**\n   * The raw bytes of the authentication key.\n   */\n  public readonly data: Hex;\n\n  constructor(args: { data: HexInput }) {\n    super();\n    const { data } = args;\n    const hex = Hex.fromHexInput(data);\n    if (hex.toUint8Array().length !== AuthenticationKey.LENGTH) {\n      throw new Error(`Authentication Key length should be ${AuthenticationKey.LENGTH}`);\n    }\n    this.data = hex;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeFixedBytes(this.data.toUint8Array());\n  }\n\n  /**\n   * Deserialize an AuthenticationKey from the byte buffer in a Deserializer instance.\n   * @param deserializer The deserializer to deserialize the AuthenticationKey from.\n   * @returns An instance of AuthenticationKey.\n   */\n  static deserialize(deserializer: Deserializer): AuthenticationKey {\n    const bytes = deserializer.deserializeFixedBytes(AuthenticationKey.LENGTH);\n    return new AuthenticationKey({ data: bytes });\n  }\n\n  toString(): string {\n    return this.data.toString();\n  }\n\n  toUint8Array(): Uint8Array {\n    return this.data.toUint8Array();\n  }\n\n  /**\n   * Creates an AuthenticationKey from seed bytes and a scheme\n   *\n   * This allows for the creation of AuthenticationKeys that are not derived from Public Keys directly\n   * @param args\n   */\n  public static fromPublicKeyAndScheme(args: { publicKey: PublicKey; scheme: AuthenticationKeyScheme }) {\n    const { publicKey, scheme } = args;\n    let authKeyBytes: Uint8Array;\n\n    switch (scheme) {\n      case SigningScheme.MultiKey:\n      case SigningScheme.SingleKey: {\n        const singleKeyBytes = publicKey.bcsToBytes();\n        authKeyBytes = new Uint8Array([...singleKeyBytes, scheme]);\n        break;\n      }\n\n      case SigningScheme.Ed25519:\n      case SigningScheme.MultiEd25519: {\n        const ed25519PublicKeyBytes = publicKey.toUint8Array();\n        const inputBytes = Hex.fromHexInput(ed25519PublicKeyBytes).toUint8Array();\n        authKeyBytes = new Uint8Array([...inputBytes, scheme]);\n        break;\n      }\n\n      default:\n        throw new Error(`Scheme ${scheme} is not supported`);\n    }\n\n    const hash = sha3Hash.create();\n    hash.update(authKeyBytes);\n    const hashDigest = hash.digest();\n    return new AuthenticationKey({ data: hashDigest });\n  }\n\n  /**\n   * Converts a PublicKey(s) to AuthenticationKey\n   *\n   * @param args.publicKey\n   * @returns AuthenticationKey\n   */\n  static fromPublicKey(args: { publicKey: PublicKey }): AuthenticationKey {\n    const { publicKey } = args;\n\n    let scheme: number;\n    if (publicKey instanceof Ed25519PublicKey) {\n      // for legacy support\n      scheme = SigningScheme.Ed25519.valueOf();\n    } else if (publicKey instanceof MultiEd25519PublicKey) {\n      // for legacy support\n      scheme = SigningScheme.MultiEd25519.valueOf();\n    } else if (publicKey instanceof AnyPublicKey) {\n      scheme = SigningScheme.SingleKey.valueOf();\n    } else if (publicKey instanceof MultiKey) {\n      scheme = SigningScheme.MultiKey.valueOf();\n    } else {\n      throw new Error(\"No supported authentication scheme for public key\");\n    }\n\n    return AuthenticationKey.fromPublicKeyAndScheme({ publicKey, scheme });\n  }\n\n  /**\n   * Derives an account address from AuthenticationKey. Since current AccountAddress is 32 bytes,\n   * AuthenticationKey bytes are directly translated to AccountAddress.\n   *\n   * @returns AccountAddress\n   */\n  derivedAddress(): AccountAddress {\n    return new AccountAddress({ data: this.data.toUint8Array() });\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport nacl from \"tweetnacl\";\nimport { PublicKey, PrivateKey, Signature } from \"./asymmetricCrypto\";\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializer } from \"../../bcs/serializer\";\nimport { Hex } from \"../hex\";\nimport { HexInput } from \"../../types\";\n\n/**\n * Represents the public key of an Ed25519 key pair.\n *\n * Since [AIP-55](https://github.com/aptos-foundation/AIPs/pull/263) Aptos supports\n * `Legacy` and `Unified` authentication keys.\n *\n * Ed25519 scheme is represented in the SDK as `Legacy authentication key` and also\n * as `AnyPublicKey` that represents any `Unified authentication key`\n */\nexport class Ed25519PublicKey extends PublicKey {\n  /**\n   * Length of an Ed25519 public key\n   */\n  static readonly LENGTH: number = 32;\n\n  /**\n   * Bytes of the public key\n   * @private\n   */\n  private readonly key: Hex;\n\n  /**\n   * Create a new PublicKey instance from a Uint8Array or String.\n   *\n   * @param hexInput A HexInput (string or Uint8Array)\n   */\n  constructor(hexInput: HexInput) {\n    super();\n\n    const hex = Hex.fromHexInput(hexInput);\n    if (hex.toUint8Array().length !== Ed25519PublicKey.LENGTH) {\n      throw new Error(`PublicKey length should be ${Ed25519PublicKey.LENGTH}`);\n    }\n    this.key = hex;\n  }\n\n  /**\n   * Get the public key in bytes (Uint8Array).\n   *\n   * @returns Uint8Array representation of the public key\n   */\n  toUint8Array(): Uint8Array {\n    return this.key.toUint8Array();\n  }\n\n  /**\n   * Get the public key as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the public key\n   */\n  toString(): string {\n    return this.key.toString();\n  }\n\n  /**\n   * Verifies a signed data with a public key\n   * @param args.message a signed message\n   * @param args.signature the signature of the message\n   */\n  verifySignature(args: { message: HexInput; signature: Ed25519Signature }): boolean {\n    const { message, signature } = args;\n    const rawMessage = Hex.fromHexInput(message).toUint8Array();\n    const rawSignature = Hex.fromHexInput(signature.toUint8Array()).toUint8Array();\n    return nacl.sign.detached.verify(rawMessage, rawSignature, this.key.toUint8Array());\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.key.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): Ed25519PublicKey {\n    const bytes = deserializer.deserializeBytes();\n    return new Ed25519PublicKey(bytes);\n  }\n\n  static load(deserializer: Deserializer): Ed25519PublicKey {\n    const bytes = deserializer.deserializeBytes();\n    return new Ed25519PublicKey(bytes);\n  }\n}\n\n/**\n * Represents the private key of an Ed25519 key pair.\n */\nexport class Ed25519PrivateKey extends PrivateKey {\n  /**\n   * Length of an Ed25519 private key\n   */\n  static readonly LENGTH: number = 32;\n\n  /**\n   * The Ed25519 signing key\n   * @private\n   */\n  private readonly signingKeyPair: nacl.SignKeyPair;\n\n  /**\n   * Create a new PrivateKey instance from a Uint8Array or String.\n   *\n   * @param hexInput HexInput (string or Uint8Array)\n   */\n  constructor(hexInput: HexInput) {\n    super();\n\n    const privateKeyHex = Hex.fromHexInput(hexInput);\n    if (privateKeyHex.toUint8Array().length !== Ed25519PrivateKey.LENGTH) {\n      throw new Error(`PrivateKey length should be ${Ed25519PrivateKey.LENGTH}`);\n    }\n\n    // Create keyPair from Private key in Uint8Array format\n    this.signingKeyPair = nacl.sign.keyPair.fromSeed(privateKeyHex.toUint8Array().slice(0, Ed25519PrivateKey.LENGTH));\n  }\n\n  /**\n   * Get the private key in bytes (Uint8Array).\n   *\n   * @returns Uint8Array representation of the private key\n   */\n  toUint8Array(): Uint8Array {\n    return this.signingKeyPair.secretKey.slice(0, Ed25519PrivateKey.LENGTH);\n  }\n\n  /**\n   * Get the private key as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the private key\n   */\n  toString(): string {\n    return Hex.fromHexInput(this.toUint8Array()).toString();\n  }\n\n  /**\n   * Sign the given message with the private key.\n   *\n   * @param message in HexInput format\n   * @returns Signature\n   */\n  sign(message: HexInput): Ed25519Signature {\n    const hex = Hex.fromHexInput(message);\n    const signature = nacl.sign.detached(hex.toUint8Array(), this.signingKeyPair.secretKey);\n    return new Ed25519Signature(signature);\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): Ed25519PrivateKey {\n    const bytes = deserializer.deserializeBytes();\n    return new Ed25519PrivateKey(bytes);\n  }\n\n  /**\n   * Generate a new random private key.\n   *\n   * @returns Ed25519PrivateKey\n   */\n  static generate(): Ed25519PrivateKey {\n    const keyPair = nacl.sign.keyPair();\n    return new Ed25519PrivateKey(keyPair.secretKey.slice(0, Ed25519PrivateKey.LENGTH));\n  }\n\n  /**\n   * Derive the Ed25519PublicKey for this private key.\n   *\n   * @returns Ed25519PublicKey\n   */\n  publicKey(): Ed25519PublicKey {\n    const bytes = this.signingKeyPair.publicKey;\n    return new Ed25519PublicKey(bytes);\n  }\n}\n\n/**\n * A signature of a message signed using an Ed25519 private key\n */\nexport class Ed25519Signature extends Signature {\n  /**\n   * Length of an Ed25519 signature\n   */\n  static readonly LENGTH = 64;\n\n  /**\n   * The signature bytes\n   * @private\n   */\n  private readonly data: Hex;\n\n  constructor(hexInput: HexInput) {\n    super();\n    const hex = Hex.fromHexInput(hexInput);\n    if (hex.toUint8Array().length !== Ed25519Signature.LENGTH) {\n      throw new Error(`Signature length should be ${Ed25519Signature.LENGTH}`);\n    }\n\n    this.data = hex;\n  }\n\n  /**\n   * Get the signature in bytes (Uint8Array).\n   *\n   * @returns Uint8Array representation of the signature\n   */\n  toUint8Array(): Uint8Array {\n    return this.data.toUint8Array();\n  }\n\n  /**\n   * Get the signature as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the signature\n   */\n  toString(): string {\n    return this.data.toString();\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.data.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): Ed25519Signature {\n    const bytes = deserializer.deserializeBytes();\n    return new Ed25519Signature(bytes);\n  }\n\n  static load(deserializer: Deserializer): Ed25519Signature {\n    const bytes = deserializer.deserializeBytes();\n    return new Ed25519Signature(bytes);\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable no-bitwise */\nimport { MAX_U32_NUMBER } from \"./consts\";\nimport { Uint8, Uint16, Uint32, Uint64, Uint128, Uint256 } from \"../types\";\n\n/**\n * This interface exists to define Deserializable<T> inputs for functions that\n * deserialize a byte buffer into a type T.\n * It is not intended to be implemented or extended, because Typescript has no support\n * for static methods in interfaces.\n */\nexport interface Deserializable<T> {\n  deserialize(deserializer: Deserializer): T;\n}\n\nexport class Deserializer {\n  private buffer: ArrayBuffer;\n\n  private offset: number;\n\n  constructor(data: Uint8Array) {\n    // copies data to prevent outside mutation of buffer.\n    this.buffer = new ArrayBuffer(data.length);\n    new Uint8Array(this.buffer).set(data, 0);\n    this.offset = 0;\n  }\n\n  private read(length: number): ArrayBuffer {\n    if (this.offset + length > this.buffer.byteLength) {\n      throw new Error(\"Reached to the end of buffer\");\n    }\n\n    const bytes = this.buffer.slice(this.offset, this.offset + length);\n    this.offset += length;\n    return bytes;\n  }\n\n  /**\n   * Deserializes a string. UTF8 string is supported. Reads the string's bytes length \"l\" first,\n   * and then reads \"l\" bytes of content. Decodes the byte array into a string.\n   *\n   * BCS layout for \"string\": string_length | string_content\n   * where string_length is a u32 integer encoded as a uleb128 integer, equal to the number of bytes in string_content.\n   *\n   * @example\n   * ```ts\n   * const deserializer = new Deserializer(new Uint8Array([8, 49, 50, 51, 52, 97, 98, 99, 100]));\n   * assert(deserializer.deserializeStr() === \"1234abcd\");\n   * ```\n   */\n  deserializeStr(): string {\n    const value = this.deserializeBytes();\n    const textDecoder = new TextDecoder();\n    return textDecoder.decode(value);\n  }\n\n  /**\n   * Deserializes an array of bytes.\n   *\n   * BCS layout for \"bytes\": bytes_length | bytes\n   * where bytes_length is a u32 integer encoded as a uleb128 integer, equal to the length of the bytes array.\n   */\n  deserializeBytes(): Uint8Array {\n    const len = this.deserializeUleb128AsU32();\n    return new Uint8Array(this.read(len));\n  }\n\n  /**\n   * Deserializes an array of bytes. The number of bytes to read is already known.\n   *\n   */\n  deserializeFixedBytes(len: number): Uint8Array {\n    return new Uint8Array(this.read(len));\n  }\n\n  /**\n   * Deserializes a boolean value.\n   *\n   * BCS layout for \"boolean\": One byte. \"0x01\" for true and \"0x00\" for false.\n   */\n  deserializeBool(): boolean {\n    const bool = new Uint8Array(this.read(1))[0];\n    if (bool !== 1 && bool !== 0) {\n      throw new Error(\"Invalid boolean value\");\n    }\n    return bool === 1;\n  }\n\n  /**\n   * Deserializes a uint8 number.\n   *\n   * BCS layout for \"uint8\": One byte. Binary format in little-endian representation.\n   */\n  deserializeU8(): Uint8 {\n    return new DataView(this.read(1)).getUint8(0);\n  }\n\n  /**\n   * Deserializes a uint16 number.\n   *\n   * BCS layout for \"uint16\": Two bytes. Binary format in little-endian representation.\n   * @example\n   * ```ts\n   * const deserializer = new Deserializer(new Uint8Array([0x34, 0x12]));\n   * assert(deserializer.deserializeU16() === 4660);\n   * ```\n   */\n  deserializeU16(): Uint16 {\n    return new DataView(this.read(2)).getUint16(0, true);\n  }\n\n  /**\n   * Deserializes a uint32 number.\n   *\n   * BCS layout for \"uint32\": Four bytes. Binary format in little-endian representation.\n   * @example\n   * ```ts\n   * const deserializer = new Deserializer(new Uint8Array([0x78, 0x56, 0x34, 0x12]));\n   * assert(deserializer.deserializeU32() === 305419896);\n   * ```\n   */\n  deserializeU32(): Uint32 {\n    return new DataView(this.read(4)).getUint32(0, true);\n  }\n\n  /**\n   * Deserializes a uint64 number.\n   *\n   * BCS layout for \"uint64\": Eight bytes. Binary format in little-endian representation.\n   * @example\n   * ```ts\n   * const deserializer = new Deserializer(new Uint8Array([0x00, 0xEF, 0xCD, 0xAB, 0x78, 0x56, 0x34, 0x12]));\n   * assert(deserializer.deserializeU64() === 1311768467750121216);\n   * ```\n   */\n  deserializeU64(): Uint64 {\n    const low = this.deserializeU32();\n    const high = this.deserializeU32();\n\n    // combine the two 32-bit values and return (little endian)\n    return BigInt((BigInt(high) << BigInt(32)) | BigInt(low));\n  }\n\n  /**\n   * Deserializes a uint128 number.\n   *\n   * BCS layout for \"uint128\": Sixteen bytes. Binary format in little-endian representation.\n   */\n  deserializeU128(): Uint128 {\n    const low = this.deserializeU64();\n    const high = this.deserializeU64();\n\n    // combine the two 64-bit values and return (little endian)\n    return BigInt((high << BigInt(64)) | low);\n  }\n\n  /**\n   * Deserializes a uint256 number.\n   *\n   * BCS layout for \"uint256\": Thirty-two bytes. Binary format in little-endian representation.\n   */\n  deserializeU256(): Uint256 {\n    const low = this.deserializeU128();\n    const high = this.deserializeU128();\n\n    // combine the two 128-bit values and return (little endian)\n    return BigInt((high << BigInt(128)) | low);\n  }\n\n  /**\n   * Deserializes a uleb128 encoded uint32 number.\n   *\n   * BCS use uleb128 encoding in two cases: (1) lengths of variable-length sequences and (2) tags of enum values\n   */\n  deserializeUleb128AsU32(): Uint32 {\n    let value: bigint = BigInt(0);\n    let shift = 0;\n\n    while (value < MAX_U32_NUMBER) {\n      const byte = this.deserializeU8();\n      value |= BigInt(byte & 0x7f) << BigInt(shift);\n\n      if ((byte & 0x80) === 0) {\n        break;\n      }\n      shift += 7;\n    }\n\n    if (value > MAX_U32_NUMBER) {\n      throw new Error(\"Overflow while parsing uleb128-encoded uint32 value\");\n    }\n\n    return Number(value);\n  }\n\n  /**\n   * Helper function that primarily exists to support alternative syntax for deserialization.\n   * That is, if we have a `const deserializer: new Deserializer(...)`, instead of having to use\n   * `MyClass.deserialize(deserializer)`, we can call `deserializer.deserialize(MyClass)`.\n   *\n   * @example const deserializer = new Deserializer(new Uint8Array([1, 2, 3]));\n   * const value = deserializer.deserialize(MyClass); // where MyClass has a `deserialize` function\n   * // value is now an instance of MyClass\n   * // equivalent to `const value = MyClass.deserialize(deserializer)`\n   * @param cls The BCS-deserializable class to deserialize the buffered bytes into.\n   *\n   * @returns the deserialized value of class type T\n   */\n  deserialize<T>(cls: Deserializable<T>): T {\n    // NOTE: `deserialize` in `cls.deserialize(this)` here is a static method defined in `cls`,\n    // It is separate from the `deserialize` instance method defined here in Deserializer.\n    return cls.deserialize(this);\n  }\n\n  /**\n   * Deserializes an array of BCS Deserializable values given an existing Deserializer\n   * instance with a loaded byte buffer.\n   *\n   * @param cls The BCS-deserializable class to deserialize the buffered bytes into.\n   * @example\n   * // serialize a vector of addresses\n   * const addresses = new Array<AccountAddress>(\n   *   AccountAddress.fromHexInputRelaxed(\"0x1\"),\n   *   AccountAddress.fromHexInputRelaxed(\"0x2\"),\n   *   AccountAddress.fromHexInputRelaxed(\"0xa\"),\n   *   AccountAddress.fromHexInputRelaxed(\"0xb\"),\n   * );\n   * const serializer = new Serializer();\n   * serializer.serializeVector(addresses);\n   * const serializedBytes = serializer.toUint8Array();\n   *\n   * // deserialize the bytes into an array of addresses\n   * const deserializer = new Deserializer(serializedBytes);\n   * const deserializedAddresses = deserializer.deserializeVector(AccountAddress);\n   * // deserializedAddresses is now an array of AccountAddress instances\n   * @returns an array of deserialized values of type T\n   */\n  deserializeVector<T>(cls: Deserializable<T>): Array<T> {\n    const length = this.deserializeUleb128AsU32();\n    const vector = new Array<T>();\n    for (let i = 0; i < length; i += 1) {\n      vector.push(this.deserialize(cls));\n    }\n    return vector;\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Serializer, Serializable } from \"../serializer\";\nimport { Deserializer } from \"../deserializer\";\nimport { HexInput } from \"../../types\";\nimport { Hex } from \"../../core/hex\";\nimport { TransactionArgument } from \"../../transactions/instances/transactionArgument\";\n\n/**\n *  This class exists to represent a contiguous sequence of already serialized BCS-bytes.\n *\n *  It differs from most other Serializable classes in that its internal byte buffer is serialized to BCS\n *  bytes exactly as-is, without prepending the length of the bytes.\n *\n *  If you want to write your own serialization function and pass the bytes as a transaction argument,\n *  you should use this class.\n *\n *  This class is also more generally used to represent type-agnostic BCS bytes as a vector<u8>.\n *\n *  An example of this is the bytes resulting from entry function arguments that have been serialized\n *  for an entry function.\n *\n *  @example\n *  const yourCustomSerializedBytes = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]);\n *  const fixedBytes = new FixedBytes(yourCustomSerializedBytes);\n *  const payload = await generateTransactionPayload({\n *    function: \"0xbeefcafe::your_module::your_function_that_requires_custom_serialization\",\n *    functionArguments: [yourCustomBytes],\n *  });\n *\n *  For example, if you store each of the 32 bytes for an address as a U8 in a MoveVector<U8>, when you\n *  serialize that MoveVector<U8>, it will be serialized to 33 bytes. If you solely want to pass around\n *  the 32 bytes as a Serializable class that *does not* prepend the length to the BCS-serialized representation,\n *  use this class.\n *\n * @params value: HexInput representing a sequence of Uint8 bytes\n * @returns a Serializable FixedBytes instance, which when serialized, does not prepend the length of the bytes\n * @see EntryFunctionBytes\n */\nexport class FixedBytes extends Serializable implements TransactionArgument {\n  public value: Uint8Array;\n\n  constructor(value: HexInput) {\n    super();\n    this.value = Hex.fromHexInput(value).toUint8Array();\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeFixedBytes(this.value);\n  }\n\n  serializeForEntryFunction(serializer: Serializer): void {\n    serializer.serialize(this);\n  }\n\n  serializeForScriptFunction(serializer: Serializer): void {\n    serializer.serialize(this);\n  }\n\n  static deserialize(deserializer: Deserializer, length: number): FixedBytes {\n    const bytes = deserializer.deserializeFixedBytes(length);\n    return new FixedBytes(bytes);\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Serializer, Serializable } from \"../serializer\";\nimport { Deserializer } from \"../deserializer\";\nimport { FixedBytes } from \"./fixedBytes\";\nimport { EntryFunctionArgument } from \"../../transactions/instances/transactionArgument\";\nimport { HexInput } from \"../../types\";\n\n/**\n * This class exists solely to represent a sequence of fixed bytes as a serialized entry function, because\n * serializing an entry function appends a prefix that's *only* used for entry function arguments.\n *\n * NOTE: Attempting to use this class for a serialized script function will result in erroneous\n * and unexpected behavior.\n *\n * If you wish to convert this class back to a TransactionArgument, you must know the type\n * of the argument beforehand, and use the appropriate class to deserialize the bytes within\n * an instance of this class.\n */\nexport class EntryFunctionBytes extends Serializable implements EntryFunctionArgument {\n  public readonly value: FixedBytes;\n\n  private constructor(value: HexInput) {\n    super();\n    this.value = new FixedBytes(value);\n  }\n\n  // Note that to see the Move, BCS-serialized representation of the underlying fixed byte vector,\n  // we must not serialize the length prefix.\n  //\n  // In other words, this class is only used to represent a sequence of bytes that are already\n  // BCS-serialized as a type. To represent those bytes accurately, the BCS-serialized form is the same exact\n  // representation.\n  serialize(serializer: Serializer): void {\n    serializer.serialize(this.value);\n  }\n\n  // When we serialize these bytes as an entry function argument, we need to\n  // serialize the length prefix. This essentially converts the underlying fixed byte vector to a type-agnostic\n  // byte vector to an `any` type.\n  // NOTE: This, and the lack of a `serializeForScriptFunction`, is the only meaningful difference between this\n  // class and FixedBytes.\n  serializeForEntryFunction(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(this.value.value.length);\n    serializer.serialize(this);\n  }\n\n  /**\n   * The only way to create an instance of this class is to use this static method.\n   *\n   * This function should only be used when deserializing a sequence of EntryFunctionPayload arguments.\n   * @param deserializer the deserializer instance with the buffered bytes\n   * @param length the length of the bytes to deserialize\n   * @returns an instance of this class, which will now only be usable as an EntryFunctionArgument\n   */\n  static deserialize(deserializer: Deserializer, length: number): EntryFunctionBytes {\n    const fixedBytes = FixedBytes.deserialize(deserializer, length);\n    return new EntryFunctionBytes(fixedBytes.value);\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  MAX_U128_BIG_INT,\n  MAX_U16_NUMBER,\n  MAX_U32_NUMBER,\n  MAX_U64_BIG_INT,\n  MAX_U8_NUMBER,\n  MAX_U256_BIG_INT,\n} from \"../consts\";\nimport { Deserializer } from \"../deserializer\";\nimport { Serializable, Serializer, ensureBoolean, validateNumberInRange } from \"../serializer\";\nimport { TransactionArgument } from \"../../transactions/instances/transactionArgument\";\nimport { AnyNumber, Uint16, Uint32, Uint8, ScriptTransactionArgumentVariants } from \"../../types\";\n\nexport class Bool extends Serializable implements TransactionArgument {\n  public readonly value: boolean;\n\n  constructor(value: boolean) {\n    super();\n    ensureBoolean(value);\n    this.value = value;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBool(this.value);\n  }\n\n  serializeForEntryFunction(serializer: Serializer): void {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n\n  serializeForScriptFunction(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(ScriptTransactionArgumentVariants.Bool);\n    serializer.serialize(this);\n  }\n\n  static deserialize(deserializer: Deserializer): Bool {\n    return new Bool(deserializer.deserializeBool());\n  }\n}\n\nexport class U8 extends Serializable implements TransactionArgument {\n  public readonly value: Uint8;\n\n  constructor(value: Uint8) {\n    super();\n    validateNumberInRange(value, 0, MAX_U8_NUMBER);\n    this.value = value;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU8(this.value);\n  }\n\n  serializeForEntryFunction(serializer: Serializer): void {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n\n  serializeForScriptFunction(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(ScriptTransactionArgumentVariants.U8);\n    serializer.serialize(this);\n  }\n\n  static deserialize(deserializer: Deserializer): U8 {\n    return new U8(deserializer.deserializeU8());\n  }\n}\n\nexport class U16 extends Serializable implements TransactionArgument {\n  public readonly value: Uint16;\n\n  constructor(value: Uint16) {\n    super();\n    validateNumberInRange(value, 0, MAX_U16_NUMBER);\n    this.value = value;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU16(this.value);\n  }\n\n  serializeForEntryFunction(serializer: Serializer): void {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n\n  serializeForScriptFunction(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(ScriptTransactionArgumentVariants.U16);\n    serializer.serialize(this);\n  }\n\n  static deserialize(deserializer: Deserializer): U16 {\n    return new U16(deserializer.deserializeU16());\n  }\n}\n\nexport class U32 extends Serializable implements TransactionArgument {\n  public readonly value: Uint32;\n\n  constructor(value: Uint32) {\n    super();\n    validateNumberInRange(value, 0, MAX_U32_NUMBER);\n    this.value = value;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32(this.value);\n  }\n\n  serializeForEntryFunction(serializer: Serializer): void {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n\n  serializeForScriptFunction(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(ScriptTransactionArgumentVariants.U32);\n    serializer.serialize(this);\n  }\n\n  static deserialize(deserializer: Deserializer): U32 {\n    return new U32(deserializer.deserializeU32());\n  }\n}\n\nexport class U64 extends Serializable implements TransactionArgument {\n  public readonly value: bigint;\n\n  constructor(value: AnyNumber) {\n    super();\n    validateNumberInRange(value, BigInt(0), MAX_U64_BIG_INT);\n    this.value = BigInt(value);\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU64(this.value);\n  }\n\n  serializeForEntryFunction(serializer: Serializer): void {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n\n  serializeForScriptFunction(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(ScriptTransactionArgumentVariants.U64);\n    serializer.serialize(this);\n  }\n\n  static deserialize(deserializer: Deserializer): U64 {\n    return new U64(deserializer.deserializeU64());\n  }\n}\n\nexport class U128 extends Serializable implements TransactionArgument {\n  public readonly value: bigint;\n\n  constructor(value: AnyNumber) {\n    super();\n    validateNumberInRange(value, BigInt(0), MAX_U128_BIG_INT);\n    this.value = BigInt(value);\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU128(this.value);\n  }\n\n  serializeForEntryFunction(serializer: Serializer): void {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n\n  serializeForScriptFunction(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(ScriptTransactionArgumentVariants.U128);\n    serializer.serialize(this);\n  }\n\n  static deserialize(deserializer: Deserializer): U128 {\n    return new U128(deserializer.deserializeU128());\n  }\n}\n\nexport class U256 extends Serializable implements TransactionArgument {\n  public readonly value: bigint;\n\n  constructor(value: AnyNumber) {\n    super();\n    validateNumberInRange(value, BigInt(0), MAX_U256_BIG_INT);\n    this.value = BigInt(value);\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU256(this.value);\n  }\n\n  serializeForEntryFunction(serializer: Serializer): void {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n\n  serializeForScriptFunction(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(ScriptTransactionArgumentVariants.U256);\n    serializer.serialize(this);\n  }\n\n  static deserialize(deserializer: Deserializer): U256 {\n    return new U256(deserializer.deserializeU256());\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Bool, U128, U16, U256, U32, U64, U8 } from \"./movePrimitives\";\nimport { Serializable, Serializer } from \"../serializer\";\nimport { Deserializable, Deserializer } from \"../deserializer\";\nimport { AnyNumber, HexInput, ScriptTransactionArgumentVariants } from \"../../types\";\nimport { Hex } from \"../../core/hex\";\nimport { EntryFunctionArgument, TransactionArgument } from \"../../transactions/instances/transactionArgument\";\n\n/**\n * This class is the Aptos Typescript SDK representation of a Move `vector<T>`,\n * where `T` represents either a primitive type (`bool`, `u8`, `u64`, ...)\n * or a BCS-serializable struct itself.\n *\n * It is a BCS-serializable, array-like type that contains an array of values of type `T`,\n * where `T` is a class that implements `Serializable`.\n *\n * The purpose of this class is to facilitate easy construction of BCS-serializable\n * Move `vector<T>` types.\n *\n * @example\n * // in Move: `vector<u8> [1, 2, 3, 4];`\n * const vecOfU8s = new MoveVector<U8>([new U8(1), new U8(2), new U8(3), new U8(4)]);\n * // in Move: `std::bcs::to_bytes(vector<u8> [1, 2, 3, 4]);`\n * const bcsBytes = vecOfU8s.toUint8Array();\n *\n * // vector<vector<u8>> [ vector<u8> [1], vector<u8> [1, 2, 3, 4], vector<u8> [5, 6, 7, 8] ];\n * const vecOfVecs = new MoveVector<MoveVector<U8>>([\n *   new MoveVector<U8>([new U8(1)]),\n *   MoveVector.U8([1, 2, 3, 4]),\n *   MoveVector.U8([5, 6, 7, 8]),\n * ]);\n *\n * // vector<Option<u8>> [ std::option::some<u8>(1), std::option::some<u8>(2) ];\n * const vecOfOptionU8s = new MoveVector<MoveOption<U8>>([\n *    MoveOption.U8(1),\n *    MoveOption.U8(2),\n * ]);\n *\n * // vector<MoveString> [ std::string::utf8(b\"hello\"), std::string::utf8(b\"world\") ];\n * const vecOfStrings = new MoveVector([new MoveString(\"hello\"), new MoveString(\"world\")]);\n * const vecOfStrings2 = MoveVector.MoveString([\"hello\", \"world\"]);\n *\n * // where MySerializableStruct is a class you've made that implements Serializable\n * const vecOfSerializableValues = new MoveVector<MySerializableStruct>([\n *   new MySerializableStruct(\"hello\", \"world\"),\n *   new MySerializableStruct(\"foo\", \"bar\"),\n * ]);\n * @params\n * values: an Array<T> of values where T is a class that implements Serializable\n * @returns a `MoveVector<T>` with the values `values`\n */\nexport class MoveVector<T extends Serializable & EntryFunctionArgument>\n  extends Serializable\n  implements TransactionArgument\n{\n  public values: Array<T>;\n\n  constructor(values: Array<T>) {\n    super();\n    this.values = values;\n  }\n\n  serializeForEntryFunction(serializer: Serializer): void {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n\n  /**\n   * NOTE: This function will only work when the inner values in the `MoveVector` are `U8`s.\n   * @param serializer\n   */\n  serializeForScriptFunction(serializer: Serializer): void {\n    // runtime check to ensure that you can't serialize anything other than vector<u8>\n    // TODO: consider adding support for MoveString later?\n    const isU8 = this.values[0] instanceof U8;\n    if (!isU8) {\n      throw new Error(\"Script function arguments only accept u8 vectors\");\n    }\n    serializer.serializeU32AsUleb128(ScriptTransactionArgumentVariants.U8Vector);\n    serializer.serialize(this);\n  }\n\n  /**\n   * Factory method to generate a MoveVector of U8s from an array of numbers.\n   *\n   * @example\n   * const v = MoveVector.U8([1, 2, 3, 4]);\n   * @params values: an array of `numbers` to convert to U8s\n   * @returns a `MoveVector<U8>`\n   */\n  static U8(values: Array<number> | HexInput): MoveVector<U8> {\n    let numbers: Array<number>;\n\n    if (Array.isArray(values) && typeof values[0] === \"number\") {\n      numbers = values;\n    } else if (typeof values === \"string\") {\n      const hex = Hex.fromHexInput(values);\n      numbers = Array.from(hex.toUint8Array());\n    } else if (values instanceof Uint8Array) {\n      numbers = Array.from(values);\n    } else {\n      throw new Error(\"Invalid input type\");\n    }\n\n    return new MoveVector<U8>(numbers.map((v) => new U8(v)));\n  }\n\n  /**\n   * Factory method to generate a MoveVector of U16s from an array of numbers.\n   *\n   * @example\n   * const v = MoveVector.U16([1, 2, 3, 4]);\n   * @params values: an array of `numbers` to convert to U16s\n   * @returns a `MoveVector<U16>`\n   */\n  static U16(values: Array<number>): MoveVector<U16> {\n    return new MoveVector<U16>(values.map((v) => new U16(v)));\n  }\n\n  /**\n   * Factory method to generate a MoveVector of U32s from an array of numbers.\n   *\n   * @example\n   * const v = MoveVector.U32([1, 2, 3, 4]);\n   * @params values: an array of `numbers` to convert to U32s\n   * @returns a `MoveVector<U32>`\n   */\n  static U32(values: Array<number>): MoveVector<U32> {\n    return new MoveVector<U32>(values.map((v) => new U32(v)));\n  }\n\n  /**\n   * Factory method to generate a MoveVector of U64s from an array of numbers or bigints.\n   *\n   * @example\n   * const v = MoveVector.U64([1, 2, 3, 4]);\n   * @params values: an array of numbers of type `number | bigint` to convert to U64s\n   * @returns a `MoveVector<U64>`\n   */\n  static U64(values: Array<AnyNumber>): MoveVector<U64> {\n    return new MoveVector<U64>(values.map((v) => new U64(v)));\n  }\n\n  /**\n   * Factory method to generate a MoveVector of U128s from an array of numbers or bigints.\n   *\n   * @example\n   * const v = MoveVector.U128([1, 2, 3, 4]);\n   * @params values: an array of numbers of type `number | bigint` to convert to U128s\n   * @returns a `MoveVector<U128>`\n   */\n  static U128(values: Array<AnyNumber>): MoveVector<U128> {\n    return new MoveVector<U128>(values.map((v) => new U128(v)));\n  }\n\n  /**\n   * Factory method to generate a MoveVector of U256s from an array of numbers or bigints.\n   *\n   * @example\n   * const v = MoveVector.U256([1, 2, 3, 4]);\n   * @params values: an array of numbers of type `number | bigint` to convert to U256s\n   * @returns a `MoveVector<U256>`\n   */\n  static U256(values: Array<AnyNumber>): MoveVector<U256> {\n    return new MoveVector<U256>(values.map((v) => new U256(v)));\n  }\n\n  /**\n   * Factory method to generate a MoveVector of Bools from an array of booleans.\n   *\n   * @example\n   * const v = MoveVector.Bool([true, false, true, false]);\n   * @params values: an array of `numbers` to convert to Bools\n   * @returns a `MoveVector<Bool>`\n   */\n  static Bool(values: Array<boolean>): MoveVector<Bool> {\n    return new MoveVector<Bool>(values.map((v) => new Bool(v)));\n  }\n\n  /**\n   * Factory method to generate a MoveVector of MoveStrings from an array of strings.\n   *\n   * @example\n   * const v = MoveVector.MoveString([\"hello\", \"world\"]);\n   * @params values: an array of `numbers` to convert to MoveStrings\n   * @returns a `MoveVector<MoveString>`\n   */\n  static MoveString(values: Array<string>): MoveVector<MoveString> {\n    return new MoveVector<MoveString>(values.map((v) => new MoveString(v)));\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeVector(this.values);\n  }\n\n  /**\n   * Deserialize a MoveVector of type T, specifically where T is a Serializable and Deserializable type.\n   *\n   * NOTE: This only works with a depth of one. Generics will not work.\n   *\n   * NOTE: This will not work with types that aren't of the Serializable class.\n   *\n   * If you want to use types that merely implement Deserializable,\n   * please use the deserializeVector function in the Deserializer class.\n   * @example\n   * const vec = MoveVector.deserialize(deserializer, U64);\n   * @params deserializer: the Deserializer instance to use, with bytes loaded into it already.\n   * cls: the class to typecast the input values to, must be a Serializable and Deserializable type.\n   * @returns a MoveVector of the corresponding class T\n   * *\n   */\n  static deserialize<T extends Serializable & EntryFunctionArgument>(\n    deserializer: Deserializer,\n    cls: Deserializable<T>,\n  ): MoveVector<T> {\n    const length = deserializer.deserializeUleb128AsU32();\n    const values = new Array<T>();\n    for (let i = 0; i < length; i += 1) {\n      values.push(cls.deserialize(deserializer));\n    }\n    return new MoveVector(values);\n  }\n}\n\nexport class MoveString extends Serializable implements TransactionArgument {\n  public value: string;\n\n  constructor(value: string) {\n    super();\n    this.value = value;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeStr(this.value);\n  }\n\n  serializeForEntryFunction(serializer: Serializer): void {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n\n  serializeForScriptFunction(serializer: Serializer): void {\n    // serialize the string, load it into a vector<u8> and serialize it as a script vector<u8> argument\n    const vectorU8 = MoveVector.U8(this.bcsToBytes());\n    vectorU8.serializeForScriptFunction(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): MoveString {\n    return new MoveString(deserializer.deserializeStr());\n  }\n}\n\nexport class MoveOption<T extends Serializable & EntryFunctionArgument>\n  extends Serializable\n  implements EntryFunctionArgument\n{\n  private vec: MoveVector<T>;\n\n  public readonly value?: T;\n\n  constructor(value?: T | null) {\n    super();\n    if (typeof value !== \"undefined\" && value !== null) {\n      this.vec = new MoveVector([value]);\n    } else {\n      this.vec = new MoveVector([]);\n    }\n\n    [this.value] = this.vec.values;\n  }\n\n  serializeForEntryFunction(serializer: Serializer): void {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n\n  /**\n   * Retrieves the inner value of the MoveOption.\n   *\n   * This method is inspired by Rust's `Option<T>.unwrap()`.\n   * In Rust, attempting to unwrap a `None` value results in a panic.\n   *\n   * Similarly, this method will throw an error if the value is not present.\n   *\n   * @example\n   * const option = new MoveOption<Bool>(new Bool(true));\n   * const value = option.unwrap();  // Returns the Bool instance\n   *\n   * @throws {Error} Throws an error if the MoveOption does not contain a value.\n   *\n   * @returns {T} The contained value if present.\n   */\n  unwrap(): T {\n    if (!this.isSome()) {\n      throw new Error(\"Called unwrap on a MoveOption with no value\");\n    } else {\n      return this.vec.values[0];\n    }\n  }\n\n  // Check if the MoveOption has a value.\n  isSome(): boolean {\n    return this.vec.values.length === 1;\n  }\n\n  serialize(serializer: Serializer): void {\n    // serialize 0 or 1\n    // if 1, serialize the value\n    this.vec.serialize(serializer);\n  }\n\n  /**\n   * Factory method to generate a MoveOption<U8> from a `number` or `undefined`.\n   *\n   * @example\n   * MoveOption.U8(1).isSome() === true;\n   * MoveOption.U8().isSome() === false;\n   * MoveOption.U8(undefined).isSome() === false;\n   * @params value: the value used to fill the MoveOption. If `value` is undefined\n   * the resulting MoveOption's .isSome() method will return false.\n   * @returns a MoveOption<U8> with an inner value `value`\n   */\n  static U8(value?: number | null): MoveOption<U8> {\n    return new MoveOption<U8>(value !== null && value !== undefined ? new U8(value) : undefined);\n  }\n\n  /**\n   * Factory method to generate a MoveOption<U16> from a `number` or `undefined`.\n   *\n   * @example\n   * MoveOption.U16(1).isSome() === true;\n   * MoveOption.U16().isSome() === false;\n   * MoveOption.U16(undefined).isSome() === false;\n   * @params value: the value used to fill the MoveOption. If `value` is undefined\n   * the resulting MoveOption's .isSome() method will return false.\n   * @returns a MoveOption<U16> with an inner value `value`\n   */\n  static U16(value?: number | null): MoveOption<U16> {\n    return new MoveOption<U16>(value !== null && value !== undefined ? new U16(value) : undefined);\n  }\n\n  /**\n   * Factory method to generate a MoveOption<U32> from a `number` or `undefined`.\n   *\n   * @example\n   * MoveOption.U32(1).isSome() === true;\n   * MoveOption.U32().isSome() === false;\n   * MoveOption.U32(undefined).isSome() === false;\n   * @params value: the value used to fill the MoveOption. If `value` is undefined\n   * the resulting MoveOption's .isSome() method will return false.\n   * @returns a MoveOption<U32> with an inner value `value`\n   */\n  static U32(value?: number | null): MoveOption<U32> {\n    return new MoveOption<U32>(value !== null && value !== undefined ? new U32(value) : undefined);\n  }\n\n  /**\n   * Factory method to generate a MoveOption<U64> from a `number` or a `bigint` or `undefined`.\n   *\n   * @example\n   * MoveOption.U64(1).isSome() === true;\n   * MoveOption.U64().isSome() === false;\n   * MoveOption.U64(undefined).isSome() === false;\n   * @params value: the value used to fill the MoveOption. If `value` is undefined\n   * the resulting MoveOption's .isSome() method will return false.\n   * @returns a MoveOption<U64> with an inner value `value`\n   */\n  static U64(value?: AnyNumber | null): MoveOption<U64> {\n    return new MoveOption<U64>(value !== null && value !== undefined ? new U64(value) : undefined);\n  }\n\n  /**\n   * Factory method to generate a MoveOption<U128> from a `number` or a `bigint` or `undefined`.\n   *\n   * @example\n   * MoveOption.U128(1).isSome() === true;\n   * MoveOption.U128().isSome() === false;\n   * MoveOption.U128(undefined).isSome() === false;\n   * @params value: the value used to fill the MoveOption. If `value` is undefined\n   * the resulting MoveOption's .isSome() method will return false.\n   * @returns a MoveOption<U128> with an inner value `value`\n   */\n  static U128(value?: AnyNumber | null): MoveOption<U128> {\n    return new MoveOption<U128>(value !== null && value !== undefined ? new U128(value) : undefined);\n  }\n\n  /**\n   * Factory method to generate a MoveOption<U256> from a `number` or a `bigint` or `undefined`.\n   *\n   * @example\n   * MoveOption.U256(1).isSome() === true;\n   * MoveOption.U256().isSome() === false;\n   * MoveOption.U256(undefined).isSome() === false;\n   * @params value: the value used to fill the MoveOption. If `value` is undefined\n   * the resulting MoveOption's .isSome() method will return false.\n   * @returns a MoveOption<U256> with an inner value `value`\n   */\n  static U256(value?: AnyNumber | null): MoveOption<U256> {\n    return new MoveOption<U256>(value !== null && value !== undefined ? new U256(value) : undefined);\n  }\n\n  /**\n   * Factory method to generate a MoveOption<Bool> from a `boolean` or `undefined`.\n   *\n   * @example\n   * MoveOption.Bool(true).isSome() === true;\n   * MoveOption.Bool().isSome() === false;\n   * MoveOption.Bool(undefined).isSome() === false;\n   * @params value: the value used to fill the MoveOption. If `value` is undefined\n   * the resulting MoveOption's .isSome() method will return false.\n   * @returns a MoveOption<Bool> with an inner value `value`\n   */\n  static Bool(value?: boolean | null): MoveOption<Bool> {\n    return new MoveOption<Bool>(value !== null && value !== undefined ? new Bool(value) : undefined);\n  }\n\n  /**\n   * Factory method to generate a MoveOption<MoveString> from a `string` or `undefined`.\n   *\n   * @example\n   * MoveOption.MoveString(\"hello\").isSome() === true;\n   * MoveOption.MoveString(\"\").isSome() === true;\n   * MoveOption.MoveString().isSome() === false;\n   * MoveOption.MoveString(undefined).isSome() === false;\n   * @params value: the value used to fill the MoveOption. If `value` is undefined\n   * the resulting MoveOption's .isSome() method will return false.\n   * @returns a MoveOption<MoveString> with an inner value `value`\n   */\n  static MoveString(value?: string | null): MoveOption<MoveString> {\n    return new MoveOption<MoveString>(value !== null && value !== undefined ? new MoveString(value) : undefined);\n  }\n\n  static deserialize<U extends Serializable & EntryFunctionArgument>(\n    deserializer: Deserializer,\n    cls: Deserializable<U>,\n  ): MoveOption<U> {\n    const vector = MoveVector.deserialize(deserializer, cls);\n    return new MoveOption(vector.values[0]);\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Serializable, Serializer } from \"../../bcs\";\nimport { HexInput } from \"../../types\";\n\n/**\n * An abstract representation of a public key.  All Asymmetric key pairs will use this to\n * verify signatures and for authentication keys.\n */\nexport abstract class PublicKey extends Serializable {\n  /**\n   * Verifies that the private key associated with this public key signed the message with the given signature.\n   * @param args.message The message that was signed\n   * @param args.signature The signature to verify\n   */\n  abstract verifySignature(args: { message: HexInput; signature: Signature }): boolean;\n\n  /**\n   * Get the raw public key bytes\n   */\n  abstract toUint8Array(): Uint8Array;\n\n  /**\n   * Get the public key as a hex string with a 0x prefix e.g. 0x123456...\n   */\n  abstract toString(): string;\n\n  abstract serialize(serializer: Serializer): void;\n}\n\n/**\n * An abstract representation of a private key.  This is used to sign transactions and\n * derive the public key associated.\n */\nexport abstract class PrivateKey extends Serializable {\n  /**\n   * Sign a message with the key\n   * @param message The message to sign\n   */\n  abstract sign(message: HexInput): Signature;\n\n  /**\n   * Get the raw private key bytes\n   */\n  abstract toUint8Array(): Uint8Array;\n\n  /**\n   * Get the private key as a hex string with a 0x prefix e.g. 0x123456...\n   */\n  abstract toString(): string;\n\n  abstract serialize(serializer: Serializer): void;\n\n  /**\n   * Derives the public key associated with the private key\n   */\n  abstract publicKey(): PublicKey;\n}\n\n/**\n * An abstract representation of a signature.  This is the product of signing a\n * message and can be used with the PublicKey to verify the signature.\n */\nexport abstract class Signature extends Serializable {\n  /**\n   * Get the raw signature bytes\n   */\n  abstract toUint8Array(): Uint8Array;\n\n  /**\n   * Get the signature as a hex string with a 0x prefix e.g. 0x123456...\n   */\n  abstract toString(): string;\n\n  abstract serialize(serializer: Serializer): void;\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { PublicKey, Signature } from \"./asymmetricCrypto\";\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializer } from \"../../bcs/serializer\";\nimport { Ed25519PublicKey, Ed25519Signature } from \"./ed25519\";\nimport { Hex } from \"../hex\";\nimport { HexInput } from \"../../types\";\n\n/**\n * Represents the public key of a K-of-N Ed25519 multi-sig transaction.\n */\nexport class MultiEd25519PublicKey extends PublicKey {\n  /**\n   * Maximum number of public keys supported\n   */\n  static readonly MAX_KEYS = 32;\n\n  /**\n   * Minimum number of public keys needed\n   */\n  static readonly MIN_KEYS = 2;\n\n  /**\n   * Minimum threshold for the number of valid signatures required\n   */\n  static readonly MIN_THRESHOLD = 1;\n\n  /**\n   * List of Ed25519 public keys for this MultiEd25519PublicKey\n   */\n  public readonly publicKeys: Ed25519PublicKey[];\n\n  /**\n   * The minimum number of valid signatures required, for the number of public keys specified\n   */\n  public readonly threshold: number;\n\n  /**\n   * Public key for a K-of-N multi-sig transaction. A K-of-N multi-sig transaction means that for such a\n   * transaction to be executed, at least K out of the N authorized signers have signed the transaction\n   * and passed the check conducted by the chain.\n   *\n   * @see {@link\n   * https://aptos.dev/integration/creating-a-signed-transaction/ | Creating a Signed Transaction}\n   *\n   * @param args.publicKeys A list of public keys\n   * @param args.threshold At least \"threshold\" signatures must be valid\n   */\n  constructor(args: { publicKeys: Ed25519PublicKey[]; threshold: number }) {\n    super();\n\n    const { publicKeys, threshold } = args;\n\n    // Validate number of public keys\n    if (publicKeys.length > MultiEd25519PublicKey.MAX_KEYS || publicKeys.length < MultiEd25519PublicKey.MIN_KEYS) {\n      throw new Error(\n        `Must have between ${MultiEd25519PublicKey.MIN_KEYS} and ${MultiEd25519PublicKey.MAX_KEYS} public keys, inclusive`,\n      );\n    }\n\n    // Validate threshold: must be between 1 and the number of public keys, inclusive\n    if (threshold < MultiEd25519PublicKey.MIN_THRESHOLD || threshold > publicKeys.length) {\n      throw new Error(\n        `Threshold must be between ${MultiEd25519PublicKey.MIN_THRESHOLD} and ${publicKeys.length}, inclusive`,\n      );\n    }\n\n    this.publicKeys = publicKeys;\n    this.threshold = threshold;\n  }\n\n  /**\n   * Converts a PublicKeys into Uint8Array (bytes) with: bytes = p1_bytes | ... | pn_bytes | threshold\n   */\n  toUint8Array(): Uint8Array {\n    const bytes = new Uint8Array(this.publicKeys.length * Ed25519PublicKey.LENGTH + 1);\n    this.publicKeys.forEach((k: Ed25519PublicKey, i: number) => {\n      bytes.set(k.toUint8Array(), i * Ed25519PublicKey.LENGTH);\n    });\n\n    bytes[this.publicKeys.length * Ed25519PublicKey.LENGTH] = this.threshold;\n\n    return bytes;\n  }\n\n  toString(): string {\n    return Hex.fromHexInput(this.toUint8Array()).toString();\n  }\n\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars\n  verifySignature(args: { message: HexInput; signature: MultiEd25519Signature }): boolean {\n    throw new Error(\"TODO - Method not implemented.\");\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): MultiEd25519PublicKey {\n    const bytes = deserializer.deserializeBytes();\n    const threshold = bytes[bytes.length - 1];\n\n    const keys: Ed25519PublicKey[] = [];\n\n    for (let i = 0; i < bytes.length - 1; i += Ed25519PublicKey.LENGTH) {\n      const begin = i;\n      keys.push(new Ed25519PublicKey(bytes.subarray(begin, begin + Ed25519PublicKey.LENGTH)));\n    }\n    return new MultiEd25519PublicKey({ publicKeys: keys, threshold });\n  }\n}\n\n/**\n * Represents the signature of a K-of-N Ed25519 multi-sig transaction.\n */\nexport class MultiEd25519Signature extends Signature {\n  /**\n   * Maximum number of Ed25519 signatures supported\n   */\n  static MAX_SIGNATURES_SUPPORTED = 32;\n\n  /**\n   * Number of bytes in the bitmap representing who signed the transaction (32-bits)\n   */\n  static BITMAP_LEN: number = 4;\n\n  /**\n   * The list of underlying Ed25519 signatures\n   */\n  public readonly signatures: Ed25519Signature[];\n\n  /**\n   * 32-bit Bitmap representing who signed the transaction\n   *\n   * This is represented where each public key can be masked to determine whether the message was signed by that key.\n   */\n  public readonly bitmap: Uint8Array;\n\n  /**\n   * Signature for a K-of-N multi-sig transaction.\n   *\n   * @see {@link\n   * https://aptos.dev/integration/creating-a-signed-transaction/#multisignature-transactions | Creating a Signed Transaction}\n   *\n   * @param args.signatures A list of signatures\n   * @param args.bitmap 4 bytes, at most 32 signatures are supported. If Nth bit value is `1`, the Nth\n   * signature should be provided in `signatures`. Bits are read from left to right\n   */\n  constructor(args: { signatures: Ed25519Signature[]; bitmap: Uint8Array }) {\n    super();\n\n    const { signatures, bitmap } = args;\n    if (bitmap.length !== MultiEd25519Signature.BITMAP_LEN) {\n      throw new Error(`\"bitmap\" length should be ${MultiEd25519Signature.BITMAP_LEN}`);\n    }\n\n    if (signatures.length > MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED) {\n      throw new Error(\n        `The number of signatures cannot be greater than ${MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED}`,\n      );\n    }\n\n    this.signatures = signatures;\n    this.bitmap = bitmap;\n  }\n\n  /**\n   * Converts a MultiSignature into Uint8Array (bytes) with `bytes = s1_bytes | ... | sn_bytes | bitmap`\n   */\n  toUint8Array(): Uint8Array {\n    const bytes = new Uint8Array(this.signatures.length * Ed25519Signature.LENGTH + MultiEd25519Signature.BITMAP_LEN);\n    this.signatures.forEach((k: Ed25519Signature, i: number) => {\n      bytes.set(k.toUint8Array(), i * Ed25519Signature.LENGTH);\n    });\n\n    bytes.set(this.bitmap, this.signatures.length * Ed25519Signature.LENGTH);\n\n    return bytes;\n  }\n\n  toString(): string {\n    return Hex.fromHexInput(this.toUint8Array()).toString();\n  }\n\n  /**\n   * Helper method to create a bitmap out of the specified bit positions\n   * @param args.bits The bitmap positions that should be set. A position starts at index 0.\n   * Valid position should range between 0 and 31.\n   * @example\n   * Here's an example of valid `bits`\n   * ```\n   * [0, 2, 31]\n   * ```\n   * `[0, 2, 31]` means the 1st, 3rd and 32nd bits should be set in the bitmap.\n   * The result bitmap should be 0b1010000000000000000000000000001\n   *\n   * @returns bitmap that is 32bit long\n   */\n  static createBitmap(args: { bits: number[] }): Uint8Array {\n    const { bits } = args;\n    // Bits are read from left to right. e.g. 0b10000000 represents the first bit is set in one byte.\n    // The decimal value of 0b10000000 is 128.\n    const firstBitInByte = 128;\n    const bitmap = new Uint8Array([0, 0, 0, 0]);\n\n    // Check if duplicates exist in bits\n    const dupCheckSet = new Set();\n\n    bits.forEach((bit: number) => {\n      if (bit >= MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED) {\n        throw new Error(`Cannot have a signature larger than ${MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED - 1}.`);\n      }\n\n      if (dupCheckSet.has(bit)) {\n        throw new Error(\"Duplicate bits detected.\");\n      }\n\n      dupCheckSet.add(bit);\n\n      const byteOffset = Math.floor(bit / 8);\n\n      let byte = bitmap[byteOffset];\n\n      // eslint-disable-next-line no-bitwise\n      byte |= firstBitInByte >> bit % 8;\n\n      bitmap[byteOffset] = byte;\n    });\n\n    return bitmap;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): MultiEd25519Signature {\n    const bytes = deserializer.deserializeBytes();\n    const bitmap = bytes.subarray(bytes.length - 4);\n\n    const signatures: Ed25519Signature[] = [];\n\n    for (let i = 0; i < bytes.length - bitmap.length; i += Ed25519Signature.LENGTH) {\n      const begin = i;\n      signatures.push(new Ed25519Signature(bytes.subarray(begin, begin + Ed25519Signature.LENGTH)));\n    }\n    return new MultiEd25519Signature({ signatures, bitmap });\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { sha3_256 } from \"@noble/hashes/sha3\";\nimport { secp256k1 } from \"@noble/curves/secp256k1\";\nimport { PrivateKey, PublicKey, Signature } from \"./asymmetricCrypto\";\nimport { Deserializer, Serializer } from \"../../bcs\";\nimport { Hex } from \"../hex\";\nimport { HexInput } from \"../../types\";\n\n/**\n * Represents the Secp256k1 ecdsa public key\n *\n * Secp256k1 authentication key is represented in the SDK as `AnyPublicKey`.\n */\nexport class Secp256k1PublicKey extends PublicKey {\n  // Secp256k1 ecdsa public keys contain a prefix indicating compression and two 32-byte coordinates.\n  static readonly LENGTH: number = 65;\n\n  // Hex value of the public key\n  private readonly key: Hex;\n\n  /**\n   * Create a new PublicKey instance from a Uint8Array or String.\n   *\n   * @param hexInput A HexInput (string or Uint8Array)\n   */\n  constructor(hexInput: HexInput) {\n    super();\n\n    const hex = Hex.fromHexInput(hexInput);\n    if (hex.toUint8Array().length !== Secp256k1PublicKey.LENGTH) {\n      throw new Error(`PublicKey length should be ${Secp256k1PublicKey.LENGTH}`);\n    }\n    this.key = hex;\n  }\n\n  /**\n   * Get the public key in bytes (Uint8Array).\n   *\n   * @returns Uint8Array representation of the public key\n   */\n  toUint8Array(): Uint8Array {\n    return this.key.toUint8Array();\n  }\n\n  /**\n   * Get the public key as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the public key\n   */\n  toString(): string {\n    return this.key.toString();\n  }\n\n  /**\n   * Verifies a signed data with a public key\n   *\n   * @param args.message message\n   * @param args.signature The signature\n   * @returns true if the signature is valid\n   */\n  verifySignature(args: { message: HexInput; signature: Secp256k1Signature }): boolean {\n    const { message, signature } = args;\n    const msgHex = Hex.fromHexInput(message).toUint8Array();\n    const sha3Message = sha3_256(msgHex);\n    const rawSignature = signature.toUint8Array();\n    return secp256k1.verify(rawSignature, sha3Message, this.toUint8Array());\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.key.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): Secp256k1PublicKey {\n    const bytes = deserializer.deserializeBytes();\n    return new Secp256k1PublicKey(bytes);\n  }\n\n  static load(deserializer: Deserializer): Secp256k1PublicKey {\n    const bytes = deserializer.deserializeBytes();\n    return new Secp256k1PublicKey(bytes);\n  }\n}\n\n/**\n * A Secp256k1 ecdsa private key\n */\nexport class Secp256k1PrivateKey extends PrivateKey {\n  /**\n   * Length of Secp256k1 ecdsa private key\n   */\n  static readonly LENGTH: number = 32;\n\n  /**\n   * The private key bytes\n   * @private\n   */\n  private readonly key: Hex;\n\n  /**\n   * Create a new PrivateKey instance from a Uint8Array or String.\n   *\n   * @param hexInput A HexInput (string or Uint8Array)\n   */\n  constructor(hexInput: HexInput) {\n    super();\n\n    const privateKeyHex = Hex.fromHexInput(hexInput);\n    if (privateKeyHex.toUint8Array().length !== Secp256k1PrivateKey.LENGTH) {\n      throw new Error(`PrivateKey length should be ${Secp256k1PrivateKey.LENGTH}`);\n    }\n\n    this.key = privateKeyHex;\n  }\n\n  /**\n   * Get the private key in bytes (Uint8Array).\n   *\n   * @returns\n   */\n  toUint8Array(): Uint8Array {\n    return this.key.toUint8Array();\n  }\n\n  /**\n   * Get the private key as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the private key\n   */\n  toString(): string {\n    return this.key.toString();\n  }\n\n  /**\n   * Sign the given message with the private key.\n   *\n   * @param message in HexInput format\n   * @returns Signature\n   */\n  sign(message: HexInput): Secp256k1Signature {\n    const msgHex = Hex.fromHexInput(message);\n    const sha3Message = sha3_256(msgHex.toUint8Array());\n    const signature = secp256k1.sign(sha3Message, this.key.toUint8Array());\n    return new Secp256k1Signature(signature.toCompactRawBytes());\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): Secp256k1PrivateKey {\n    const bytes = deserializer.deserializeBytes();\n    return new Secp256k1PrivateKey(bytes);\n  }\n\n  /**\n   * Generate a new random private key.\n   *\n   * @returns Secp256k1PrivateKey\n   */\n  static generate(): Secp256k1PrivateKey {\n    const hexInput = secp256k1.utils.randomPrivateKey();\n    return new Secp256k1PrivateKey(hexInput);\n  }\n\n  /**\n   * Derive the Secp256k1PublicKey from this private key.\n   *\n   * @returns Secp256k1PublicKey\n   */\n  publicKey(): Secp256k1PublicKey {\n    const bytes = secp256k1.getPublicKey(this.key.toUint8Array(), false);\n    return new Secp256k1PublicKey(bytes);\n  }\n}\n\n/**\n * A signature of a message signed using an Secp256k1 ecdsa private key\n */\nexport class Secp256k1Signature extends Signature {\n  /**\n   * Secp256k1 ecdsa signatures are 256-bit.\n   */\n  static readonly LENGTH = 64;\n\n  /**\n   * The signature bytes\n   * @private\n   */\n  private readonly data: Hex;\n\n  /**\n   * Create a new Signature instance from a Uint8Array or String.\n   *\n   * @param hexInput A HexInput (string or Uint8Array)\n   */\n  constructor(hexInput: HexInput) {\n    super();\n\n    const hex = Hex.fromHexInput(hexInput);\n    if (hex.toUint8Array().length !== Secp256k1Signature.LENGTH) {\n      throw new Error(`Signature length should be ${Secp256k1Signature.LENGTH}, recieved ${hex.toUint8Array().length}`);\n    }\n    this.data = hex;\n  }\n\n  /**\n   * Get the signature in bytes (Uint8Array).\n   *\n   * @returns Uint8Array representation of the signature\n   */\n  toUint8Array(): Uint8Array {\n    return this.data.toUint8Array();\n  }\n\n  /**\n   * Get the signature as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the signature\n   */\n  toString(): string {\n    return this.data.toString();\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.data.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): Secp256k1Signature {\n    const hex = deserializer.deserializeBytes();\n    return new Secp256k1Signature(hex);\n  }\n\n  static load(deserializer: Deserializer): Secp256k1Signature {\n    const bytes = deserializer.deserializeBytes();\n    return new Secp256k1Signature(bytes);\n  }\n}\n","import { Serializer, Deserializer } from \"../../bcs\";\nimport { AnyPublicKeyVariant, HexInput } from \"../../types\";\nimport { AnySignature } from \"./anySignature\";\nimport { PublicKey } from \"./asymmetricCrypto\";\nimport { Ed25519PublicKey } from \"./ed25519\";\nimport { Secp256k1PublicKey } from \"./secp256k1\";\n\n/**\n * Represents any public key supported by Aptos.\n *\n * Since [AIP-55](https://github.com/aptos-foundation/AIPs/pull/263) Aptos supports\n * `Legacy` and `Unified` authentication keys.\n *\n * Any unified authentication key is represented in the SDK as `AnyPublicKey`.\n */\nexport class AnyPublicKey extends PublicKey {\n  /**\n   * Reference to the inner public key\n   */\n  public readonly publicKey: PublicKey;\n\n  constructor(publicKey: PublicKey) {\n    super();\n    this.publicKey = publicKey;\n  }\n\n  /**\n   * Get the public key in bytes (Uint8Array).\n   *\n   * @returns Uint8Array representation of the public key\n   */\n  toUint8Array(): Uint8Array {\n    return this.publicKey.toUint8Array();\n  }\n\n  /**\n   * Get the public key as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the public key\n   */\n  toString(): string {\n    return this.publicKey.toString();\n  }\n\n  /**\n   * Verifies a signed data with a public key\n   *\n   * @param args.message message\n   * @param args.signature The signature\n   * @returns true if the signature is valid\n   */\n  verifySignature(args: { message: HexInput; signature: AnySignature }): boolean {\n    const { message, signature } = args;\n    return this.publicKey.verifySignature({ message, signature });\n  }\n\n  serialize(serializer: Serializer): void {\n    if (this.publicKey instanceof Ed25519PublicKey) {\n      serializer.serializeU32AsUleb128(AnyPublicKeyVariant.Ed25519);\n      this.publicKey.serialize(serializer);\n    } else if (this.publicKey instanceof Secp256k1PublicKey) {\n      serializer.serializeU32AsUleb128(AnyPublicKeyVariant.Secp256k1);\n      this.publicKey.serialize(serializer);\n    } else {\n      throw new Error(\"Unknown public key type\");\n    }\n  }\n\n  static deserialize(deserializer: Deserializer): AnyPublicKey {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case AnyPublicKeyVariant.Ed25519:\n        return new AnyPublicKey(Ed25519PublicKey.load(deserializer));\n      case AnyPublicKeyVariant.Secp256k1:\n        return new AnyPublicKey(Secp256k1PublicKey.load(deserializer));\n      default:\n        throw new Error(`Unknown variant index for AnyPublicKey: ${index}`);\n    }\n  }\n}\n","import { Hex } from \"../hex\";\nimport { HexInput } from \"../../types\";\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializer } from \"../../bcs/serializer\";\nimport { AnyPublicKey } from \"./anyPublicKey\";\nimport { AnySignature } from \"./anySignature\";\nimport { PublicKey } from \"./asymmetricCrypto\";\n\nexport class MultiKey extends PublicKey {\n  /**\n   * List of any public keys\n   */\n  public readonly publicKeys: AnyPublicKey[];\n\n  /**\n   * The minimum number of valid signatures required, for the number of public keys specified\n   */\n  public readonly signaturesRequired: number;\n\n  constructor(args: { publicKeys: PublicKey[]; signaturesRequired: number }) {\n    super();\n    const { publicKeys, signaturesRequired } = args;\n\n    // Validate number of public keys is greater than signature required\n    if (signaturesRequired < 1) {\n      throw new Error(\"The number of required signatures needs to be greater then 0\");\n    }\n\n    // Validate number of public keys is greater than signature required\n    if (publicKeys.length < signaturesRequired) {\n      throw new Error(\n        `Provided ${publicKeys.length} public keys is smaller than the ${signaturesRequired} required signatures`,\n      );\n    }\n\n    const keys: AnyPublicKey[] = [];\n    publicKeys.forEach((publicKey) => {\n      if (publicKey instanceof AnyPublicKey) {\n        keys.push(publicKey);\n      } else {\n        // if public key is instance of a legacy authentication key, i.e\n        // Legacy Ed25519, convert it into AnyPublicKey\n        keys.push(new AnyPublicKey(publicKey));\n      }\n    });\n\n    this.publicKeys = keys;\n    this.signaturesRequired = signaturesRequired;\n  }\n\n  toUint8Array(): Uint8Array {\n    return this.bcsToBytes();\n  }\n\n  /**\n   * Create a bitmap that holds the mapping from the original public keys\n   * to the signatures passed in\n   *\n   * @param args.bits array of the index mapping to the matching public keys\n   * @returns Uint8array bit map\n   */\n  createBitmap(args: { bits: number[] }): Uint8Array {\n    const { bits } = args;\n    // Bits are read from left to right. e.g. 0b10000000 represents the first bit is set in one byte.\n    // The decimal value of 0b10000000 is 128.\n    const firstBitInByte = 128;\n    const bitmap = new Uint8Array([0, 0, 0, 0]);\n\n    // Check if duplicates exist in bits\n    const dupCheckSet = new Set();\n\n    bits.forEach((bit: number, idx: number) => {\n      if (idx + 1 > this.publicKeys.length) {\n        throw new Error(`Signature index ${idx + 1} is out of public keys range, ${this.publicKeys.length}.`);\n      }\n\n      if (dupCheckSet.has(bit)) {\n        throw new Error(`Duplicate bit ${bit} detected.`);\n      }\n\n      dupCheckSet.add(bit);\n\n      const byteOffset = Math.floor(bit / 8);\n\n      let byte = bitmap[byteOffset];\n\n      // eslint-disable-next-line no-bitwise\n      byte |= firstBitInByte >> bit % 8;\n\n      bitmap[byteOffset] = byte;\n    });\n\n    return bitmap;\n  }\n\n  /**\n   * Hex string representation the multi key bytes\n   *\n   * @returns string\n   */\n  toString(): string {\n    return Hex.fromHexInput(this.toUint8Array()).toString();\n  }\n\n  // TODO\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars\n  verifySignature(args: { message: HexInput; signature: AnySignature }): boolean {\n    throw new Error(\"not implemented\");\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeVector(this.publicKeys);\n    serializer.serializeU8(this.signaturesRequired);\n  }\n\n  static deserialize(deserializer: Deserializer): MultiKey {\n    const keys = deserializer.deserializeVector(AnyPublicKey);\n    const signaturesRequired = deserializer.deserializeU8();\n\n    return new MultiKey({ publicKeys: keys, signaturesRequired });\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { hmac } from \"@noble/hashes/hmac\";\nimport { sha512 } from \"@noble/hashes/sha512\";\nimport * as bip39 from \"@scure/bip39\";\n\nexport type DerivedKeys = {\n  key: Uint8Array;\n  chainCode: Uint8Array;\n};\n\n/**\n * Aptos derive path is 637\n *\n * See https://github.com/satoshilabs/slips/blob/master/slip-0044.md\n */\nexport const APTOS_PATH_REGEX = /^m\\/44'\\/637'\\/[0-9]+'\\/[0-9]+'\\/[0-9]+'?$/;\n\n/**\n * A list of supported key types and associated seeds\n */\nexport enum KeyType {\n  ED25519 = \"ed25519 seed\",\n}\n\nconst HARDENED_OFFSET = 0x80000000;\n\nconst deriveKey = (hashSeed: Uint8Array | string, data: Uint8Array | string): DerivedKeys => {\n  const digest = hmac.create(sha512, hashSeed).update(data).digest();\n  return {\n    key: digest.slice(0, 32),\n    chainCode: digest.slice(32),\n  };\n};\n\n/**\n * Derive a child key from the private key\n * @param key\n * @param chainCode\n * @param index\n * @constructor\n */\nconst CKDPriv = ({ key, chainCode }: DerivedKeys, index: number): DerivedKeys => {\n  const buffer = new ArrayBuffer(4);\n  new DataView(buffer).setUint32(0, index);\n  const indexBytes = new Uint8Array(buffer);\n  const zero = new Uint8Array([0]);\n  const data = new Uint8Array([...zero, ...key, ...indexBytes]);\n\n  return deriveKey(chainCode, data);\n};\n\nconst removeApostrophes = (val: string): string => val.replace(\"'\", \"\");\n\n/**\n * Splits derive path into segments\n * @param path\n */\nconst splitPath = (path: string): Array<string> => path.split(\"/\").slice(1).map(removeApostrophes);\n\n/**\n * Checks if the BIP44 path is valid for Aptos\n * @param path the BIP44 path\n *\n * @returns true if the path is a valid Aptos path\n */\nexport const isValidPath = (path: string): boolean => {\n  if (!APTOS_PATH_REGEX.test(path)) {\n    return false;\n  }\n  return !splitPath(path).some(Number.isNaN as any);\n};\n\n/**\n * Normalizes the mnemonic by removing extra whitespace and making it lowercase\n * @param mnemonic the mnemonic seed phrase\n */\nconst mnemonicToSeed = (mnemonic: string): Uint8Array => {\n  const normalizedMnemonic = mnemonic\n    .trim()\n    .split(/\\s+/)\n    .map((part) => part.toLowerCase())\n    .join(\" \");\n  return bip39.mnemonicToSeedSync(normalizedMnemonic);\n};\n\n/**\n * Derives a private key from a mnemonic seed phrase.\n *\n * To derive multiple keys from the same phrase, change the path\n * @param keyType the key type seed used to derive keys\n * @param path the BIP44 path\n * @param seedPhrase the mnemonic seed phrase\n * @param offset the offset used for key derivation, defaults to [HARDENED_OFFSET]\n */\nexport const derivePrivateKeyFromMnemonic = (\n  keyType: KeyType,\n  path: string,\n  seedPhrase: string,\n  offset = HARDENED_OFFSET,\n): DerivedKeys => {\n  if (!isValidPath(path)) {\n    throw new Error(\"Invalid derivation path\");\n  }\n\n  // Derive the master key from the mnemonic\n  const { key, chainCode } = deriveKey(keyType, mnemonicToSeed(seedPhrase));\n  const segments = splitPath(path).map((el) => parseInt(el, 10));\n\n  // Derive the child key based on the path\n  return segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset), { key, chainCode });\n};\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AccountAddress } from \"./accountAddress\";\nimport { AuthenticationKey } from \"./authenticationKey\";\nimport { PrivateKey, PublicKey, Signature } from \"./crypto/asymmetricCrypto\";\nimport { Ed25519PrivateKey, Ed25519PublicKey } from \"./crypto/ed25519\";\nimport { MultiEd25519PublicKey } from \"./crypto/multiEd25519\";\nimport { Secp256k1PrivateKey, Secp256k1PublicKey } from \"./crypto/secp256k1\";\nimport { Hex } from \"./hex\";\nimport { GenerateAccount, HexInput, SigningScheme, SigningSchemeInput } from \"../types\";\nimport { derivePrivateKeyFromMnemonic, KeyType } from \"../utils/hdKey\";\nimport { AnyPublicKey } from \"./crypto/anyPublicKey\";\n\n/**\n * Class for creating and managing account on Aptos network\n *\n * Use this class to create accounts, sign transactions, and more.\n * Note: Creating an account instance does not create the account on-chain.\n *\n * Since [AIP-55](https://github.com/aptos-foundation/AIPs/pull/263) Aptos supports\n * `Legacy` and `Unified` authentications.\n *\n * @Legacy includes `ED25519` and `MultiED25519`\n * @Unified includes `SingleSender` and `MultiSender`, where currently\n * `SingleSender` supports `ED25519` and `Secp256k1`, and `MultiSender` supports\n * `MultiED25519`.\n *\n * In TypeScript SDK, we support all of these options\n * @generate default to generate Unified keys, with an optional `legacy` boolean argument\n * that lets you generate new keys conforming to the Legacy authentication.\n * @fromPrivateKey derives an account by a provided private key and address, with an optional\n * `legacy` boolean argument that lets you generate new keys conforming to the Legacy authentication.\n * @fromDerivationPath derives an account with bip44 path and mnemonics,\n *\n */\nexport class Account {\n  /**\n   * Public key associated with the account\n   */\n  readonly publicKey: PublicKey;\n\n  /**\n   * Private key associated with the account\n   */\n  readonly privateKey: PrivateKey;\n\n  /**\n   * Account address associated with the account\n   */\n  readonly accountAddress: AccountAddress;\n\n  /**\n   * Signing scheme used to sign transactions\n   */\n  readonly signingScheme: SigningScheme;\n\n  /**\n   * constructor for Account\n   *\n   * Need to update this to use the new crypto library if new schemes are added.\n   *\n   * @param args.privateKey PrivateKey - private key of the account\n   * @param args.address AccountAddress - address of the account\n   * @param args.legacy optional. If set to true, the keypair authentication keys will be derived with a Legacy scheme.\n   * Defaults to deriving an authentication key with a Unified scheme\n   *\n   * This method is private because it should only be called by the factory static methods.\n   * @returns Account\n   */\n  private constructor(args: { privateKey: PrivateKey; address: AccountAddress; legacy?: boolean }) {\n    const { privateKey, address, legacy } = args;\n\n    // Derive the public key from the private key\n    this.publicKey = privateKey.publicKey();\n\n    // Derive the signing scheme from the public key\n    if (this.publicKey instanceof Ed25519PublicKey) {\n      if (legacy) {\n        this.signingScheme = SigningScheme.Ed25519;\n      } else {\n        this.publicKey = new AnyPublicKey(this.publicKey);\n        this.signingScheme = SigningScheme.SingleKey;\n      }\n    } else if (this.publicKey instanceof MultiEd25519PublicKey) {\n      this.signingScheme = SigningScheme.MultiEd25519;\n    } else if (this.publicKey instanceof Secp256k1PublicKey) {\n      this.publicKey = new AnyPublicKey(this.publicKey);\n      this.signingScheme = SigningScheme.SingleKey;\n    } else {\n      throw new Error(\"Can not create new Account, unsupported public key type\");\n    }\n\n    this.privateKey = privateKey;\n    this.accountAddress = address;\n  }\n\n  /**\n   * Derives an account with random private key and address.\n   * Default generation is using the Unified flow with ED25519 key\n   *\n   * @param args optional. Unify GenerateAccount type for Legacy and Unified keys\n   *\n   * Account input type to generate an account using Legacy\n   * Ed25519 or MultiEd25519 keys or without a specified `scheme`.\n   * ```\n   * GenerateAccountWithLegacyKey = {\n   *  scheme?: SigningSchemeInput.Ed25519 | SigningSchemeInput.MultiEd25519;\n   *  legacy: true;\n   * };\n   * ```\n   *\n   * Account input type to generate an account using Unified\n   * Secp256k1Ecdsa key\n   * In this case `legacy` is always false\n   * ```\n   * GenerateAccountWithUnifiedKey = {\n   *  scheme: SigningSchemeInput.Secp256k1Ecdsa;\n   *  legacy?: false;\n   * };\n   * ```\n   *\n   * @returns Account with the given signing scheme\n   */\n  static generate(args?: GenerateAccount): Account {\n    let privateKey: PrivateKey;\n\n    switch (args?.scheme) {\n      case SigningSchemeInput.Secp256k1Ecdsa:\n        privateKey = Secp256k1PrivateKey.generate();\n        break;\n      default:\n        privateKey = Ed25519PrivateKey.generate();\n    }\n\n    let publicKey = privateKey.publicKey();\n    if (!args?.legacy) {\n      publicKey = new AnyPublicKey(privateKey.publicKey());\n    }\n\n    const address = new AccountAddress({\n      data: Account.authKey({\n        publicKey,\n      }).toUint8Array(),\n    });\n    return new Account({ privateKey, address, legacy: args?.legacy });\n  }\n\n  /**\n   * Instantiates an account given a private key and a specified account address.\n   * This is primarily used to instantiate an `Account` that has had its authentication key rotated.\n   *\n   * @param privateKey PrivateKey - private key of the account\n   * @param address The account address\n   * @param args.legacy optional. If set to true, the keypair authentication keys will be derived with a Legacy scheme.\n   * Defaults to deriving an authentication key with a Unified scheme\n   *\n   * @returns Account\n   */\n  static fromPrivateKeyAndAddress(args: {\n    privateKey: PrivateKey;\n    address: AccountAddress;\n    legacy?: boolean;\n  }): Account {\n    const { privateKey, address, legacy } = args;\n    return new Account({ privateKey, address, legacy });\n  }\n\n  /**\n   * Derives an account with bip44 path and mnemonics,\n   *\n   * @param args.path the BIP44 derive path (e.g. m/44'/637'/0'/0'/0')\n   * Detailed description: {@link https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki}\n   * @param args.mnemonic the mnemonic seed phrase of the account\n   * @returns AptosAccount\n   */\n  static fromDerivationPath(args: { path: string; mnemonic: string }): Account {\n    const { path, mnemonic } = args;\n    const { key } = derivePrivateKeyFromMnemonic(KeyType.ED25519, path, mnemonic);\n    const privateKey = new Ed25519PrivateKey(key);\n    const publicKey = privateKey.publicKey();\n    const authKey = Account.authKey({ publicKey });\n    const address = new AccountAddress({ data: authKey.toUint8Array() });\n    return new Account({ privateKey, address, legacy: true });\n  }\n\n  /**\n   * This key enables account owners to rotate their private key(s)\n   * associated with the account without changing the address that hosts their account.\n   * See here for more info: {@link https://aptos.dev/concepts/accounts#single-signer-authentication}\n   *\n   * @param args.publicKey PublicKey - public key of the account\n   * @returns Authentication key for the associated account\n   */\n  static authKey(args: { publicKey: PublicKey }): Hex {\n    const { publicKey } = args;\n    const authKey = AuthenticationKey.fromPublicKey({ publicKey });\n    return authKey.data;\n  }\n\n  /**\n   * Sign the given message with the private key.\n   *\n   * TODO: Add sign transaction or specific types\n   *\n   * @param data in HexInput format\n   * @returns Signature\n   */\n  sign(data: HexInput): Signature {\n    return this.privateKey.sign(data);\n  }\n\n  /**\n   * Verify the given message and signature with the public key.\n   *\n   * @param args.message raw message data in HexInput format\n   * @param args.signature signed message Signature\n   * @returns\n   */\n  verifySignature(args: { message: HexInput; signature: Signature }): boolean {\n    const { message, signature } = args;\n    const rawMessage = Hex.fromHexInput(message).toUint8Array();\n    return this.publicKey.verifySignature({ message: rawMessage, signature });\n  }\n}\n","import * as Types from \"./operations\";\n\nimport { GraphQLClient } from \"graphql-request\";\nimport * as Dom from \"graphql-request/dist/types.dom\";\nexport const CurrentTokenOwnershipFieldsFragmentDoc = `\n    fragment CurrentTokenOwnershipFields on current_token_ownerships_v2 {\n  token_standard\n  token_properties_mutated_v1\n  token_data_id\n  table_type_v1\n  storage_id\n  property_version_v1\n  owner_address\n  last_transaction_version\n  last_transaction_timestamp\n  is_soulbound_v2\n  is_fungible_v2\n  amount\n  current_token_data {\n    collection_id\n    description\n    is_fungible_v2\n    largest_property_version_v1\n    last_transaction_timestamp\n    last_transaction_version\n    maximum\n    supply\n    token_data_id\n    token_name\n    token_properties\n    token_standard\n    token_uri\n    current_collection {\n      collection_id\n      collection_name\n      creator_address\n      current_supply\n      description\n      last_transaction_timestamp\n      last_transaction_version\n      max_supply\n      mutable_description\n      mutable_uri\n      table_handle_v1\n      token_standard\n      total_minted_v2\n      uri\n    }\n  }\n}\n    `;\nexport const TokenActivitiesFieldsFragmentDoc = `\n    fragment TokenActivitiesFields on token_activities_v2 {\n  after_value\n  before_value\n  entry_function_id_str\n  event_account_address\n  event_index\n  from_address\n  is_fungible_v2\n  property_version_v1\n  to_address\n  token_amount\n  token_data_id\n  token_standard\n  transaction_timestamp\n  transaction_version\n  type\n}\n    `;\nexport const GetAccountCoinsCount = `\n    query getAccountCoinsCount($address: String) {\n  current_fungible_asset_balances_aggregate(\n    where: {owner_address: {_eq: $address}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n    `;\nexport const GetAccountCoinsData = `\n    query getAccountCoinsData($where_condition: current_fungible_asset_balances_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_fungible_asset_balances_order_by!]) {\n  current_fungible_asset_balances(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    amount\n    asset_type\n    is_frozen\n    is_primary\n    last_transaction_timestamp\n    last_transaction_version\n    owner_address\n    storage_id\n    token_standard\n    metadata {\n      token_standard\n      symbol\n      supply_aggregator_table_key_v1\n      supply_aggregator_table_handle_v1\n      project_uri\n      name\n      last_transaction_version\n      last_transaction_timestamp\n      icon_uri\n      decimals\n      creator_address\n      asset_type\n    }\n  }\n}\n    `;\nexport const GetAccountCollectionsWithOwnedTokens = `\n    query getAccountCollectionsWithOwnedTokens($where_condition: current_collection_ownership_v2_view_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_collection_ownership_v2_view_order_by!]) {\n  current_collection_ownership_v2_view(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    current_collection {\n      collection_id\n      collection_name\n      creator_address\n      current_supply\n      description\n      last_transaction_timestamp\n      last_transaction_version\n      mutable_description\n      max_supply\n      mutable_uri\n      table_handle_v1\n      token_standard\n      total_minted_v2\n      uri\n    }\n    collection_id\n    collection_name\n    collection_uri\n    creator_address\n    distinct_tokens\n    last_transaction_version\n    owner_address\n    single_token_uri\n  }\n}\n    `;\nexport const GetAccountOwnedObjects = `\n    query getAccountOwnedObjects($where_condition: current_objects_bool_exp, $offset: Int, $limit: Int, $order_by: [current_objects_order_by!]) {\n  current_objects(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    allow_ungated_transfer\n    state_key_hash\n    owner_address\n    object_address\n    last_transaction_version\n    last_guid_creation_num\n    is_deleted\n  }\n}\n    `;\nexport const GetAccountOwnedTokens = `\n    query getAccountOwnedTokens($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {\n  current_token_ownerships_v2(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    ...CurrentTokenOwnershipFields\n  }\n}\n    ${CurrentTokenOwnershipFieldsFragmentDoc}`;\nexport const GetAccountOwnedTokensByTokenData = `\n    query getAccountOwnedTokensByTokenData($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {\n  current_token_ownerships_v2(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    ...CurrentTokenOwnershipFields\n  }\n}\n    ${CurrentTokenOwnershipFieldsFragmentDoc}`;\nexport const GetAccountOwnedTokensFromCollection = `\n    query getAccountOwnedTokensFromCollection($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {\n  current_token_ownerships_v2(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    ...CurrentTokenOwnershipFields\n  }\n}\n    ${CurrentTokenOwnershipFieldsFragmentDoc}`;\nexport const GetAccountTokensCount = `\n    query getAccountTokensCount($where_condition: current_token_ownerships_v2_bool_exp, $offset: Int, $limit: Int) {\n  current_token_ownerships_v2_aggregate(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n    `;\nexport const GetAccountTransactionsCount = `\n    query getAccountTransactionsCount($address: String) {\n  account_transactions_aggregate(where: {account_address: {_eq: $address}}) {\n    aggregate {\n      count\n    }\n  }\n}\n    `;\nexport const GetChainTopUserTransactions = `\n    query getChainTopUserTransactions($limit: Int) {\n  user_transactions(limit: $limit, order_by: {version: desc}) {\n    version\n  }\n}\n    `;\nexport const GetCollectionData = `\n    query getCollectionData($where_condition: current_collections_v2_bool_exp!) {\n  current_collections_v2(where: $where_condition) {\n    collection_id\n    collection_name\n    creator_address\n    current_supply\n    description\n    last_transaction_timestamp\n    last_transaction_version\n    max_supply\n    mutable_description\n    mutable_uri\n    table_handle_v1\n    token_standard\n    total_minted_v2\n    uri\n  }\n}\n    `;\nexport const GetCurrentFungibleAssetBalances = `\n    query getCurrentFungibleAssetBalances($where_condition: current_fungible_asset_balances_bool_exp, $offset: Int, $limit: Int) {\n  current_fungible_asset_balances(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n  ) {\n    amount\n    asset_type\n    is_frozen\n    is_primary\n    last_transaction_timestamp\n    last_transaction_version\n    owner_address\n    storage_id\n    token_standard\n  }\n}\n    `;\nexport const GetDelegatedStakingActivities = `\n    query getDelegatedStakingActivities($delegatorAddress: String, $poolAddress: String) {\n  delegated_staking_activities(\n    where: {delegator_address: {_eq: $delegatorAddress}, pool_address: {_eq: $poolAddress}}\n  ) {\n    amount\n    delegator_address\n    event_index\n    event_type\n    pool_address\n    transaction_version\n  }\n}\n    `;\nexport const GetEvents = `\n    query getEvents($where_condition: events_bool_exp, $offset: Int, $limit: Int, $order_by: [events_order_by!]) {\n  events(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    account_address\n    creation_number\n    data\n    event_index\n    sequence_number\n    transaction_block_height\n    transaction_version\n    type\n  }\n}\n    `;\nexport const GetFungibleAssetActivities = `\n    query getFungibleAssetActivities($where_condition: fungible_asset_activities_bool_exp, $offset: Int, $limit: Int) {\n  fungible_asset_activities(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n  ) {\n    amount\n    asset_type\n    block_height\n    entry_function_id_str\n    event_index\n    gas_fee_payer_address\n    is_frozen\n    is_gas_fee\n    is_transaction_success\n    owner_address\n    storage_id\n    storage_refund_amount\n    token_standard\n    transaction_timestamp\n    transaction_version\n    type\n  }\n}\n    `;\nexport const GetFungibleAssetMetadata = `\n    query getFungibleAssetMetadata($where_condition: fungible_asset_metadata_bool_exp, $offset: Int, $limit: Int) {\n  fungible_asset_metadata(where: $where_condition, offset: $offset, limit: $limit) {\n    icon_uri\n    project_uri\n    supply_aggregator_table_handle_v1\n    supply_aggregator_table_key_v1\n    creator_address\n    asset_type\n    decimals\n    last_transaction_timestamp\n    last_transaction_version\n    name\n    symbol\n    token_standard\n  }\n}\n    `;\nexport const GetNumberOfDelegators = `\n    query getNumberOfDelegators($where_condition: num_active_delegator_per_pool_bool_exp!, $order_by: [num_active_delegator_per_pool_order_by!]) {\n  num_active_delegator_per_pool(where: $where_condition, order_by: $order_by) {\n    num_active_delegator\n    pool_address\n  }\n}\n    `;\nexport const GetProcessorStatus = `\n    query getProcessorStatus {\n  processor_status {\n    last_success_version\n    processor\n    last_updated\n  }\n}\n    `;\nexport const GetTokenActivity = `\n    query getTokenActivity($where_condition: token_activities_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [token_activities_v2_order_by!]) {\n  token_activities_v2(\n    where: $where_condition\n    order_by: $order_by\n    offset: $offset\n    limit: $limit\n  ) {\n    ...TokenActivitiesFields\n  }\n}\n    ${TokenActivitiesFieldsFragmentDoc}`;\nexport const GetCurrentTokenOwnership = `\n    query getCurrentTokenOwnership($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {\n  current_token_ownerships_v2(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    ...CurrentTokenOwnershipFields\n  }\n}\n    ${CurrentTokenOwnershipFieldsFragmentDoc}`;\nexport const GetTokenData = `\n    query getTokenData($where_condition: current_token_datas_v2_bool_exp, $offset: Int, $limit: Int, $order_by: [current_token_datas_v2_order_by!]) {\n  current_token_datas_v2(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    collection_id\n    description\n    is_fungible_v2\n    largest_property_version_v1\n    last_transaction_timestamp\n    last_transaction_version\n    maximum\n    supply\n    token_data_id\n    token_name\n    token_properties\n    token_standard\n    token_uri\n    current_collection {\n      collection_id\n      collection_name\n      creator_address\n      current_supply\n      description\n      last_transaction_timestamp\n      last_transaction_version\n      max_supply\n      mutable_description\n      mutable_uri\n      table_handle_v1\n      token_standard\n      total_minted_v2\n      uri\n    }\n  }\n}\n    `;\n\nexport type SdkFunctionWrapper = <T>(\n  action: (requestHeaders?: Record<string, string>) => Promise<T>,\n  operationName: string,\n  operationType?: string,\n) => Promise<T>;\n\nconst defaultWrapper: SdkFunctionWrapper = (action, _operationName, _operationType) => action();\n\nexport function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {\n  return {\n    getAccountCoinsCount(\n      variables?: Types.GetAccountCoinsCountQueryVariables,\n      requestHeaders?: Dom.RequestInit[\"headers\"],\n    ): Promise<Types.GetAccountCoinsCountQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAccountCoinsCountQuery>(GetAccountCoinsCount, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getAccountCoinsCount\",\n        \"query\",\n      );\n    },\n    getAccountCoinsData(\n      variables: Types.GetAccountCoinsDataQueryVariables,\n      requestHeaders?: Dom.RequestInit[\"headers\"],\n    ): Promise<Types.GetAccountCoinsDataQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAccountCoinsDataQuery>(GetAccountCoinsData, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getAccountCoinsData\",\n        \"query\",\n      );\n    },\n    getAccountCollectionsWithOwnedTokens(\n      variables: Types.GetAccountCollectionsWithOwnedTokensQueryVariables,\n      requestHeaders?: Dom.RequestInit[\"headers\"],\n    ): Promise<Types.GetAccountCollectionsWithOwnedTokensQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAccountCollectionsWithOwnedTokensQuery>(\n            GetAccountCollectionsWithOwnedTokens,\n            variables,\n            { ...requestHeaders, ...wrappedRequestHeaders },\n          ),\n        \"getAccountCollectionsWithOwnedTokens\",\n        \"query\",\n      );\n    },\n    getAccountOwnedObjects(\n      variables?: Types.GetAccountOwnedObjectsQueryVariables,\n      requestHeaders?: Dom.RequestInit[\"headers\"],\n    ): Promise<Types.GetAccountOwnedObjectsQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAccountOwnedObjectsQuery>(GetAccountOwnedObjects, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getAccountOwnedObjects\",\n        \"query\",\n      );\n    },\n    getAccountOwnedTokens(\n      variables: Types.GetAccountOwnedTokensQueryVariables,\n      requestHeaders?: Dom.RequestInit[\"headers\"],\n    ): Promise<Types.GetAccountOwnedTokensQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAccountOwnedTokensQuery>(GetAccountOwnedTokens, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getAccountOwnedTokens\",\n        \"query\",\n      );\n    },\n    getAccountOwnedTokensByTokenData(\n      variables: Types.GetAccountOwnedTokensByTokenDataQueryVariables,\n      requestHeaders?: Dom.RequestInit[\"headers\"],\n    ): Promise<Types.GetAccountOwnedTokensByTokenDataQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAccountOwnedTokensByTokenDataQuery>(GetAccountOwnedTokensByTokenData, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getAccountOwnedTokensByTokenData\",\n        \"query\",\n      );\n    },\n    getAccountOwnedTokensFromCollection(\n      variables: Types.GetAccountOwnedTokensFromCollectionQueryVariables,\n      requestHeaders?: Dom.RequestInit[\"headers\"],\n    ): Promise<Types.GetAccountOwnedTokensFromCollectionQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAccountOwnedTokensFromCollectionQuery>(\n            GetAccountOwnedTokensFromCollection,\n            variables,\n            { ...requestHeaders, ...wrappedRequestHeaders },\n          ),\n        \"getAccountOwnedTokensFromCollection\",\n        \"query\",\n      );\n    },\n    getAccountTokensCount(\n      variables?: Types.GetAccountTokensCountQueryVariables,\n      requestHeaders?: Dom.RequestInit[\"headers\"],\n    ): Promise<Types.GetAccountTokensCountQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAccountTokensCountQuery>(GetAccountTokensCount, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getAccountTokensCount\",\n        \"query\",\n      );\n    },\n    getAccountTransactionsCount(\n      variables?: Types.GetAccountTransactionsCountQueryVariables,\n      requestHeaders?: Dom.RequestInit[\"headers\"],\n    ): Promise<Types.GetAccountTransactionsCountQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetAccountTransactionsCountQuery>(GetAccountTransactionsCount, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getAccountTransactionsCount\",\n        \"query\",\n      );\n    },\n    getChainTopUserTransactions(\n      variables?: Types.GetChainTopUserTransactionsQueryVariables,\n      requestHeaders?: Dom.RequestInit[\"headers\"],\n    ): Promise<Types.GetChainTopUserTransactionsQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetChainTopUserTransactionsQuery>(GetChainTopUserTransactions, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getChainTopUserTransactions\",\n        \"query\",\n      );\n    },\n    getCollectionData(\n      variables: Types.GetCollectionDataQueryVariables,\n      requestHeaders?: Dom.RequestInit[\"headers\"],\n    ): Promise<Types.GetCollectionDataQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetCollectionDataQuery>(GetCollectionData, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getCollectionData\",\n        \"query\",\n      );\n    },\n    getCurrentFungibleAssetBalances(\n      variables?: Types.GetCurrentFungibleAssetBalancesQueryVariables,\n      requestHeaders?: Dom.RequestInit[\"headers\"],\n    ): Promise<Types.GetCurrentFungibleAssetBalancesQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetCurrentFungibleAssetBalancesQuery>(GetCurrentFungibleAssetBalances, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getCurrentFungibleAssetBalances\",\n        \"query\",\n      );\n    },\n    getDelegatedStakingActivities(\n      variables?: Types.GetDelegatedStakingActivitiesQueryVariables,\n      requestHeaders?: Dom.RequestInit[\"headers\"],\n    ): Promise<Types.GetDelegatedStakingActivitiesQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetDelegatedStakingActivitiesQuery>(GetDelegatedStakingActivities, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getDelegatedStakingActivities\",\n        \"query\",\n      );\n    },\n    getEvents(\n      variables?: Types.GetEventsQueryVariables,\n      requestHeaders?: Dom.RequestInit[\"headers\"],\n    ): Promise<Types.GetEventsQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetEventsQuery>(GetEvents, variables, { ...requestHeaders, ...wrappedRequestHeaders }),\n        \"getEvents\",\n        \"query\",\n      );\n    },\n    getFungibleAssetActivities(\n      variables?: Types.GetFungibleAssetActivitiesQueryVariables,\n      requestHeaders?: Dom.RequestInit[\"headers\"],\n    ): Promise<Types.GetFungibleAssetActivitiesQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetFungibleAssetActivitiesQuery>(GetFungibleAssetActivities, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getFungibleAssetActivities\",\n        \"query\",\n      );\n    },\n    getFungibleAssetMetadata(\n      variables?: Types.GetFungibleAssetMetadataQueryVariables,\n      requestHeaders?: Dom.RequestInit[\"headers\"],\n    ): Promise<Types.GetFungibleAssetMetadataQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetFungibleAssetMetadataQuery>(GetFungibleAssetMetadata, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getFungibleAssetMetadata\",\n        \"query\",\n      );\n    },\n    getNumberOfDelegators(\n      variables: Types.GetNumberOfDelegatorsQueryVariables,\n      requestHeaders?: Dom.RequestInit[\"headers\"],\n    ): Promise<Types.GetNumberOfDelegatorsQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetNumberOfDelegatorsQuery>(GetNumberOfDelegators, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getNumberOfDelegators\",\n        \"query\",\n      );\n    },\n    getProcessorStatus(\n      variables?: Types.GetProcessorStatusQueryVariables,\n      requestHeaders?: Dom.RequestInit[\"headers\"],\n    ): Promise<Types.GetProcessorStatusQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetProcessorStatusQuery>(GetProcessorStatus, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getProcessorStatus\",\n        \"query\",\n      );\n    },\n    getTokenActivity(\n      variables: Types.GetTokenActivityQueryVariables,\n      requestHeaders?: Dom.RequestInit[\"headers\"],\n    ): Promise<Types.GetTokenActivityQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetTokenActivityQuery>(GetTokenActivity, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getTokenActivity\",\n        \"query\",\n      );\n    },\n    getCurrentTokenOwnership(\n      variables: Types.GetCurrentTokenOwnershipQueryVariables,\n      requestHeaders?: Dom.RequestInit[\"headers\"],\n    ): Promise<Types.GetCurrentTokenOwnershipQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetCurrentTokenOwnershipQuery>(GetCurrentTokenOwnership, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getCurrentTokenOwnership\",\n        \"query\",\n      );\n    },\n    getTokenData(\n      variables?: Types.GetTokenDataQueryVariables,\n      requestHeaders?: Dom.RequestInit[\"headers\"],\n    ): Promise<Types.GetTokenDataQuery> {\n      return withWrapper(\n        (wrappedRequestHeaders) =>\n          client.request<Types.GetTokenDataQuery>(GetTokenData, variables, {\n            ...requestHeaders,\n            ...wrappedRequestHeaders,\n          }),\n        \"getTokenData\",\n        \"query\",\n      );\n    },\n  };\n}\nexport type Sdk = ReturnType<typeof getSdk>;\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/general}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * general namespace and without having a dependency cycle error.\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { getAptosFullNode, postAptosFullNode, postAptosIndexer } from \"../client\";\nimport {\n  AnyNumber,\n  Block,\n  GetChainTopUserTransactionsResponse,\n  GetProcessorStatusResponse,\n  GraphqlQuery,\n  LedgerInfo,\n  LedgerVersion,\n  MoveValue,\n  TableItemRequest,\n  ViewRequest,\n  ViewRequestData,\n} from \"../types\";\nimport { GetChainTopUserTransactionsQuery, GetProcessorStatusQuery } from \"../types/generated/operations\";\nimport { GetChainTopUserTransactions, GetProcessorStatus } from \"../types/generated/queries\";\n\nexport async function getLedgerInfo(args: { aptosConfig: AptosConfig }): Promise<LedgerInfo> {\n  const { aptosConfig } = args;\n  const { data } = await getAptosFullNode<{}, LedgerInfo>({\n    aptosConfig,\n    originMethod: \"getLedgerInfo\",\n    path: \"\",\n  });\n  return data;\n}\n\nexport async function getBlockByVersion(args: {\n  aptosConfig: AptosConfig;\n  ledgerVersion: AnyNumber;\n  options?: { withTransactions?: boolean };\n}): Promise<Block> {\n  const { aptosConfig, ledgerVersion, options } = args;\n  const { data } = await getAptosFullNode<{}, Block>({\n    aptosConfig,\n    originMethod: \"getBlockByVersion\",\n    path: `blocks/by_version/${ledgerVersion}`,\n    params: { with_transactions: options?.withTransactions },\n  });\n  return data;\n}\n\nexport async function getBlockByHeight(args: {\n  aptosConfig: AptosConfig;\n  blockHeight: AnyNumber;\n  options?: { withTransactions?: boolean };\n}): Promise<Block> {\n  const { aptosConfig, blockHeight, options } = args;\n  const { data } = await getAptosFullNode<{}, Block>({\n    aptosConfig,\n    originMethod: \"getBlockByHeight\",\n    path: `blocks/by_height/${blockHeight}`,\n    params: { with_transactions: options?.withTransactions },\n  });\n  return data;\n}\n\nexport async function getTableItem(args: {\n  aptosConfig: AptosConfig;\n  handle: string;\n  data: TableItemRequest;\n  options?: LedgerVersion;\n}): Promise<any> {\n  const { aptosConfig, handle, data, options } = args;\n  const response = await postAptosFullNode<TableItemRequest, any>({\n    aptosConfig,\n    originMethod: \"getTableItem\",\n    path: `tables/${handle}/item`,\n    params: { ledger_version: options?.ledgerVersion },\n    body: data,\n  });\n  return response.data;\n}\n\nexport async function view(args: {\n  aptosConfig: AptosConfig;\n  payload: ViewRequestData;\n  options?: LedgerVersion;\n}): Promise<MoveValue[]> {\n  const { aptosConfig, payload, options } = args;\n  const { data } = await postAptosFullNode<ViewRequest, MoveValue[]>({\n    aptosConfig,\n    originMethod: \"view\",\n    path: \"view\",\n    params: { ledger_version: options?.ledgerVersion },\n    body: {\n      function: payload.function,\n      type_arguments: payload.typeArguments ?? [],\n      arguments: payload.functionArguments ?? [],\n    },\n  });\n  return data;\n}\n\nexport async function getChainTopUserTransactions(args: {\n  aptosConfig: AptosConfig;\n  limit: number;\n}): Promise<GetChainTopUserTransactionsResponse> {\n  const { aptosConfig, limit } = args;\n  const graphqlQuery = {\n    query: GetChainTopUserTransactions,\n    variables: { limit },\n  };\n\n  const data = await queryIndexer<GetChainTopUserTransactionsQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getChainTopUserTransactions\",\n  });\n\n  return data.user_transactions;\n}\n\nexport async function queryIndexer<T>(args: {\n  aptosConfig: AptosConfig;\n  query: GraphqlQuery;\n  originMethod?: string;\n}): Promise<T> {\n  const { aptosConfig, query, originMethod } = args;\n  const { data } = await postAptosIndexer<GraphqlQuery, T>({\n    aptosConfig,\n    originMethod: originMethod ?? \"queryIndexer\",\n    path: \"\",\n    body: query,\n    overrides: { WITH_CREDENTIALS: false },\n  });\n  return data;\n}\n\nexport async function getProcessorStatuses(args: { aptosConfig: AptosConfig }): Promise<GetProcessorStatusResponse> {\n  const { aptosConfig } = args;\n\n  const graphqlQuery = {\n    query: GetProcessorStatus,\n  };\n\n  const data = await queryIndexer<GetProcessorStatusQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getProcessorStatuses\",\n  });\n\n  return data.processor_status;\n}\n\nexport async function getIndexerLastSuccessVersion(args: { aptosConfig: AptosConfig }): Promise<number> {\n  const response = await getProcessorStatuses({ aptosConfig: args.aptosConfig });\n  return response[0].last_success_version;\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * The global cache Map shared across all functions.  Must keep care to ensure that the\n * cache keys are unique across all functions.\n */\nconst cache = new Map<string, { value: any; timestamp: number }>();\n\n/**\n * A memoize high order function to cache async function response\n *\n * @param func An async function to cache the result of\n * @param key The provided cache key\n * @param ttlMs time-to-live in milliseconds for cached data\n * @returns the cached or latest result\n */\nexport function memoizeAsync<T>(\n  func: (...args: any[]) => Promise<T>,\n  key: string,\n  ttlMs?: number,\n): (...args: any[]) => Promise<T> {\n  return async (...args: any[]) => {\n    // Check if the cached result exists and is within TTL\n    if (cache.has(key)) {\n      const { value, timestamp } = cache.get(key)!;\n      if (ttlMs === undefined || Date.now() - timestamp <= ttlMs) {\n        return value;\n      }\n    }\n\n    // If not cached or TTL expired, compute the result\n    const result = await func(...args);\n\n    // Cache the result with a timestamp\n    cache.set(key, { value: result, timestamp: Date.now() });\n\n    return result;\n  };\n}\n\n/**\n * A memoize high order function to cache function response\n *\n * @param func A function to cache the result of\n * @param key The provided cache key\n * @param ttlMs time-to-live in milliseconds for cached data\n * @returns the cached or latest result\n */\nexport function memoize<T>(func: (...args: any[]) => T, key: string, ttlMs?: number): (...args: any[]) => T {\n  return (...args: any[]) => {\n    // Check if the cached result exists and is within TTL\n    if (cache.has(key)) {\n      const { value, timestamp } = cache.get(key)!;\n      if (ttlMs === undefined || Date.now() - timestamp <= ttlMs) {\n        return value;\n      }\n    }\n\n    // If not cached or TTL expired, compute the result\n    const result = func(...args);\n\n    // Cache the result with a timestamp\n    cache.set(key, { value: result, timestamp: Date.now() });\n\n    return result;\n  };\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/account}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * account namespace and without having a dependency cycle error.\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { AptosApiError, getAptosFullNode, paginateWithCursor } from \"../client\";\nimport { AccountAddress } from \"../core/accountAddress\";\nimport { Account } from \"../core/account\";\nimport { PrivateKey } from \"../core/crypto/asymmetricCrypto\";\nimport { Hex } from \"../core/hex\";\nimport { getTableItem, queryIndexer } from \"./general\";\nimport {\n  AccountData,\n  GetAccountCoinsDataResponse,\n  GetAccountCollectionsWithOwnedTokenResponse,\n  GetAccountOwnedObjectsResponse,\n  GetAccountOwnedTokensFromCollectionResponse,\n  GetAccountOwnedTokensQueryResponse,\n  HexInput,\n  LedgerVersion,\n  MoveModuleBytecode,\n  MoveResource,\n  MoveStructType,\n  OrderBy,\n  PaginationArgs,\n  SigningScheme,\n  TokenStandard,\n  TransactionResponse,\n} from \"../types\";\nimport {\n  GetAccountCoinsCountQuery,\n  GetAccountCoinsDataQuery,\n  GetAccountCollectionsWithOwnedTokensQuery,\n  GetAccountOwnedObjectsQuery,\n  GetAccountOwnedTokensFromCollectionQuery,\n  GetAccountOwnedTokensQuery,\n  GetAccountTokensCountQuery,\n  GetAccountTransactionsCountQuery,\n} from \"../types/generated/operations\";\nimport {\n  GetAccountCoinsCount,\n  GetAccountCoinsData,\n  GetAccountCollectionsWithOwnedTokens,\n  GetAccountOwnedObjects,\n  GetAccountOwnedTokens,\n  GetAccountOwnedTokensFromCollection,\n  GetAccountTokensCount,\n  GetAccountTransactionsCount,\n} from \"../types/generated/queries\";\nimport { memoizeAsync } from \"../utils/memoize\";\nimport { Secp256k1PrivateKey, AuthenticationKey, Ed25519PrivateKey } from \"../core\";\nimport { AnyPublicKey } from \"../core/crypto/anyPublicKey\";\n\nexport async function getInfo(args: { aptosConfig: AptosConfig; accountAddress: HexInput }): Promise<AccountData> {\n  const { aptosConfig, accountAddress } = args;\n  const { data } = await getAptosFullNode<{}, AccountData>({\n    aptosConfig,\n    originMethod: \"getInfo\",\n    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}`,\n  });\n  return data;\n}\n\nexport async function getModules(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: HexInput;\n  options?: PaginationArgs & LedgerVersion;\n}): Promise<MoveModuleBytecode[]> {\n  const { aptosConfig, accountAddress, options } = args;\n  return paginateWithCursor<{}, MoveModuleBytecode[]>({\n    aptosConfig,\n    originMethod: \"getModules\",\n    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}/modules`,\n    params: {\n      ledger_version: options?.ledgerVersion,\n      start: options?.offset,\n      limit: options?.limit ?? 1000,\n    },\n  });\n}\n\n/**\n * Queries for a move module given account address and module name\n *\n * @param args.accountAddress Hex-encoded 32 byte Aptos account address\n * @param args.moduleName The name of the module\n * @param args.query.ledgerVersion Specifies ledger version of transactions. By default, latest version will be used\n * @returns The move module.\n */\nexport async function getModule(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: HexInput;\n  moduleName: string;\n  options?: LedgerVersion;\n}): Promise<MoveModuleBytecode> {\n  // We don't memoize the account module by ledger version, as it's not a common use case, this would be handled\n  // by the developer directly\n  if (args.options?.ledgerVersion !== undefined) {\n    return getModuleInner(args);\n  }\n\n  return memoizeAsync(\n    async () => getModuleInner(args),\n    `module-${args.accountAddress}-${args.moduleName}`,\n    1000 * 60 * 5, // 5 minutes\n  )();\n}\n\nasync function getModuleInner(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: HexInput;\n  moduleName: string;\n  options?: LedgerVersion;\n}): Promise<MoveModuleBytecode> {\n  const { aptosConfig, accountAddress, moduleName, options } = args;\n\n  const { data } = await getAptosFullNode<{}, MoveModuleBytecode>({\n    aptosConfig,\n    originMethod: \"getModule\",\n    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}/module/${moduleName}`,\n    params: { ledger_version: options?.ledgerVersion },\n  });\n  return data;\n}\n\nexport async function getTransactions(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: HexInput;\n  options?: PaginationArgs;\n}): Promise<TransactionResponse[]> {\n  const { aptosConfig, accountAddress, options } = args;\n  return paginateWithCursor<{}, TransactionResponse[]>({\n    aptosConfig,\n    originMethod: \"getTransactions\",\n    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}/transactions`,\n    params: { start: options?.offset, limit: options?.limit },\n  });\n}\n\nexport async function getResources(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: HexInput;\n  options?: PaginationArgs & LedgerVersion;\n}): Promise<MoveResource[]> {\n  const { aptosConfig, accountAddress, options } = args;\n  return paginateWithCursor<{}, MoveResource[]>({\n    aptosConfig,\n    originMethod: \"getResources\",\n    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}/resources`,\n    params: {\n      ledger_version: options?.ledgerVersion,\n      start: options?.offset,\n      limit: options?.limit ?? 999,\n    },\n  });\n}\n\nexport async function getResource<T extends {}>(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: HexInput;\n  resourceType: MoveStructType;\n  options?: LedgerVersion;\n}): Promise<T> {\n  const { aptosConfig, accountAddress, resourceType, options } = args;\n  const { data } = await getAptosFullNode<{}, MoveResource>({\n    aptosConfig,\n    originMethod: \"getResource\",\n    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}/resource/${resourceType}`,\n    params: { ledger_version: options?.ledgerVersion },\n  });\n  return data.data as T;\n}\n\nexport async function lookupOriginalAccountAddress(args: {\n  aptosConfig: AptosConfig;\n  authenticationKey: HexInput;\n  options?: LedgerVersion;\n}): Promise<AccountAddress> {\n  const { aptosConfig, authenticationKey, options } = args;\n  type OriginatingAddress = {\n    address_map: { handle: string };\n  };\n  const resource = await getResource<OriginatingAddress>({\n    aptosConfig,\n    accountAddress: \"0x1\",\n    resourceType: \"0x1::account::OriginatingAddress\",\n    options,\n  });\n\n  const {\n    address_map: { handle },\n  } = resource;\n\n  // If the address is not found in the address map, which means its not rotated\n  // then return the address as is\n  try {\n    const originalAddress = await getTableItem({\n      aptosConfig,\n      handle,\n      data: {\n        key: Hex.fromHexInput(authenticationKey).toString(),\n        key_type: \"address\",\n        value_type: \"address\",\n      },\n      options,\n    });\n\n    return AccountAddress.fromHexInput(originalAddress);\n  } catch (err) {\n    if (err instanceof AptosApiError && err.data.error_code === \"table_item_not_found\") {\n      return AccountAddress.fromHexInput(authenticationKey);\n    }\n\n    throw err;\n  }\n}\n\nexport async function getAccountTokensCount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: HexInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress } = args;\n\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n\n  const whereCondition: any = {\n    owner_address: { _eq: address },\n    amount: { _gt: \"0\" },\n  };\n\n  const graphqlQuery = {\n    query: GetAccountTokensCount,\n    variables: { where_condition: whereCondition },\n  };\n\n  const data = await queryIndexer<GetAccountTokensCountQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountTokensCount\",\n  });\n  if (!data.current_token_ownerships_v2_aggregate.aggregate) {\n    throw Error(\"Failed to get the count of account tokens\");\n  }\n  return data.current_token_ownerships_v2_aggregate.aggregate.count;\n}\n\nexport async function getAccountOwnedTokens(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: HexInput;\n  options?: {\n    tokenStandard?: TokenStandard;\n    pagination?: PaginationArgs;\n    orderBy?: OrderBy<GetAccountOwnedTokensQueryResponse[0]>;\n  };\n}): Promise<GetAccountOwnedTokensQueryResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n\n  const whereCondition: any = {\n    owner_address: { _eq: address },\n    amount: { _gt: 0 },\n  };\n\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard };\n  }\n\n  const graphqlQuery = {\n    query: GetAccountOwnedTokens,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.pagination?.offset,\n      limit: options?.pagination?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountOwnedTokensQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedTokens\",\n  });\n\n  return data.current_token_ownerships_v2;\n}\n\nexport async function getAccountOwnedTokensFromCollectionAddress(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: HexInput;\n  collectionAddress: HexInput;\n  options?: {\n    tokenStandard?: TokenStandard;\n    pagination?: PaginationArgs;\n    orderBy?: OrderBy<GetAccountOwnedTokensFromCollectionResponse[0]>;\n  };\n}): Promise<GetAccountOwnedTokensFromCollectionResponse> {\n  const { aptosConfig, accountAddress, collectionAddress, options } = args;\n  const ownerAddress = AccountAddress.fromHexInput(accountAddress).toString();\n  const collAddress = Hex.fromHexInput(collectionAddress).toString();\n\n  const whereCondition: any = {\n    owner_address: { _eq: ownerAddress },\n    current_token_data: { collection_id: { _eq: collAddress } },\n    amount: { _gt: 0 },\n  };\n\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard };\n  }\n\n  const graphqlQuery = {\n    query: GetAccountOwnedTokensFromCollection,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.pagination?.offset,\n      limit: options?.pagination?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountOwnedTokensFromCollectionQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedTokensFromCollectionAddress\",\n  });\n\n  return data.current_token_ownerships_v2;\n}\n\nexport async function getAccountCollectionsWithOwnedTokens(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: HexInput;\n  options?: {\n    tokenStandard?: TokenStandard;\n    pagination?: PaginationArgs;\n    orderBy?: OrderBy<GetAccountCollectionsWithOwnedTokenResponse[0]>;\n  };\n}): Promise<GetAccountCollectionsWithOwnedTokenResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n\n  const whereCondition: any = {\n    owner_address: { _eq: address },\n    amount: { _gt: 0 },\n  };\n\n  if (options?.tokenStandard) {\n    whereCondition.current_collection = {\n      token_standard: { _eq: options?.tokenStandard },\n    };\n  }\n\n  const graphqlQuery = {\n    query: GetAccountCollectionsWithOwnedTokens,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.pagination?.offset,\n      limit: options?.pagination?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountCollectionsWithOwnedTokensQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCollectionsWithOwnedTokens\",\n  });\n\n  return data.current_collection_ownership_v2_view;\n}\n\nexport async function getAccountTransactionsCount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: HexInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress } = args;\n\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n\n  const graphqlQuery = {\n    query: GetAccountTransactionsCount,\n    variables: { address },\n  };\n\n  const data = await queryIndexer<GetAccountTransactionsCountQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountTransactionsCount\",\n  });\n\n  if (!data.account_transactions_aggregate.aggregate) {\n    throw Error(\"Failed to get the count of account transactions\");\n  }\n\n  return data.account_transactions_aggregate.aggregate.count;\n}\n\nexport async function getAccountCoinsData(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: HexInput;\n  options?: {\n    pagination?: PaginationArgs;\n    orderBy?: OrderBy<GetAccountCoinsDataResponse[0]>;\n  };\n}): Promise<GetAccountCoinsDataResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n\n  const whereCondition: any = {\n    owner_address: { _eq: address },\n  };\n\n  const graphqlQuery = {\n    query: GetAccountCoinsData,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.pagination?.offset,\n      limit: options?.pagination?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetAccountCoinsDataQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCoinsData\",\n  });\n\n  return data.current_fungible_asset_balances;\n}\n\nexport async function getAccountCoinsCount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: HexInput;\n}): Promise<number> {\n  const { aptosConfig, accountAddress } = args;\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n\n  const graphqlQuery = {\n    query: GetAccountCoinsCount,\n    variables: { address },\n  };\n\n  const data = await queryIndexer<GetAccountCoinsCountQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCoinsCount\",\n  });\n\n  if (!data.current_fungible_asset_balances_aggregate.aggregate) {\n    throw Error(\"Failed to get the count of account coins\");\n  }\n\n  return data.current_fungible_asset_balances_aggregate.aggregate.count;\n}\n\nexport async function getAccountOwnedObjects(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: HexInput;\n  options?: {\n    pagination?: PaginationArgs;\n    orderBy?: OrderBy<GetAccountOwnedObjectsResponse[0]>;\n  };\n}): Promise<GetAccountOwnedObjectsResponse> {\n  const { aptosConfig, accountAddress, options } = args;\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n\n  const whereCondition: any = {\n    owner_address: { _eq: address },\n  };\n  const graphqlQuery = {\n    query: GetAccountOwnedObjects,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.pagination?.offset,\n      limit: options?.pagination?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n  const data = await queryIndexer<GetAccountOwnedObjectsQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedObjects\",\n  });\n\n  return data.current_objects;\n}\n\nexport async function deriveAccountFromPrivateKey(args: {\n  aptosConfig: AptosConfig;\n  privateKey: PrivateKey;\n}): Promise<Account> {\n  const { aptosConfig, privateKey } = args;\n  const publicKey = new AnyPublicKey(privateKey.publicKey());\n\n  if (privateKey instanceof Secp256k1PrivateKey) {\n    // private key is secp256k1, therefore we know it for sure uses a single signer key\n    const authKey = AuthenticationKey.fromPublicKeyAndScheme({ publicKey, scheme: SigningScheme.SingleKey });\n    const address = new AccountAddress({ data: authKey.toUint8Array() });\n    return Account.fromPrivateKeyAndAddress({ privateKey, address });\n  }\n\n  if (privateKey instanceof Ed25519PrivateKey) {\n    // lookup single sender ed25519\n    const SingleSenderTransactionAuthenticatorAuthKey = AuthenticationKey.fromPublicKeyAndScheme({\n      publicKey,\n      scheme: SigningScheme.SingleKey,\n    });\n    const isSingleSenderTransactionAuthenticator = await isAccountExist({\n      authKey: SingleSenderTransactionAuthenticatorAuthKey,\n      aptosConfig,\n    });\n    if (isSingleSenderTransactionAuthenticator) {\n      const address = new AccountAddress({ data: SingleSenderTransactionAuthenticatorAuthKey.toUint8Array() });\n      return Account.fromPrivateKeyAndAddress({ privateKey, address });\n    }\n    // lookup legacy ed25519\n    const legacyAuthKey = AuthenticationKey.fromPublicKeyAndScheme({ publicKey, scheme: SigningScheme.Ed25519 });\n    const isLegacyEd25519 = await isAccountExist({ authKey: legacyAuthKey, aptosConfig });\n    if (isLegacyEd25519) {\n      const address = new AccountAddress({ data: legacyAuthKey.toUint8Array() });\n      return Account.fromPrivateKeyAndAddress({ privateKey, address, legacy: true });\n    }\n  }\n  // if we are here, it means we couldn't find an address with an\n  // auth key that matches the provided private key\n  throw new Error(`Can't derive account from private key ${privateKey}`);\n}\n\nexport async function isAccountExist(args: { aptosConfig: AptosConfig; authKey: AuthenticationKey }): Promise<boolean> {\n  const { aptosConfig, authKey } = args;\n  const accountAddress = await lookupOriginalAccountAddress({\n    aptosConfig,\n    authenticationKey: authKey.toString(),\n  });\n\n  try {\n    await getInfo({\n      aptosConfig,\n      accountAddress: accountAddress.toString(),\n    });\n    return true;\n  } catch (error: any) {\n    // account not found\n    if (error.status === 404) {\n      return false;\n    }\n    throw new Error(`Error while looking for an account info ${accountAddress.toString()}`);\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AptosConfig } from \"./aptosConfig\";\nimport { AccountAddress, PrivateKey, Account as AccountModule } from \"../core\";\nimport {\n  AccountData,\n  GetAccountCoinsDataResponse,\n  GetAccountCollectionsWithOwnedTokenResponse,\n  GetAccountOwnedObjectsResponse,\n  GetAccountOwnedTokensFromCollectionResponse,\n  GetAccountOwnedTokensQueryResponse,\n  HexInput,\n  LedgerVersion,\n  MoveModuleBytecode,\n  MoveResource,\n  MoveStructType,\n  OrderBy,\n  PaginationArgs,\n  TokenStandard,\n  TransactionResponse,\n} from \"../types\";\nimport {\n  deriveAccountFromPrivateKey,\n  getAccountCoinsCount,\n  getAccountCoinsData,\n  getAccountCollectionsWithOwnedTokens,\n  getAccountOwnedObjects,\n  getAccountOwnedTokens,\n  getAccountOwnedTokensFromCollectionAddress,\n  getAccountTokensCount,\n  getAccountTransactionsCount,\n  getInfo,\n  getModule,\n  getModules,\n  getResource,\n  getResources,\n  getTransactions,\n  lookupOriginalAccountAddress,\n} from \"../internal/account\";\n\n/**\n * A class to query all `Account` related queries on Aptos.\n */\nexport class Account {\n  readonly config: AptosConfig;\n\n  constructor(config: AptosConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Queries the current state for an Aptos account given its account address\n   *\n   * @param args.accountAddress Aptos account address\n   *\n   * @returns The account data\n   *\n   * @example An example of the returned account\n   * ```\n   * {\n   *    sequence_number: \"1\",\n   *    authentication_key: \"0x5307b5f4bc67829097a8ba9b43dba3b88261eeccd1f709d9bde240fc100fbb69\"\n   * }\n   * ```\n   */\n  async getAccountInfo(args: { accountAddress: HexInput }): Promise<AccountData> {\n    return getInfo({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries for all modules in an account given an account address\n   *\n   * Note: In order to get all account modules, this function may call the API\n   * multiple times as it auto paginates.\n   *\n   * @param args.accountAddress Aptos account address\n   * @param args.options.offset The number module to start returning results from\n   * @param args.options.limit The number of results to return\n   * @param args.options.ledgerVersion The ledger version to query, if not provided it will get the latest version\n   *\n   * @returns Account modules\n   */\n\n  async getAccountModules(args: {\n    accountAddress: HexInput;\n    options?: PaginationArgs & LedgerVersion;\n  }): Promise<MoveModuleBytecode[]> {\n    return getModules({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries for a specific account module given account address and module name\n   *\n   * @param args.accountAddress Aptos account address\n   * @param args.moduleName The name of the module\n   * @param args.options.ledgerVersion The ledger version to query, if not provided it will get the latest version\n   *\n   * @returns Account module\n   *\n   * @example An example of an account module\n   * ```\n   * {\n   *    bytecode: \"0xa11ceb0b0600000006010002030206050807070f0d081c200\",\n   *    abi: { address: \"0x1\" }\n   * }\n   * ```\n   */\n  async getAccountModule(args: {\n    accountAddress: HexInput;\n    moduleName: string;\n    options?: LedgerVersion;\n  }): Promise<MoveModuleBytecode> {\n    return getModule({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries account transactions given an account address\n   *\n   * Note: In order to get all account transactions, this function may call the API\n   * multiple times as it auto paginates.\n   *\n   * @param args.accountAddress Aptos account address\n   * @param args.options.offset The number transaction to start returning results from\n   * @param args.options.limit The number of results to return\n   *\n   * @returns The account transactions\n   */\n  async getAccountTransactions(args: {\n    accountAddress: HexInput;\n    options?: PaginationArgs;\n  }): Promise<TransactionResponse[]> {\n    return getTransactions({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries all account resources given an account address\n   *\n   * Note: In order to get all account resources, this function may call the API\n   * multiple times as it auto paginates.\n   *\n   * @param args.accountAddress Aptos account address\n   * @param args.options.offset The number resource to start returning results from\n   * @param args.options.limit The number of results to return\n   * @param args.options.ledgerVersion The ledger version to query, if not provided it will get the latest version\n   * @returns Account resources\n   */\n  async getAccountResources(args: {\n    accountAddress: HexInput;\n    options?: PaginationArgs & LedgerVersion;\n  }): Promise<MoveResource[]> {\n    return getResources({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries a specific account resource given account address and resource type. Note that the default is `any` in order\n   * to allow for ease of accessing properties of the object.\n   *\n   * @type The typed output of the resource\n   * @param args.accountAddress Aptos account address\n   * @param args.resourceType String representation of an on-chain Move struct type, i.e \"0x1::aptos_coin::AptosCoin\"\n   * @param args.options.ledgerVersion The ledger version to query, if not provided it will get the latest version\n   *\n   * @returns Account resource\n   *\n   * @example An example of an account resource\n   * ```\n   * {\n   *    data: { value: 6 }\n   * }\n   * ```\n   */\n  async getAccountResource<T extends {} = any>(args: {\n    accountAddress: HexInput;\n    resourceType: MoveStructType;\n    options?: LedgerVersion;\n  }): Promise<T> {\n    return getResource<T>({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Looks up the account address for a given authentication key\n   *\n   * This handles both if the account's authentication key has been rotated or not.\n   *\n   * @param args.authenticationKey The authentication key\n   * @param args.options.ledgerVersion The ledger version to query, if not provided it will get the latest version\n   * @returns Promise<AccountAddress> The accountAddress associated with the authentication key\n   */\n  async lookupOriginalAccountAddress(args: {\n    authenticationKey: HexInput;\n    options?: LedgerVersion;\n  }): Promise<AccountAddress> {\n    return lookupOriginalAccountAddress({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries the current count of tokens owned by an account\n   *\n   * @param args.accountAddress The account address\n   * @returns Current count of tokens owned by the account\n   */\n  async getAccountTokensCount(args: { accountAddress: HexInput }): Promise<number> {\n    return getAccountTokensCount({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries the account's current owned tokens.\n   *\n   * This query returns all tokens (v1 and v2 standards) an account owns, including NFTs, fungible, soulbound, etc.\n   * If you want to get only the token from a specific standard, you can pass an optional tokenStandard param\n   *\n   * @param args.accountAddress The account address we want to get the tokens for\n   * @param args.options.tokenStandard The NFT standard to query for\n   * @param args.options.pagination.offset The number token to start returning results from\n   * @param args.options.pagination.limit The number of results to return\n   * @param args.options.orderBy The order to sort the tokens by\n   * @returns Tokens array with the token data\n   */\n  async getAccountOwnedTokens(args: {\n    accountAddress: HexInput;\n    options?: {\n      tokenStandard?: TokenStandard;\n      pagination?: PaginationArgs;\n      orderBy?: OrderBy<GetAccountOwnedTokensQueryResponse[0]>;\n    };\n  }): Promise<GetAccountOwnedTokensQueryResponse> {\n    return getAccountOwnedTokens({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries all current tokens of a specific collection that an account owns by the collection address\n   *\n   * This query returns all tokens (v1 and v2 standards) an account owns, including NFTs, fungible, soulbound, etc.\n   * If you want to get only the token from a specific standard, you can pass an optional tokenStandard param\n   *\n   * @param args.accountAddress The account address we want to get the tokens for\n   * @param args.collectionAddress The address of the collection being queried\n   * @param args.options.tokenStandard The NFT standard to query for\n   * @param args.options.pagination.offset The number token to start returning results from\n   * @param args.options.pagination.limit The number of results to return\n   * @param args.options.orderBy The order to sort the tokens by\n   * @returns Tokens array with the token data\n   */\n  async getAccountOwnedTokensFromCollectionAddress(args: {\n    accountAddress: HexInput;\n    collectionAddress: HexInput;\n    options?: {\n      tokenStandard?: TokenStandard;\n      pagination?: PaginationArgs;\n      orderBy?: OrderBy<GetAccountOwnedTokensFromCollectionResponse[0]>;\n    };\n  }): Promise<GetAccountOwnedTokensFromCollectionResponse> {\n    return getAccountOwnedTokensFromCollectionAddress({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries for all collections that an account currently has tokens for.\n   *\n   * This query returns all tokens (v1 and v2 standards) an account owns, including NFTs, fungible, soulbound, etc.\n   * If you want to get only the token from a specific standard, you can pass an optional tokenStandard param\n   *\n   * @param args.accountAddress The account address we want to get the collections for\n   * @param args.options.tokenStandard The NFT standard to query for\n   * @param args.options.pagination.offset The number collection to start returning results from\n   * @param args.options.pagination.limit The number of results to return\n   * @param args.options.orderBy The order to sort the tokens by\n   * @returns Collections array with the collections data\n   */\n  async getAccountCollectionsWithOwnedTokens(args: {\n    accountAddress: HexInput;\n    options?: {\n      tokenStandard?: TokenStandard;\n      pagination?: PaginationArgs;\n      orderBy?: OrderBy<GetAccountCollectionsWithOwnedTokenResponse[0]>;\n    };\n  }): Promise<GetAccountCollectionsWithOwnedTokenResponse> {\n    return getAccountCollectionsWithOwnedTokens({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries the current count of transactions submitted by an account\n   *\n   * @param args.accountAddress The account address we want to get the total count for\n   * @returns Current count of transactions made by an account\n   */\n  async getAccountTransactionsCount(args: { accountAddress: HexInput }): Promise<number> {\n    return getAccountTransactionsCount({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries an account's coins data\n   *\n   * @param args.accountAddress The account address we want to get the coins data for\n   * @param args.options.pagination.offset The number coin to start returning results from\n   * @param args.options.pagination.limit The number of results to return\n   * @param args.options.orderBy The order to sort the coins by\n   * @returns Array with the coins data\n   */\n  async getAccountCoinsData(args: {\n    accountAddress: HexInput;\n    options?: {\n      pagination?: PaginationArgs;\n      orderBy?: OrderBy<GetAccountCoinsDataResponse[0]>;\n    };\n  }): Promise<GetAccountCoinsDataResponse> {\n    return getAccountCoinsData({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries the current count of an account's coins aggregated\n   *\n   * @param args.accountAddress The account address we want to get the total count for\n   * @returns Current count of the aggregated count of all account's coins\n   */\n  async getAccountCoinsCount(args: { accountAddress: HexInput }): Promise<number> {\n    return getAccountCoinsCount({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries an account's owned objects\n   *\n   * @param args.accountAddress The account address we want to get the objects for\n   * @param args.options.pagination.offset The number coin to start returning results from\n   * @param args.options.pagination.limit The number of results to return\n   * @param args.options.orderBy The order to sort the coins by\n   * @returns Objects array with the object data\n   */\n  async getAccountOwnedObjects(args: {\n    accountAddress: HexInput;\n    options?: {\n      pagination?: PaginationArgs;\n      orderBy?: OrderBy<GetAccountOwnedObjectsResponse[0]>;\n    };\n  }): Promise<GetAccountOwnedObjectsResponse> {\n    return getAccountOwnedObjects({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Derives an account by providing a private key.\n   * This functions resolves the provided private key type and derives the public key from it.\n   *\n   * If the privateKey is a Secp256k1 type, it derives the account using the derived public key and\n   * auth key using the SingleKey scheme locally.\n   *\n   * If the privateKey is a ED25519 type, it looks up the authentication key on chain, and uses it to resolve\n   * whether it is a Legacy ED25519 key or a Unified ED25519 key. It then derives the account based\n   * on that.\n   *\n   * @param args.privateKey An account private key\n   * @returns Account type\n   */\n  async deriveAccountFromPrivateKey(args: { privateKey: PrivateKey }): Promise<AccountModule> {\n    return deriveAccountFromPrivateKey({ aptosConfig: this.config, ...args });\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport aptosClient from \"@aptos-labs/aptos-client\";\nimport { AptosSettings, ClientConfig, Client } from \"../types\";\nimport { NetworkToNodeAPI, NetworkToFaucetAPI, NetworkToIndexerAPI, Network } from \"../utils/apiEndpoints\";\nimport { AptosApiType, DEFAULT_NETWORK } from \"../utils/const\";\n\n/**\n * This class holds the config information for the SDK client instance.\n */\nexport class AptosConfig {\n  /** The Network that this SDK is associated with. */\n  readonly network: Network;\n\n  /**\n   * The client instance the SDK uses\n   */\n  readonly client: Client;\n\n  /**\n   * The optional hardcoded fullnode URL to send requests to instead of using the network\n   */\n  readonly fullnode?: string;\n\n  /**\n   * The optional hardcoded faucet URL to send requests to instead of using the network\n   */\n  readonly faucet?: string;\n\n  /**\n   * The optional hardcoded indexer URL to send requests to instead of using the network\n   */\n  readonly indexer?: string;\n\n  readonly clientConfig?: ClientConfig;\n\n  constructor(settings?: AptosSettings) {\n    this.network = settings?.network ?? DEFAULT_NETWORK;\n    this.fullnode = settings?.fullnode;\n    this.faucet = settings?.faucet;\n    this.indexer = settings?.indexer;\n    this.client = settings?.client ?? { provider: aptosClient };\n    this.clientConfig = settings?.clientConfig ?? {};\n  }\n\n  /**\n   * Returns the URL endpoint to send the request to.\n   * If a custom URL was provided in the config, that URL is returned.\n   * If a custom URL was provided but not URL endpoints, an error is thrown.\n   * Otherwise, the URL endpoint is derived from the network.\n   *\n   * @param apiType - The type of Aptos API to get the URL for.\n   *\n   * @internal\n   */\n  getRequestUrl(apiType: AptosApiType): string {\n    switch (apiType) {\n      case AptosApiType.FULLNODE:\n        if (this.fullnode !== undefined) return this.fullnode;\n        if (this.network === Network.CUSTOM) throw new Error(\"Please provide a custom full node url\");\n        return NetworkToNodeAPI[this.network];\n      case AptosApiType.FAUCET:\n        if (this.faucet !== undefined) return this.faucet;\n        if (this.network === Network.CUSTOM) throw new Error(\"Please provide a custom faucet url\");\n        return NetworkToFaucetAPI[this.network];\n      case AptosApiType.INDEXER:\n        if (this.indexer !== undefined) return this.indexer;\n        if (this.network === Network.CUSTOM) throw new Error(\"Please provide a custom indexer url\");\n        return NetworkToIndexerAPI[this.network];\n      default:\n        throw Error(`apiType ${apiType} is not supported`);\n    }\n  }\n\n  /**\n   * Checks if the URL is a known indexer endpoint\n   *\n   * @internal\n   * */\n  isIndexerRequest(url: string): boolean {\n    return NetworkToIndexerAPI[this.network] === url;\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file handles the transaction creation lifecycle.\n * It holds different operations to generate a transaction payload, a raw transaction,\n * and a signed transaction that can be simulated, signed and submitted to chain.\n */\nimport { sha3_256 as sha3Hash } from \"@noble/hashes/sha3\";\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { AccountAddress, Hex, PublicKey } from \"../../core\";\nimport { Account } from \"../../core/account\";\nimport { AnyPublicKey } from \"../../core/crypto/anyPublicKey\";\nimport { AnySignature } from \"../../core/crypto/anySignature\";\nimport { Ed25519PublicKey, Ed25519Signature } from \"../../core/crypto/ed25519\";\nimport { Secp256k1PublicKey, Secp256k1Signature } from \"../../core/crypto/secp256k1\";\nimport { getInfo } from \"../../internal/account\";\nimport { getLedgerInfo } from \"../../internal/general\";\nimport { getGasPriceEstimation } from \"../../internal/transaction\";\nimport { NetworkToChainId } from \"../../utils/apiEndpoints\";\nimport {\n  DEFAULT_MAX_GAS_AMOUNT,\n  DEFAULT_TXN_EXP_SEC_FROM_NOW,\n  RAW_TRANSACTION_SALT,\n  RAW_TRANSACTION_WITH_DATA_SALT,\n} from \"../../utils/const\";\nimport {\n  AccountAuthenticator,\n  AccountAuthenticatorEd25519,\n  AccountAuthenticatorMultiKey,\n  AccountAuthenticatorSingleKey,\n} from \"../authenticator/account\";\nimport {\n  TransactionAuthenticatorEd25519,\n  TransactionAuthenticatorFeePayer,\n  TransactionAuthenticatorMultiAgent,\n  TransactionAuthenticatorSingleSender,\n} from \"../authenticator/transaction\";\nimport {\n  ChainId,\n  EntryFunction,\n  FeePayerRawTransaction,\n  MultiAgentRawTransaction,\n  MultiSig,\n  MultisigTransactionPayload,\n  RawTransaction,\n  Script,\n  TransactionPayloadEntryFunction,\n  TransactionPayloadMultisig,\n  TransactionPayloadScript,\n} from \"../instances\";\nimport { SignedTransaction } from \"../instances/signedTransaction\";\nimport {\n  InputGenerateTransactionOptions,\n  AnyTransactionPayloadInstance,\n  AnyRawTransactionInstance,\n  InputGenerateFeePayerRawTransactionArgs,\n  InputGenerateMultiAgentRawTransactionArgs,\n  InputGenerateRawTransactionArgs,\n  InputGenerateSingleSignerRawTransactionArgs,\n  InputSingleSignerTransaction,\n  AnyRawTransaction,\n  InputFeePayerTransaction,\n  InputMultiAgentTransaction,\n  InputScriptData,\n  InputSimulateTransactionData,\n  EntryFunctionArgumentTypes,\n  EntryFunctionABI,\n  InputGenerateTransactionPayloadData,\n  InputEntryFunctionData,\n  InputMultiSigData,\n  InputMultiSigDataWithRemoteABI,\n  InputEntryFunctionDataWithRemoteABI,\n  InputGenerateTransactionPayloadDataWithRemoteABI,\n} from \"../types\";\nimport { convertArgument, fetchEntryFunctionAbi, standardizeTypeTags } from \"./remoteAbi\";\nimport { memoizeAsync } from \"../../utils/memoize\";\nimport { HexInput, SigningScheme } from \"../../types\";\nimport { getFunctionParts, isScriptDataInput } from \"./helpers\";\n\n/**\n * We are defining function signatures, each with its specific input and output.\n * These are the possible function signature for our `generateTransactionPayload` function.\n * When we call our `generateTransactionPayload` function with the relevant type properties,\n * Typescript can infer the return type based on the appropriate function overload.\n */\nexport async function generateTransactionPayload(\n  args: InputScriptData & { aptosConfig?: undefined },\n): Promise<TransactionPayloadScript>;\nexport async function generateTransactionPayload(\n  args: InputEntryFunctionDataWithRemoteABI,\n): Promise<TransactionPayloadEntryFunction>;\nexport async function generateTransactionPayload(\n  args: InputMultiSigDataWithRemoteABI,\n): Promise<TransactionPayloadMultisig>;\nexport async function generateTransactionPayload(\n  args: InputGenerateTransactionPayloadDataWithRemoteABI,\n): Promise<AnyTransactionPayloadInstance>;\n\n/**\n * Builds a transaction payload based on the data argument and returns\n * a transaction payload - TransactionPayloadScript | TransactionPayloadMultisig | TransactionPayloadEntryFunction\n *\n * This uses the RemoteABI by default, and the remote ABI can be skipped by using generateTransactionPayloadWithABI\n *\n * @param args.data GenerateTransactionPayloadData\n *\n * @return TransactionPayload\n */\nexport async function generateTransactionPayload(\n  args: InputGenerateTransactionPayloadDataWithRemoteABI,\n): Promise<AnyTransactionPayloadInstance> {\n  if (isScriptDataInput(args)) {\n    return generateTransactionPayloadScript(args);\n  }\n\n  const { moduleAddress, moduleName, functionName } = getFunctionParts(args.function);\n\n  // We fetch the entry function ABI, and then pretend that we already had the ABI\n  const functionAbi = await memoizeAsync(\n    async () => fetchEntryFunctionAbi(moduleAddress, moduleName, functionName, args.aptosConfig),\n    `entry-function-${args.aptosConfig.network}-${moduleAddress}-${moduleName}-${functionName}`,\n    1000 * 60 * 5, // 5 minutes\n  )();\n\n  return generateTransactionPayloadWithABI(args, functionAbi);\n}\n\nexport function generateTransactionPayloadWithABI(\n  args: InputEntryFunctionData,\n  functionAbi: EntryFunctionABI,\n): TransactionPayloadEntryFunction;\nexport function generateTransactionPayloadWithABI(\n  args: InputMultiSigData,\n  functionAbi: EntryFunctionABI,\n): TransactionPayloadMultisig;\nexport function generateTransactionPayloadWithABI(\n  args: InputGenerateTransactionPayloadData,\n  functionAbi: EntryFunctionABI,\n): AnyTransactionPayloadInstance;\nexport function generateTransactionPayloadWithABI(\n  args: InputGenerateTransactionPayloadData,\n  functionAbi: EntryFunctionABI,\n): AnyTransactionPayloadInstance {\n  if (isScriptDataInput(args)) {\n    return generateTransactionPayloadScript(args);\n  }\n\n  const { moduleAddress, moduleName, functionName } = getFunctionParts(args.function);\n\n  // Ensure that all type arguments are typed properly\n  const typeArguments = standardizeTypeTags(args.typeArguments);\n\n  // Check the type argument count against the ABI\n  if (typeArguments.length !== functionAbi.typeParameters.length) {\n    throw new Error(\n      `Type argument count mismatch, expected ${functionAbi.typeParameters.length}, received ${typeArguments.length}`,\n    );\n  }\n\n  // Check all BCS types, and convert any non-BCS types\n  const functionArguments: Array<EntryFunctionArgumentTypes> = args.functionArguments.map((arg, i) =>\n    convertArgument(args.function, functionAbi, arg, i, typeArguments),\n  );\n\n  // Check that all arguments are accounted for\n  if (functionArguments.length !== functionAbi.parameters.length) {\n    throw new Error(\n      // eslint-disable-next-line max-len\n      `Too few arguments for '${moduleAddress}::${moduleName}::${functionName}', expected ${functionAbi.parameters.length} but got ${functionArguments.length}`,\n    );\n  }\n\n  // Generate entry function payload\n  const entryFunctionPayload = EntryFunction.build(\n    `${moduleAddress}::${moduleName}`,\n    functionName,\n    typeArguments,\n    functionArguments,\n  );\n\n  // Send it as multi sig if it's a multisig payload\n  if (\"multisigAddress\" in args) {\n    let multisigAddress: AccountAddress;\n    if (typeof args.multisigAddress === \"string\") {\n      multisigAddress = AccountAddress.fromString(args.multisigAddress);\n    } else {\n      multisigAddress = args.multisigAddress;\n    }\n    return new TransactionPayloadMultisig(\n      new MultiSig(multisigAddress, new MultisigTransactionPayload(entryFunctionPayload)),\n    );\n  }\n\n  // Otherwise send as an entry function\n  return new TransactionPayloadEntryFunction(entryFunctionPayload);\n}\n\nfunction generateTransactionPayloadScript(args: InputScriptData) {\n  return new TransactionPayloadScript(\n    new Script(Hex.fromHexInput(args.bytecode).toUint8Array(), args.typeArguments ?? [], args.functionArguments),\n  );\n}\n\n/**\n * Generates a raw transaction\n *\n * @param args.aptosConfig AptosConfig\n * @param args.sender The transaction's sender account address as a hex input\n * @param args.payload The transaction payload - can create by using generateTransactionPayload()\n *\n * @returns RawTransaction\n */\nexport async function generateRawTransaction(args: {\n  aptosConfig: AptosConfig;\n  sender: HexInput;\n  payload: AnyTransactionPayloadInstance;\n  options?: InputGenerateTransactionOptions;\n}): Promise<RawTransaction> {\n  const { aptosConfig, sender, payload, options } = args;\n\n  const getSequenceNumber = options?.accountSequenceNumber\n    ? Promise.resolve({ sequence_number: options.accountSequenceNumber })\n    : getInfo({ aptosConfig, accountAddress: sender });\n\n  const getChainId = NetworkToChainId[aptosConfig.network]\n    ? Promise.resolve({ chain_id: NetworkToChainId[aptosConfig.network] })\n    : getLedgerInfo({ aptosConfig });\n\n  const getGasUnitPrice = options?.gasUnitPrice\n    ? Promise.resolve({ gas_estimate: options.gasUnitPrice })\n    : getGasPriceEstimation({ aptosConfig });\n\n  const [{ sequence_number: sequenceNumber }, { chain_id: chainId }, { gas_estimate: gasEstimate }] = await Promise.all(\n    [getSequenceNumber, getChainId, getGasUnitPrice],\n  );\n\n  const { maxGasAmount, gasUnitPrice, expireTimestamp } = {\n    maxGasAmount: BigInt(DEFAULT_MAX_GAS_AMOUNT),\n    gasUnitPrice: BigInt(gasEstimate),\n    expireTimestamp: BigInt(Math.floor(Date.now() / 1000) + DEFAULT_TXN_EXP_SEC_FROM_NOW),\n    ...options,\n  };\n\n  return new RawTransaction(\n    AccountAddress.fromHexInput(sender),\n    BigInt(sequenceNumber),\n    payload,\n    BigInt(maxGasAmount),\n    BigInt(gasUnitPrice),\n    BigInt(expireTimestamp),\n    new ChainId(chainId),\n  );\n}\n\n/**\n * We are defining function signatures, each with its specific input and output.\n * These are the possible function signature for our `generateTransaction` function.\n * When we call our `generateTransaction` function with the relevant type properties,\n * Typescript can infer the return type based on the appropriate function overload.\n */\nexport async function buildTransaction(\n  args: InputGenerateSingleSignerRawTransactionArgs,\n): Promise<InputSingleSignerTransaction>;\nexport async function buildTransaction(\n  args: InputGenerateFeePayerRawTransactionArgs,\n): Promise<InputFeePayerTransaction>;\nexport async function buildTransaction(\n  args: InputGenerateMultiAgentRawTransactionArgs,\n): Promise<InputMultiAgentTransaction>;\nexport async function buildTransaction(args: InputGenerateRawTransactionArgs): Promise<AnyRawTransaction>;\n/**\n * Generates a transaction based on the provided arguments\n *\n * Note: we can start with one function to support all different payload/transaction types,\n * and if to complex to use, we could have function for each type\n *\n * @param args.aptosConfig AptosConfig\n * @param args.sender The transaction's sender account address as a hex input\n * @param args.payload The transaction payload - can create by using generateTransactionPayload()\n * @param args.options optional. Transaction options object\n * @param args.secondarySignerAddresses optional. For when want to create a multi signers transaction\n * @param args.feePayerAddress optional. For when want to create a fee payer (aka sponsored) transaction\n *\n * @return An Aptos raw transaction type (note that it holds the raw transaction as a bcs serialized data)\n * ```\n * {\n *  rawTransaction: Uint8Array,\n *  secondarySignerAddresses? : Array<AccountAddress>,\n *  feePayerAddress?: AccountAddress\n * }\n * ```\n */\nexport async function buildTransaction(args: InputGenerateRawTransactionArgs): Promise<AnyRawTransaction> {\n  const { aptosConfig, sender, payload, options, secondarySignerAddresses, feePayerAddress } = args;\n  // generate raw transaction\n  const rawTxn = await generateRawTransaction({\n    aptosConfig,\n    sender,\n    payload,\n    options,\n  });\n\n  if (feePayerAddress) {\n    const signers: Array<AccountAddress> = secondarySignerAddresses\n      ? secondarySignerAddresses.map((signer) => AccountAddress.fromHexInput(signer))\n      : [];\n\n    return {\n      rawTransaction: rawTxn.bcsToBytes(),\n      secondarySignerAddresses: signers,\n      feePayerAddress: AccountAddress.fromHexInput(feePayerAddress),\n    };\n  }\n\n  if (secondarySignerAddresses) {\n    const signers: Array<AccountAddress> = secondarySignerAddresses.map((signer) =>\n      AccountAddress.fromHexInput(signer),\n    );\n\n    return {\n      rawTransaction: rawTxn.bcsToBytes(),\n      secondarySignerAddresses: signers,\n    };\n  }\n  // return the raw transaction\n  return { rawTransaction: rawTxn.bcsToBytes() };\n}\n\n/**\n * Simulate a transaction before signing and submit to chain\n *\n * @param args.transaction A aptos transaction type to sign\n * @param args.signerPublicKey The signer public key\n * @param args.secondarySignersPublicKeys optional. The secondary signers public keys if multi signers transaction\n * @param args.feePayerPublicKey optional. The fee payer public key is a fee payer (aka sponsored) transaction\n * @param args.options optional. SimulateTransactionOptions\n *\n * @returns A signed serialized transaction that can be simulated\n */\nexport function generateSignedTransactionForSimulation(args: InputSimulateTransactionData): Uint8Array {\n  const { signerPublicKey, transaction, secondarySignersPublicKeys, feePayerPublicKey } = args;\n\n  const deserializer = new Deserializer(transaction.rawTransaction);\n  const deserializedTransaction = RawTransaction.deserialize(deserializer);\n\n  const accountAuthenticator = getAuthenticatorForSimulation(signerPublicKey);\n  // fee payer transaction\n  if (transaction.feePayerAddress) {\n    const transactionToSign = new FeePayerRawTransaction(\n      deserializedTransaction,\n      transaction.secondarySignerAddresses ?? [],\n      transaction.feePayerAddress,\n    );\n\n    let secondaryAccountAuthenticators: Array<AccountAuthenticator> = [];\n    if (secondarySignersPublicKeys) {\n      secondaryAccountAuthenticators = secondarySignersPublicKeys.map((publicKey) =>\n        getAuthenticatorForSimulation(publicKey),\n      );\n    }\n\n    const feePayerAuthenticator = getAuthenticatorForSimulation(feePayerPublicKey!);\n\n    const transactionAuthenticator = new TransactionAuthenticatorFeePayer(\n      accountAuthenticator,\n      transaction.secondarySignerAddresses ?? [],\n      secondaryAccountAuthenticators,\n      {\n        address: transaction.feePayerAddress,\n        authenticator: feePayerAuthenticator,\n      },\n    );\n    return new SignedTransaction(transactionToSign.raw_txn, transactionAuthenticator).bcsToBytes();\n  }\n\n  // multi agent transaction\n  if (transaction.secondarySignerAddresses) {\n    const transactionToSign = new MultiAgentRawTransaction(\n      deserializedTransaction,\n      transaction.secondarySignerAddresses,\n    );\n\n    let secondaryAccountAuthenticators: Array<AccountAuthenticator> = [];\n\n    secondaryAccountAuthenticators = secondarySignersPublicKeys!.map((publicKey) =>\n      getAuthenticatorForSimulation(publicKey),\n    );\n\n    const transactionAuthenticator = new TransactionAuthenticatorMultiAgent(\n      accountAuthenticator,\n      transaction.secondarySignerAddresses,\n      secondaryAccountAuthenticators,\n    );\n\n    return new SignedTransaction(transactionToSign.raw_txn, transactionAuthenticator).bcsToBytes();\n  }\n\n  // raw transaction\n  let transactionAuthenticator;\n  if (accountAuthenticator instanceof AccountAuthenticatorEd25519) {\n    transactionAuthenticator = new TransactionAuthenticatorEd25519(\n      accountAuthenticator.public_key,\n      accountAuthenticator.signature,\n    );\n  } else if (accountAuthenticator instanceof AccountAuthenticatorSingleKey) {\n    transactionAuthenticator = new TransactionAuthenticatorSingleSender(accountAuthenticator);\n  } else {\n    throw new Error(\"Invalid public key\");\n  }\n  return new SignedTransaction(deserializedTransaction, transactionAuthenticator).bcsToBytes();\n}\n\nexport function getAuthenticatorForSimulation(publicKey: PublicKey) {\n  // TODO add support for AnyMultiKey\n  if (publicKey instanceof AnyPublicKey) {\n    if (publicKey.publicKey instanceof Ed25519PublicKey) {\n      return new AccountAuthenticatorSingleKey(publicKey, new AnySignature(new Ed25519Signature(new Uint8Array(64))));\n    }\n    if (publicKey.publicKey instanceof Secp256k1PublicKey) {\n      return new AccountAuthenticatorSingleKey(publicKey, new AnySignature(new Secp256k1Signature(new Uint8Array(64))));\n    }\n  }\n\n  // legacy code\n  // TODO add support to legacy multied25519\n  return new AccountAuthenticatorEd25519(\n    new Ed25519PublicKey(publicKey.toUint8Array()),\n    new Ed25519Signature(new Uint8Array(64)),\n  );\n}\n\n/**\n * Sign a transaction that can later be submitted to chain\n *\n * @param args.signer The signer account to sign the transaction\n * @param args.transaction A aptos transaction type to sign\n *\n * @return The signer AccountAuthenticator\n */\nexport function sign(args: { signer: Account; transaction: AnyRawTransaction }): AccountAuthenticator {\n  const { signer, transaction } = args;\n\n  const transactionToSign = deriveTransactionType(transaction);\n\n  // get the signing message\n  const message = getSigningMessage(transactionToSign);\n\n  // account.signMessage\n  const signerSignature = signer.sign(message);\n\n  // return account authentication\n  switch (signer.signingScheme) {\n    case SigningScheme.Ed25519:\n      return new AccountAuthenticatorEd25519(\n        new Ed25519PublicKey(signer.publicKey.toUint8Array()),\n        new Ed25519Signature(signerSignature.toUint8Array()),\n      );\n    case SigningScheme.SingleKey:\n      return new AccountAuthenticatorSingleKey(signer.publicKey as AnyPublicKey, new AnySignature(signerSignature));\n    // TODO support MultiEd25519\n    default:\n      throw new Error(`Cannot sign transaction, signing scheme ${signer.signingScheme} not supported`);\n  }\n}\n\n/**\n * Prepare a transaction to be submitted to chain\n *\n * @param args.transaction A aptos transaction type\n * @param args.senderAuthenticator The account authenticator of the transaction sender\n * @param args.secondarySignerAuthenticators optional. For when the transaction is a multi signers transaction\n *\n * @returns A SignedTransaction\n */\nexport function generateSignedTransaction(args: {\n  transaction: AnyRawTransaction;\n  senderAuthenticator: AccountAuthenticator;\n  secondarySignerAuthenticators?: {\n    feePayerAuthenticator?: AccountAuthenticator;\n    additionalSignersAuthenticators?: Array<AccountAuthenticator>;\n  };\n}): Uint8Array {\n  const { transaction, senderAuthenticator, secondarySignerAuthenticators } = args;\n\n  const transactionToSubmit = deriveTransactionType(transaction);\n\n  if (secondarySignerAuthenticators) {\n    return generateMultiSignersSignedTransaction(\n      transactionToSubmit as MultiAgentRawTransaction | FeePayerRawTransaction,\n      senderAuthenticator,\n      secondarySignerAuthenticators,\n    );\n  }\n\n  // submit single signer transaction\n\n  // check what instance is accountAuthenticator\n  if (senderAuthenticator instanceof AccountAuthenticatorEd25519) {\n    const transactionAuthenticator = new TransactionAuthenticatorEd25519(\n      senderAuthenticator.public_key,\n      senderAuthenticator.signature,\n    );\n    return new SignedTransaction(transactionToSubmit as RawTransaction, transactionAuthenticator).bcsToBytes();\n  }\n\n  if (\n    senderAuthenticator instanceof AccountAuthenticatorSingleKey ||\n    senderAuthenticator instanceof AccountAuthenticatorMultiKey\n  ) {\n    const transactionAuthenticator = new TransactionAuthenticatorSingleSender(senderAuthenticator);\n    return new SignedTransaction(transactionToSubmit as RawTransaction, transactionAuthenticator).bcsToBytes();\n  }\n\n  throw new Error(\n    `Cannot generate a signed transaction, ${senderAuthenticator} is not a supported account authentication scheme`,\n  );\n}\n\n/**\n * Derive the raw transaction type - FeePayerRawTransaction or MultiAgentRawTransaction or RawTransaction\n *\n * @param transaction A aptos transaction type\n *\n * @returns FeePayerRawTransaction | MultiAgentRawTransaction | RawTransaction\n */\nexport function deriveTransactionType(transaction: AnyRawTransaction): AnyRawTransactionInstance {\n  const deserializer = new Deserializer(transaction.rawTransaction);\n  const deserializedTransaction = RawTransaction.deserialize(deserializer);\n\n  if (transaction.feePayerAddress) {\n    return new FeePayerRawTransaction(\n      deserializedTransaction,\n      transaction.secondarySignerAddresses ?? [],\n      transaction.feePayerAddress,\n    );\n  }\n  if (transaction.secondarySignerAddresses) {\n    return new MultiAgentRawTransaction(deserializedTransaction, transaction.secondarySignerAddresses);\n  }\n\n  return deserializedTransaction as RawTransaction;\n}\n\n/**\n * Generate a multi signers signed transaction that can be submitted to chain\n *\n * @param transaction MultiAgentRawTransaction | FeePayerRawTransaction\n * @param senderAuthenticator The account authenticator of the transaction sender\n * @param secondarySignerAuthenticators The extra signers account Authenticators\n *\n * @returns A SignedTransaction\n */\nexport function generateMultiSignersSignedTransaction(\n  transaction: MultiAgentRawTransaction | FeePayerRawTransaction,\n  senderAuthenticator: AccountAuthenticator,\n  secondarySignerAuthenticators: {\n    feePayerAuthenticator?: AccountAuthenticator;\n    additionalSignersAuthenticators?: Array<AccountAuthenticator>;\n  },\n) {\n  if (transaction instanceof FeePayerRawTransaction) {\n    if (!secondarySignerAuthenticators.feePayerAuthenticator) {\n      throw new Error(\"Must provide a feePayerAuthenticator argument to generate a signed fee payer transaction\");\n    }\n    const { feePayerAuthenticator, additionalSignersAuthenticators } = secondarySignerAuthenticators;\n    const txAuthenticatorFeePayer = new TransactionAuthenticatorFeePayer(\n      senderAuthenticator,\n      transaction.secondary_signer_addresses,\n      additionalSignersAuthenticators ?? [],\n      {\n        address: transaction.fee_payer_address,\n        authenticator: feePayerAuthenticator,\n      },\n    );\n    return new SignedTransaction(transaction.raw_txn, txAuthenticatorFeePayer).bcsToBytes();\n  }\n  if (transaction instanceof MultiAgentRawTransaction) {\n    if (!secondarySignerAuthenticators.additionalSignersAuthenticators) {\n      throw new Error(\n        \"Must provide a additionalSignersAuthenticators argument to generate a signed multi agent transaction\",\n      );\n    }\n    const { additionalSignersAuthenticators } = secondarySignerAuthenticators;\n    const multiAgentAuthenticator = new TransactionAuthenticatorMultiAgent(\n      senderAuthenticator,\n      transaction.secondary_signer_addresses,\n      additionalSignersAuthenticators ?? [],\n    );\n    return new SignedTransaction(transaction.raw_txn, multiAgentAuthenticator).bcsToBytes();\n  }\n\n  throw new Error(\n    `Cannot prepare multi signers transaction to submission, ${typeof transaction} transaction is not supported`,\n  );\n}\n\nexport function getSigningMessage(rawTxn: AnyRawTransactionInstance): Uint8Array {\n  const hash = sha3Hash.create();\n\n  if (rawTxn instanceof RawTransaction) {\n    hash.update(RAW_TRANSACTION_SALT);\n  } else if (rawTxn instanceof MultiAgentRawTransaction) {\n    hash.update(RAW_TRANSACTION_WITH_DATA_SALT);\n  } else if (rawTxn instanceof FeePayerRawTransaction) {\n    hash.update(RAW_TRANSACTION_WITH_DATA_SALT);\n  } else {\n    throw new Error(`Unknown transaction type to sign on: ${rawTxn}`);\n  }\n\n  const prefix = hash.digest();\n\n  const body = rawTxn.bcsToBytes();\n\n  const mergedArray = new Uint8Array(prefix.length + body.length);\n  mergedArray.set(prefix);\n  mergedArray.set(body, prefix.length);\n\n  return mergedArray;\n}\n","import { Serializer, Deserializer } from \"../../bcs\";\nimport { AnySignatureVariant } from \"../../types\";\nimport { Signature } from \"./asymmetricCrypto\";\nimport { Ed25519Signature } from \"./ed25519\";\nimport { Secp256k1Signature } from \"./secp256k1\";\n\nexport class AnySignature extends Signature {\n  public readonly signature: Signature;\n\n  constructor(signature: Signature) {\n    super();\n    this.signature = signature;\n  }\n\n  /**\n   * Get the public key in bytes (Uint8Array).\n   *\n   * @returns Uint8Array representation of the public key\n   */\n  toUint8Array(): Uint8Array {\n    return this.signature.toUint8Array();\n  }\n\n  /**\n   * Get the public key as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the public key\n   */\n  toString(): string {\n    return this.signature.toString();\n  }\n\n  serialize(serializer: Serializer): void {\n    if (this.signature instanceof Ed25519Signature) {\n      serializer.serializeU32AsUleb128(AnySignatureVariant.Ed25519);\n      this.signature.serialize(serializer);\n    } else if (this.signature instanceof Secp256k1Signature) {\n      serializer.serializeU32AsUleb128(AnySignatureVariant.Secp256k1);\n      this.signature.serialize(serializer);\n    } else {\n      throw new Error(\"Unknown signature type\");\n    }\n  }\n\n  static deserialize(deserializer: Deserializer): AnySignature {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case AnySignatureVariant.Ed25519:\n        return new AnySignature(Ed25519Signature.load(deserializer));\n      case AnySignatureVariant.Secp256k1:\n        return new AnySignature(Secp256k1Signature.load(deserializer));\n      default:\n        throw new Error(`Unknown variant index for AnySignature: ${index}`);\n    }\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Sleep the current thread for the given amount of time\n * @param timeMs time in milliseconds to sleep\n */\nexport async function sleep(timeMs: number): Promise<null> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeMs);\n  });\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/transaction}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * transaction namespace and without having a dependency cycle error.\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { AptosApiError, getAptosFullNode, paginateWithCursor } from \"../client\";\nimport {\n  TransactionResponseType,\n  type AnyNumber,\n  type GasEstimation,\n  type HexInput,\n  type PaginationArgs,\n  type TransactionResponse,\n  WaitForTransactionOptions,\n} from \"../types\";\nimport { DEFAULT_TXN_TIMEOUT_SEC } from \"../utils/const\";\nimport { sleep } from \"../utils/helpers\";\nimport { memoizeAsync } from \"../utils/memoize\";\nimport { getIndexerLastSuccessVersion } from \"./general\";\n\nexport async function getTransactions(args: {\n  aptosConfig: AptosConfig;\n  options?: PaginationArgs;\n}): Promise<TransactionResponse[]> {\n  const { aptosConfig, options } = args;\n  return paginateWithCursor<{}, TransactionResponse[]>({\n    aptosConfig,\n    originMethod: \"getTransactions\",\n    path: \"transactions\",\n    params: { start: options?.offset, limit: options?.limit },\n  });\n}\n\nexport async function getGasPriceEstimation(args: { aptosConfig: AptosConfig }) {\n  const { aptosConfig } = args;\n\n  return memoizeAsync(\n    async () => {\n      const { data } = await getAptosFullNode<{}, GasEstimation>({\n        aptosConfig,\n        originMethod: \"getGasPriceEstimation\",\n        path: \"estimate_gas_price\",\n      });\n      return data;\n    },\n    `gas-price-${aptosConfig.network}`,\n    1000 * 60 * 5, // 5 minutes\n  )();\n}\n\nexport async function getTransactionByVersion(args: {\n  aptosConfig: AptosConfig;\n  ledgerVersion: AnyNumber;\n}): Promise<TransactionResponse> {\n  const { aptosConfig, ledgerVersion } = args;\n  const { data } = await getAptosFullNode<{}, TransactionResponse>({\n    aptosConfig,\n    originMethod: \"getTransactionByVersion\",\n    path: `transactions/by_version/${ledgerVersion}`,\n  });\n  return data;\n}\n\nexport async function getTransactionByHash(args: {\n  aptosConfig: AptosConfig;\n  transactionHash: HexInput;\n}): Promise<TransactionResponse> {\n  const { aptosConfig, transactionHash } = args;\n  const { data } = await getAptosFullNode<{}, TransactionResponse>({\n    aptosConfig,\n    path: `transactions/by_hash/${transactionHash}`,\n    originMethod: \"getTransactionByHash\",\n  });\n  return data;\n}\n\nexport async function isTransactionPending(args: {\n  aptosConfig: AptosConfig;\n  transactionHash: HexInput;\n}): Promise<boolean> {\n  const { aptosConfig, transactionHash } = args;\n  try {\n    const transaction = await getTransactionByHash({ aptosConfig, transactionHash });\n    return transaction.type === TransactionResponseType.Pending;\n  } catch (e: any) {\n    if (e?.status === 404) {\n      return true;\n    }\n    throw e;\n  }\n}\n\nexport async function waitForTransaction(args: {\n  aptosConfig: AptosConfig;\n  transactionHash: HexInput;\n  options?: WaitForTransactionOptions;\n}): Promise<TransactionResponse> {\n  const { aptosConfig, transactionHash, options } = args;\n  const timeoutSecs = options?.timeoutSecs ?? DEFAULT_TXN_TIMEOUT_SEC;\n  const checkSuccess = options?.checkSuccess ?? true;\n  const indexerVersionCheck = options?.indexerVersionCheck ?? true;\n\n  let isPending = true;\n  let timeElapsed = 0;\n  let lastTxn: TransactionResponse | undefined;\n  let lastError: AptosApiError | undefined;\n  let backoffIntervalMs = 200;\n  const backoffMultiplier = 1.5;\n\n  while (isPending) {\n    if (timeElapsed >= timeoutSecs) {\n      break;\n    }\n    try {\n      // eslint-disable-next-line no-await-in-loop\n      lastTxn = await getTransactionByHash({ aptosConfig, transactionHash });\n\n      isPending = lastTxn.type === TransactionResponseType.Pending;\n\n      if (!isPending) {\n        break;\n      }\n    } catch (e) {\n      // In short, this means we will retry if it was an AptosApiError and the code was 404 or 5xx.\n      const isAptosApiError = e instanceof AptosApiError;\n      if (!isAptosApiError) {\n        throw e; // This would be unexpected\n      }\n      lastError = e;\n      const isRequestError = e.status !== 404 && e.status >= 400 && e.status < 500;\n      if (isRequestError) {\n        throw e;\n      }\n    }\n    // eslint-disable-next-line no-await-in-loop\n    await sleep(backoffIntervalMs);\n    timeElapsed += backoffIntervalMs / 1000; // Convert to seconds\n    backoffIntervalMs *= backoffMultiplier;\n  }\n\n  // There is a chance that lastTxn is still undefined. Let's throw the last error otherwise a WaitForTransactionError\n  if (lastTxn === undefined) {\n    if (lastError) {\n      throw lastError;\n    } else {\n      throw new WaitForTransactionError(\n        `Fetching transaction ${transactionHash} failed and timed out after ${timeoutSecs} seconds`,\n        lastTxn,\n      );\n    }\n  }\n\n  if (lastTxn.type === TransactionResponseType.Pending) {\n    throw new WaitForTransactionError(\n      `Transaction ${transactionHash} timed out in pending state after ${timeoutSecs} seconds`,\n      lastTxn,\n    );\n  }\n  if (!checkSuccess) {\n    return lastTxn;\n  }\n  if (!lastTxn.success) {\n    throw new FailedTransactionError(\n      `Transaction ${transactionHash} failed with an error: ${(lastTxn as any).vm_status}`,\n      lastTxn,\n    );\n  }\n\n  // Make sure indexer is synced with the latest ledger version\n  if (indexerVersionCheck) {\n    try {\n      await waitForLastSuccessIndexerVersionSync({ aptosConfig, ledgerVersion: Number(lastTxn.version) });\n    } catch (_e) {\n      throw new WaitForTransactionError(\n        // eslint-disable-next-line max-len\n        `Transaction ${transactionHash} committed, but timed out waiting for indexer to sync with ledger version ${lastTxn.version}.` +\n          \"You can disable this check by setting `indexerVersionCheck` to false in the `extraArgs` parameter.\",\n        lastTxn,\n      );\n    }\n  }\n\n  return lastTxn;\n}\n\n/**\n * Waits for the indexer to sync up to the ledgerVersion. Timeout is 3 seconds.\n */\nasync function waitForLastSuccessIndexerVersionSync(args: {\n  aptosConfig: AptosConfig;\n  ledgerVersion: number;\n}): Promise<void> {\n  const { aptosConfig, ledgerVersion } = args;\n  const timeoutMilliseconds = 3000; // 3 seconds\n  const startTime = new Date().getTime();\n  let indexerVersion = -1;\n\n  while (indexerVersion < ledgerVersion) {\n    // check for timeout\n    if (new Date().getTime() - startTime > timeoutMilliseconds) {\n      throw new Error(\"waitForLastSuccessIndexerVersionSync timeout\");\n    }\n\n    // eslint-disable-next-line no-await-in-loop\n    indexerVersion = await getIndexerLastSuccessVersion({ aptosConfig });\n    if (indexerVersion >= ledgerVersion) {\n      // break out immediately if we are synced\n      break;\n    }\n\n    // eslint-disable-next-line no-await-in-loop\n    await sleep(200);\n  }\n}\n\n/**\n * This error is used by `waitForTransaction` when waiting for a\n * transaction to time out or when the transaction response is undefined\n */\nexport class WaitForTransactionError extends Error {\n  public readonly lastSubmittedTransaction: TransactionResponse | undefined;\n\n  constructor(message: string, lastSubmittedTransaction: TransactionResponse | undefined) {\n    super(message);\n    this.lastSubmittedTransaction = lastSubmittedTransaction;\n  }\n}\n\n/**\n * This error is used by `waitForTransaction` if `checkSuccess` is true.\n * See that function for more information.\n */\nexport class FailedTransactionError extends Error {\n  public readonly transaction: TransactionResponse;\n\n  constructor(message: string, transaction: TransactionResponse) {\n    super(message);\n    this.transaction = transaction;\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { Serializer, Deserializer, Serializable } from \"../../bcs\";\nimport { AnyPublicKey } from \"../../core/crypto/anyPublicKey\";\nimport { AnySignature } from \"../../core/crypto/anySignature\";\nimport { Ed25519PublicKey, Ed25519Signature } from \"../../core/crypto/ed25519\";\nimport { MultiEd25519PublicKey, MultiEd25519Signature } from \"../../core/crypto/multiEd25519\";\nimport { MultiKey } from \"../../core/crypto/multiKey\";\nimport { AccountAuthenticatorVariant } from \"../../types\";\n\nexport abstract class AccountAuthenticator extends Serializable {\n  abstract serialize(serializer: Serializer): void;\n\n  static deserialize(deserializer: Deserializer): AccountAuthenticator {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case AccountAuthenticatorVariant.Ed25519:\n        return AccountAuthenticatorEd25519.load(deserializer);\n      case AccountAuthenticatorVariant.MultiEd25519:\n        return AccountAuthenticatorMultiEd25519.load(deserializer);\n      case AccountAuthenticatorVariant.SingleKey:\n        return AccountAuthenticatorSingleKey.load(deserializer);\n      case AccountAuthenticatorVariant.MultiKey:\n        return AccountAuthenticatorMultiKey.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for AccountAuthenticator: ${index}`);\n    }\n  }\n}\n\n/**\n * Transaction authenticator Ed25519 for a multi signer transaction\n *\n * @param public_key Account's Ed25519 public key.\n * @param signature Account's Ed25519 signature\n *\n */\nexport class AccountAuthenticatorEd25519 extends AccountAuthenticator {\n  public readonly public_key: Ed25519PublicKey;\n\n  public readonly signature: Ed25519Signature;\n\n  constructor(public_key: Ed25519PublicKey, signature: Ed25519Signature) {\n    super();\n    this.public_key = public_key;\n    this.signature = signature;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(AccountAuthenticatorVariant.Ed25519);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): AccountAuthenticatorEd25519 {\n    const public_key = Ed25519PublicKey.deserialize(deserializer);\n    const signature = Ed25519Signature.deserialize(deserializer);\n    return new AccountAuthenticatorEd25519(public_key, signature);\n  }\n}\n\n/**\n * Transaction authenticator Multi Ed25519 for a multi signers transaction\n *\n * @param public_key Account's MultiEd25519 public key.\n * @param signature Account's MultiEd25519 signature\n *\n */\nexport class AccountAuthenticatorMultiEd25519 extends AccountAuthenticator {\n  public readonly public_key: MultiEd25519PublicKey;\n\n  public readonly signature: MultiEd25519Signature;\n\n  constructor(public_key: MultiEd25519PublicKey, signature: MultiEd25519Signature) {\n    super();\n    this.public_key = public_key;\n    this.signature = signature;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(AccountAuthenticatorVariant.MultiEd25519);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): AccountAuthenticatorMultiEd25519 {\n    const public_key = MultiEd25519PublicKey.deserialize(deserializer);\n    const signature = MultiEd25519Signature.deserialize(deserializer);\n    return new AccountAuthenticatorMultiEd25519(public_key, signature);\n  }\n}\n\n/**\n * AccountAuthenticatorSingleKey for a single signer\n *\n * @param public_key AnyPublicKey\n * @param signature AnySignature\n *\n */\nexport class AccountAuthenticatorSingleKey extends AccountAuthenticator {\n  public readonly public_key: AnyPublicKey;\n\n  public readonly signature: AnySignature;\n\n  constructor(public_key: AnyPublicKey, signature: AnySignature) {\n    super();\n    this.public_key = public_key;\n    this.signature = signature;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(AccountAuthenticatorVariant.SingleKey);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): AccountAuthenticatorSingleKey {\n    const public_key = AnyPublicKey.deserialize(deserializer);\n    const signature = AnySignature.deserialize(deserializer);\n    return new AccountAuthenticatorSingleKey(public_key, signature);\n  }\n}\n\n/**\n * AccountAuthenticatorMultiKey for a multi signer\n *\n * @param public_keys MultiKey\n * @param signatures Signature\n *\n */\nexport class AccountAuthenticatorMultiKey extends AccountAuthenticator {\n  public readonly public_keys: MultiKey;\n\n  public readonly signatures: Array<AnySignature>;\n\n  public readonly signatures_bitmap: Uint8Array;\n\n  constructor(public_keys: MultiKey, signatures: Array<AnySignature>, signatures_bitmap: Uint8Array) {\n    super();\n    this.public_keys = public_keys;\n    this.signatures = signatures;\n    this.signatures_bitmap = signatures_bitmap;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(AccountAuthenticatorVariant.MultiKey);\n    this.public_keys.serialize(serializer);\n    serializer.serializeVector<AnySignature>(this.signatures);\n    serializer.serializeBytes(this.signatures_bitmap);\n  }\n\n  static load(deserializer: Deserializer): AccountAuthenticatorMultiKey {\n    const public_keys = MultiKey.deserialize(deserializer);\n    const signatures = deserializer.deserializeVector(AnySignature);\n    const signatures_bitmap = deserializer.deserializeBytes();\n    return new AccountAuthenticatorMultiKey(public_keys, signatures, signatures_bitmap);\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { AccountAuthenticator } from \"./account\";\nimport { Deserializer, Serializable, Serializer } from \"../../bcs\";\nimport { AccountAddress } from \"../../core\";\nimport { Ed25519PublicKey, Ed25519Signature } from \"../../core/crypto/ed25519\";\nimport { MultiEd25519PublicKey, MultiEd25519Signature } from \"../../core/crypto/multiEd25519\";\nimport { TransactionAuthenticatorVariant } from \"../../types\";\n\nexport abstract class TransactionAuthenticator extends Serializable {\n  abstract serialize(serializer: Serializer): void;\n\n  static deserialize(deserializer: Deserializer): TransactionAuthenticator {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case TransactionAuthenticatorVariant.Ed25519:\n        return TransactionAuthenticatorEd25519.load(deserializer);\n      case TransactionAuthenticatorVariant.MultiEd25519:\n        return TransactionAuthenticatorMultiEd25519.load(deserializer);\n      case TransactionAuthenticatorVariant.MultiAgent:\n        return TransactionAuthenticatorMultiAgent.load(deserializer);\n      case TransactionAuthenticatorVariant.FeePayer:\n        return TransactionAuthenticatorFeePayer.load(deserializer);\n      case TransactionAuthenticatorVariant.SingleSender:\n        return TransactionAuthenticatorSingleSender.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for TransactionAuthenticator: ${index}`);\n    }\n  }\n}\n\n/**\n * Transaction authenticator Ed25519 for a single signer transaction\n *\n * @param public_key Client's public key.\n * @param signature Ed25519 signature of a raw transaction.\n * @see {@link https://aptos.dev/integration/creating-a-signed-transaction | Creating a Signed Transaction}\n * for details about generating a signature.\n */\nexport class TransactionAuthenticatorEd25519 extends TransactionAuthenticator {\n  public readonly public_key: Ed25519PublicKey;\n\n  public readonly signature: Ed25519Signature;\n\n  constructor(public_key: Ed25519PublicKey, signature: Ed25519Signature) {\n    super();\n    this.public_key = public_key;\n    this.signature = signature;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionAuthenticatorVariant.Ed25519);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionAuthenticatorEd25519 {\n    const public_key = Ed25519PublicKey.deserialize(deserializer);\n    const signature = Ed25519Signature.deserialize(deserializer);\n    return new TransactionAuthenticatorEd25519(public_key, signature);\n  }\n}\n\n/**\n * Transaction authenticator Ed25519 for a multi signers transaction\n *\n * @param public_key Client's public key.\n * @param signature Multi Ed25519 signature of a raw transaction.\n *\n */\nexport class TransactionAuthenticatorMultiEd25519 extends TransactionAuthenticator {\n  public readonly public_key: MultiEd25519PublicKey;\n\n  public readonly signature: MultiEd25519Signature;\n\n  constructor(public_key: MultiEd25519PublicKey, signature: MultiEd25519Signature) {\n    super();\n    this.public_key = public_key;\n    this.signature = signature;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionAuthenticatorVariant.MultiEd25519);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionAuthenticatorMultiEd25519 {\n    const public_key = MultiEd25519PublicKey.deserialize(deserializer);\n    const signature = MultiEd25519Signature.deserialize(deserializer);\n    return new TransactionAuthenticatorMultiEd25519(public_key, signature);\n  }\n}\n\n/**\n * Transaction authenticator for a multi-agent transaction\n *\n * @param sender Sender account authenticator\n * @param secondary_signer_addresses Secondary signers address\n * @param secondary_signers Secondary signers account authenticators\n *\n */\nexport class TransactionAuthenticatorMultiAgent extends TransactionAuthenticator {\n  public readonly sender: AccountAuthenticator;\n\n  public readonly secondary_signer_addresses: Array<AccountAddress>;\n\n  public readonly secondary_signers: Array<AccountAuthenticator>;\n\n  constructor(\n    sender: AccountAuthenticator,\n    secondary_signer_addresses: Array<AccountAddress>,\n    secondary_signers: Array<AccountAuthenticator>,\n  ) {\n    super();\n    this.sender = sender;\n    this.secondary_signer_addresses = secondary_signer_addresses;\n    this.secondary_signers = secondary_signers;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionAuthenticatorVariant.MultiAgent);\n    this.sender.serialize(serializer);\n    serializer.serializeVector<AccountAddress>(this.secondary_signer_addresses);\n    serializer.serializeVector<AccountAuthenticator>(this.secondary_signers);\n  }\n\n  static load(deserializer: Deserializer): TransactionAuthenticatorMultiAgent {\n    const sender = AccountAuthenticator.deserialize(deserializer);\n    const secondary_signer_addresses = deserializer.deserializeVector(AccountAddress);\n    const secondary_signers = deserializer.deserializeVector(AccountAuthenticator);\n    return new TransactionAuthenticatorMultiAgent(sender, secondary_signer_addresses, secondary_signers);\n  }\n}\n\n/**\n * Transaction authenticator for a fee payer transaction\n *\n * @param sender Sender account authenticator\n * @param secondary_signer_addresses Secondary signers address\n * @param secondary_signers Secondary signers account authenticators\n * @param fee_payer Object of the fee payer account address and the fee payer authentication\n *\n */\nexport class TransactionAuthenticatorFeePayer extends TransactionAuthenticator {\n  public readonly sender: AccountAuthenticator;\n\n  public readonly secondary_signer_addresses: Array<AccountAddress>;\n\n  public readonly secondary_signers: Array<AccountAuthenticator>;\n\n  public readonly fee_payer: {\n    address: AccountAddress;\n    authenticator: AccountAuthenticator;\n  };\n\n  constructor(\n    sender: AccountAuthenticator,\n    secondary_signer_addresses: Array<AccountAddress>,\n    secondary_signers: Array<AccountAuthenticator>,\n    fee_payer: { address: AccountAddress; authenticator: AccountAuthenticator },\n  ) {\n    super();\n    this.sender = sender;\n    this.secondary_signer_addresses = secondary_signer_addresses;\n    this.secondary_signers = secondary_signers;\n    this.fee_payer = fee_payer;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionAuthenticatorVariant.FeePayer);\n    this.sender.serialize(serializer);\n    serializer.serializeVector<AccountAddress>(this.secondary_signer_addresses);\n    serializer.serializeVector<AccountAuthenticator>(this.secondary_signers);\n    this.fee_payer.address.serialize(serializer);\n    this.fee_payer.authenticator.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionAuthenticatorMultiAgent {\n    const sender = AccountAuthenticator.deserialize(deserializer);\n    const secondary_signer_addresses = deserializer.deserializeVector(AccountAddress);\n    const secondary_signers = deserializer.deserializeVector(AccountAuthenticator);\n    const address = AccountAddress.deserialize(deserializer);\n    const authenticator = AccountAuthenticator.deserialize(deserializer);\n    const fee_payer = { address, authenticator };\n    return new TransactionAuthenticatorFeePayer(sender, secondary_signer_addresses, secondary_signers, fee_payer);\n  }\n}\n\n/**\n * Single Sender authenticator for a single signer transaction\n *\n * @param sender AccountAuthenticator\n */\nexport class TransactionAuthenticatorSingleSender extends TransactionAuthenticator {\n  public readonly sender: AccountAuthenticator;\n\n  constructor(sender: AccountAuthenticator) {\n    super();\n    this.sender = sender;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionAuthenticatorVariant.SingleSender);\n    this.sender.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionAuthenticatorSingleSender {\n    const sender = AccountAuthenticator.deserialize(deserializer);\n    return new TransactionAuthenticatorSingleSender(sender);\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Serializer, Serializable } from \"../../bcs/serializer\";\nimport { Deserializer } from \"../../bcs/deserializer\";\n\n/**\n * Representation of a ChainId that can serialized and deserialized\n */\nexport class ChainId extends Serializable {\n  public readonly chainId: number;\n\n  constructor(chainId: number) {\n    super();\n    this.chainId = chainId;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU8(this.chainId);\n  }\n\n  static deserialize(deserializer: Deserializer): ChainId {\n    const chainId = deserializer.deserializeU8();\n    return new ChainId(chainId);\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializable, Serializer } from \"../../bcs/serializer\";\n\n/**\n * Representation of an Identifier that can serialized and deserialized.\n * We use Identifier to represent the module \"name\" in \"ModuleId\" and\n * the \"function name\" in \"EntryFunction\"\n */\nexport class Identifier extends Serializable {\n  public identifier: string;\n\n  constructor(identifier: string) {\n    super();\n    this.identifier = identifier;\n  }\n\n  public serialize(serializer: Serializer): void {\n    serializer.serializeStr(this.identifier);\n  }\n\n  static deserialize(deserializer: Deserializer): Identifier {\n    const identifier = deserializer.deserializeStr();\n    return new Identifier(identifier);\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Serializable, Serializer } from \"../../bcs/serializer\";\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { AccountAddress } from \"../../core\";\nimport { Identifier } from \"./identifier\";\nimport { MoveModuleId } from \"../../types\";\n\n/**\n * Representation of a ModuleId that can serialized and deserialized\n * ModuleId means the module address (e.g \"0x1\") and the module name (e.g \"coin\")\n */\nexport class ModuleId extends Serializable {\n  public readonly address: AccountAddress;\n\n  public readonly name: Identifier;\n\n  /**\n   * Full name of a module.\n   * @param address The account address. e.g \"0x1\"\n   * @param name The module name under the \"address\". e.g \"coin\"\n   */\n  constructor(address: AccountAddress, name: Identifier) {\n    super();\n    this.address = address;\n    this.name = name;\n  }\n\n  /**\n   * Converts a string literal to a ModuleId\n   * @param moduleId String literal in format \"account_address::module_name\", e.g. \"0x1::coin\"\n   * @returns ModuleId\n   */\n  static fromStr(moduleId: MoveModuleId): ModuleId {\n    const parts = moduleId.split(\"::\");\n    if (parts.length !== 2) {\n      throw new Error(\"Invalid module id.\");\n    }\n    return new ModuleId(AccountAddress.fromString(parts[0]), new Identifier(parts[1]));\n  }\n\n  serialize(serializer: Serializer): void {\n    this.address.serialize(serializer);\n    this.name.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): ModuleId {\n    const address = AccountAddress.deserialize(deserializer);\n    const name = Identifier.deserialize(deserializer);\n    return new ModuleId(address, name);\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable class-methods-use-this */\n/* eslint-disable max-classes-per-file */\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializable, Serializer } from \"../../bcs/serializer\";\nimport { AccountAddress } from \"../../core\";\nimport { Identifier } from \"../instances/identifier\";\nimport { TypeTagVariants } from \"../../types\";\n\nexport abstract class TypeTag extends Serializable {\n  abstract serialize(serializer: Serializer): void;\n\n  static deserialize(deserializer: Deserializer): TypeTag {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case TypeTagVariants.Bool:\n        return TypeTagBool.load(deserializer);\n      case TypeTagVariants.U8:\n        return TypeTagU8.load(deserializer);\n      case TypeTagVariants.U64:\n        return TypeTagU64.load(deserializer);\n      case TypeTagVariants.U128:\n        return TypeTagU128.load(deserializer);\n      case TypeTagVariants.Address:\n        return TypeTagAddress.load(deserializer);\n      case TypeTagVariants.Signer:\n        return TypeTagSigner.load(deserializer);\n      case TypeTagVariants.Vector:\n        return TypeTagVector.load(deserializer);\n      case TypeTagVariants.Struct:\n        return TypeTagStruct.load(deserializer);\n      case TypeTagVariants.U16:\n        return TypeTagU16.load(deserializer);\n      case TypeTagVariants.U32:\n        return TypeTagU32.load(deserializer);\n      case TypeTagVariants.U256:\n        return TypeTagU256.load(deserializer);\n      case TypeTagVariants.Generic:\n        // This is only used for ABI representation, and cannot actually be used as a type.\n        return TypeTagGeneric.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for TypeTag: ${index}`);\n    }\n  }\n\n  abstract toString(): string;\n\n  isBool(): this is TypeTagBool {\n    return this instanceof TypeTagBool;\n  }\n\n  isAddress(): this is TypeTagAddress {\n    return this instanceof TypeTagAddress;\n  }\n\n  isGeneric(): this is TypeTagGeneric {\n    return this instanceof TypeTagGeneric;\n  }\n\n  isSigner(): this is TypeTagSigner {\n    return this instanceof TypeTagSigner;\n  }\n\n  isVector(): this is TypeTagVector {\n    return this instanceof TypeTagVector;\n  }\n\n  isStruct(): this is TypeTagStruct {\n    return this instanceof TypeTagStruct;\n  }\n\n  isU8(): this is TypeTagU8 {\n    return this instanceof TypeTagU8;\n  }\n\n  isU16(): this is TypeTagU16 {\n    return this instanceof TypeTagU16;\n  }\n\n  isU32(): this is TypeTagU32 {\n    return this instanceof TypeTagU32;\n  }\n\n  isU64(): this is TypeTagU64 {\n    return this instanceof TypeTagU64;\n  }\n\n  isU128(): this is TypeTagU128 {\n    return this instanceof TypeTagU128;\n  }\n\n  isU256(): this is TypeTagU256 {\n    return this instanceof TypeTagU256;\n  }\n}\n\nexport class TypeTagBool extends TypeTag {\n  toString(): string {\n    return \"bool\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Bool);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagBool {\n    return new TypeTagBool();\n  }\n}\n\nexport class TypeTagU8 extends TypeTag {\n  toString(): string {\n    return \"u8\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.U8);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagU8 {\n    return new TypeTagU8();\n  }\n}\n\nexport class TypeTagU16 extends TypeTag {\n  toString(): string {\n    return \"u16\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.U16);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagU16 {\n    return new TypeTagU16();\n  }\n}\n\nexport class TypeTagU32 extends TypeTag {\n  toString(): string {\n    return \"u32\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.U32);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagU32 {\n    return new TypeTagU32();\n  }\n}\n\nexport class TypeTagU64 extends TypeTag {\n  toString(): string {\n    return \"u64\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.U64);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagU64 {\n    return new TypeTagU64();\n  }\n}\n\nexport class TypeTagU128 extends TypeTag {\n  toString(): string {\n    return \"u128\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.U128);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagU128 {\n    return new TypeTagU128();\n  }\n}\n\nexport class TypeTagU256 extends TypeTag {\n  toString(): string {\n    return \"u256\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.U256);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagU256 {\n    return new TypeTagU256();\n  }\n}\n\nexport class TypeTagAddress extends TypeTag {\n  toString(): string {\n    return \"address\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Address);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagAddress {\n    return new TypeTagAddress();\n  }\n}\n\nexport class TypeTagSigner extends TypeTag {\n  toString(): string {\n    return \"signer\";\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Signer);\n  }\n\n  static load(_deserializer: Deserializer): TypeTagSigner {\n    return new TypeTagSigner();\n  }\n}\n\nexport class TypeTagReference extends TypeTag {\n  toString(): `&${string}` {\n    return `&${this.value.toString()}`;\n  }\n\n  constructor(public readonly value: TypeTag) {\n    super();\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Reference);\n  }\n\n  static load(deserializer: Deserializer): TypeTagReference {\n    const value = TypeTag.deserialize(deserializer);\n    return new TypeTagReference(value);\n  }\n}\n\n/**\n * Generics are used for type parameters in entry functions.  However,\n * they are not actually serialized into a real type, so they cannot be\n * used as a type directly.\n */\nexport class TypeTagGeneric extends TypeTag {\n  toString(): `T${number}` {\n    return `T${this.value}`;\n  }\n\n  constructor(public readonly value: number) {\n    super();\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Generic);\n    serializer.serializeU32(this.value);\n  }\n\n  static load(deserializer: Deserializer): TypeTagGeneric {\n    const value = deserializer.deserializeU32();\n    return new TypeTagGeneric(value);\n  }\n}\n\nexport class TypeTagVector extends TypeTag {\n  toString(): `vector<${string}>` {\n    return `vector<${this.value.toString()}>`;\n  }\n\n  constructor(public readonly value: TypeTag) {\n    super();\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Vector);\n    this.value.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TypeTagVector {\n    const value = TypeTag.deserialize(deserializer);\n    return new TypeTagVector(value);\n  }\n}\n\nexport class TypeTagStruct extends TypeTag {\n  toString(): `0x${string}::${string}::${string}` {\n    // Collect type args and add it if there are any\n    let typePredicate = \"\";\n    if (this.value.type_args.length > 0) {\n      typePredicate = `<${this.value.type_args.map((typeArg) => typeArg.toString()).join(\", \")}>`;\n    }\n\n    return `${this.value.address.toString()}::${this.value.module_name.identifier}::${\n      this.value.name.identifier\n    }${typePredicate}`;\n  }\n\n  constructor(public readonly value: StructTag) {\n    super();\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TypeTagVariants.Struct);\n    this.value.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TypeTagStruct {\n    const value = StructTag.deserialize(deserializer);\n    return new TypeTagStruct(value);\n  }\n\n  isTypeTag(address: AccountAddress, moduleName: string, structName: string): boolean {\n    return (\n      this.value.module_name.identifier === moduleName &&\n      this.value.name.identifier === structName &&\n      this.value.address.equals(address)\n    );\n  }\n\n  isString(): boolean {\n    return this.isTypeTag(AccountAddress.ONE, \"string\", \"String\");\n  }\n\n  isOption(): boolean {\n    return this.isTypeTag(AccountAddress.ONE, \"option\", \"Option\");\n  }\n\n  isObject(): boolean {\n    return this.isTypeTag(AccountAddress.ONE, \"object\", \"Object\");\n  }\n}\n\nexport class StructTag extends Serializable {\n  public readonly address: AccountAddress;\n\n  public readonly module_name: Identifier;\n\n  public readonly name: Identifier;\n\n  public readonly type_args: Array<TypeTag>;\n\n  constructor(address: AccountAddress, module_name: Identifier, name: Identifier, type_args: Array<TypeTag>) {\n    super();\n    this.address = address;\n    this.module_name = module_name;\n    this.name = name;\n    this.type_args = type_args;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serialize(this.address);\n    serializer.serialize(this.module_name);\n    serializer.serialize(this.name);\n    serializer.serializeVector(this.type_args);\n  }\n\n  static deserialize(deserializer: Deserializer): StructTag {\n    const address = AccountAddress.deserialize(deserializer);\n    const moduleName = Identifier.deserialize(deserializer);\n    const name = Identifier.deserialize(deserializer);\n    const typeArgs = deserializer.deserializeVector(TypeTag);\n    return new StructTag(address, moduleName, name, typeArgs);\n  }\n}\n\nexport function aptosCoinStructTag(): StructTag {\n  return new StructTag(AccountAddress.ONE, new Identifier(\"aptos_coin\"), new Identifier(\"AptosCoin\"), []);\n}\n\nexport function stringStructTag(): StructTag {\n  return new StructTag(AccountAddress.ONE, new Identifier(\"string\"), new Identifier(\"String\"), []);\n}\n\nexport function optionStructTag(typeArg: TypeTag): StructTag {\n  return new StructTag(AccountAddress.ONE, new Identifier(\"option\"), new Identifier(\"Option\"), [typeArg]);\n}\n\nexport function objectStructTag(typeArg: TypeTag): StructTag {\n  return new StructTag(AccountAddress.ONE, new Identifier(\"object\"), new Identifier(\"Object\"), [typeArg]);\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializable, Serializer } from \"../../bcs/serializer\";\nimport { EntryFunctionBytes } from \"../../bcs/serializable/entryFunctionBytes\";\nimport { Bool, U128, U16, U256, U32, U64, U8 } from \"../../bcs/serializable/movePrimitives\";\nimport { MoveVector } from \"../../bcs/serializable/moveStructs\";\nimport { AccountAddress } from \"../../core\";\nimport { Identifier } from \"./identifier\";\nimport { ModuleId } from \"./moduleId\";\nimport type { EntryFunctionArgument, ScriptFunctionArgument, TransactionArgument } from \"./transactionArgument\";\nimport { MoveModuleId, ScriptTransactionArgumentVariants, TransactionPayloadVariants } from \"../../types\";\nimport { TypeTag } from \"../typeTag\";\n\n/**\n * Deserialize a Script Transaction Argument\n */\nexport function deserializeFromScriptArgument(deserializer: Deserializer): TransactionArgument {\n  // index enum variant\n  const index = deserializer.deserializeUleb128AsU32();\n  switch (index) {\n    case ScriptTransactionArgumentVariants.U8:\n      return U8.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.U64:\n      return U64.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.U128:\n      return U128.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.Address:\n      return AccountAddress.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.U8Vector:\n      return MoveVector.deserialize(deserializer, U8);\n    case ScriptTransactionArgumentVariants.Bool:\n      return Bool.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.U16:\n      return U16.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.U32:\n      return U32.deserialize(deserializer);\n    case ScriptTransactionArgumentVariants.U256:\n      return U256.deserialize(deserializer);\n    default:\n      throw new Error(`Unknown variant index for ScriptTransactionArgument: ${index}`);\n  }\n}\n\n/**\n * Representation of the supported Transaction Payload\n * that can serialized and deserialized\n */\nexport abstract class TransactionPayload extends Serializable {\n  /**\n   * Serialize a Transaction Payload\n   */\n  abstract serialize(serializer: Serializer): void;\n\n  /**\n   * Deserialize a Transaction Payload\n   */\n  static deserialize(deserializer: Deserializer): TransactionPayload {\n    // index enum variant\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case TransactionPayloadVariants.Script:\n        return TransactionPayloadScript.load(deserializer);\n      case TransactionPayloadVariants.EntryFunction:\n        return TransactionPayloadEntryFunction.load(deserializer);\n      case TransactionPayloadVariants.Multisig:\n        return TransactionPayloadMultisig.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for TransactionPayload: ${index}`);\n    }\n  }\n}\n\n/**\n * Representation of a Transaction Payload Script that can serialized and deserialized\n */\nexport class TransactionPayloadScript extends TransactionPayload {\n  public readonly script: Script;\n\n  constructor(script: Script) {\n    super();\n    this.script = script;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionPayloadVariants.Script);\n    this.script.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionPayloadScript {\n    const script = Script.deserialize(deserializer);\n    return new TransactionPayloadScript(script);\n  }\n}\n\n/**\n * Representation of a Transaction Payload Entry Function that can serialized and deserialized\n */\nexport class TransactionPayloadEntryFunction extends TransactionPayload {\n  public readonly entryFunction: EntryFunction;\n\n  constructor(entryFunction: EntryFunction) {\n    super();\n    this.entryFunction = entryFunction;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionPayloadVariants.EntryFunction);\n    this.entryFunction.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionPayloadEntryFunction {\n    const entryFunction = EntryFunction.deserialize(deserializer);\n    return new TransactionPayloadEntryFunction(entryFunction);\n  }\n}\n\n/**\n * Representation of a Transaction Payload Multi-sig that can serialized and deserialized\n */\nexport class TransactionPayloadMultisig extends TransactionPayload {\n  public readonly multiSig: MultiSig;\n\n  constructor(multiSig: MultiSig) {\n    super();\n    this.multiSig = multiSig;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionPayloadVariants.Multisig);\n    this.multiSig.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): TransactionPayloadMultisig {\n    const multiSig = MultiSig.deserialize(deserializer);\n    return new TransactionPayloadMultisig(multiSig);\n  }\n}\n\n/**\n * Representation of a EntryFunction that can serialized and deserialized\n */\nexport class EntryFunction {\n  public readonly module_name: ModuleId;\n\n  public readonly function_name: Identifier;\n\n  public readonly type_args: Array<TypeTag>;\n\n  public readonly args: Array<EntryFunctionArgument>;\n\n  /**\n   * Contains the payload to run a function within a module.\n   * @param module_name Fully qualified module name in format \"account_address::module_name\" e.g. \"0x1::coin\"\n   * @param function_name The function name. e.g \"transfer\"\n   * @param type_args Type arguments that move function requires.\n   *\n   * @example\n   * A coin transfer function has one type argument \"CoinType\".\n   * ```\n   * public entry fun transfer<CoinType>(from: &signer, to: address, amount: u64)\n   * ```\n   * @param args arguments to the move function.\n   *\n   * @example\n   * A coin transfer function has three arguments \"from\", \"to\" and \"amount\".\n   * ```\n   * public entry fun transfer<CoinType>(from: &signer, to: address, amount: u64)\n   * ```\n   */\n  constructor(\n    module_name: ModuleId,\n    function_name: Identifier,\n    type_args: Array<TypeTag>,\n    args: Array<EntryFunctionArgument>,\n  ) {\n    this.module_name = module_name;\n    this.function_name = function_name;\n    this.type_args = type_args;\n    this.args = args;\n  }\n\n  /**\n   * A helper function to build a EntryFunction payload from raw primitive values\n   *\n   * @param module_id Fully qualified module name in format \"AccountAddress::module_id\" e.g. \"0x1::coin\"\n   * @param function_name Function name\n   * @param type_args Type arguments that move function requires.\n   *\n   * @example\n   * A coin transfer function has one type argument \"CoinType\".\n   * ```\n   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)\n   * ```\n   * @param args Arguments to the move function.\n   *\n   * @example\n   * A coin transfer function has three arguments \"from\", \"to\" and \"amount\".\n   * ```\n   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)\n   * ```\n   * @returns EntryFunction\n   */\n  static build(\n    module_id: MoveModuleId,\n    function_name: string,\n    type_args: Array<TypeTag>,\n    args: Array<EntryFunctionArgument>,\n  ): EntryFunction {\n    return new EntryFunction(ModuleId.fromStr(module_id), new Identifier(function_name), type_args, args);\n  }\n\n  serialize(serializer: Serializer): void {\n    this.module_name.serialize(serializer);\n    this.function_name.serialize(serializer);\n    serializer.serializeVector<TypeTag>(this.type_args);\n    serializer.serializeU32AsUleb128(this.args.length);\n    this.args.forEach((item: EntryFunctionArgument) => {\n      item.serializeForEntryFunction(serializer);\n    });\n  }\n\n  /**\n   * Deserializes an entry function payload with the arguments represented as EntryFunctionBytes instances.\n   * @see EntryFunctionBytes\n   *\n   * NOTE: When you deserialize an EntryFunction payload with this method, the entry function\n   * arguments are populated into the deserialized instance as type-agnostic, raw fixed bytes\n   * in the form of the EntryFunctionBytes class.\n   *\n   * In order to correctly deserialize these arguments as their actual type representations, you\n   * must know the types of the arguments beforehand and deserialize them yourself individually.\n   *\n   * One way you could achieve this is by using the ABIs for an entry function and deserializing each\n   * argument as its given, corresponding type.\n   *\n   * @param deserializer\n   * @returns A deserialized EntryFunction payload for a transaction.\n   *\n   */\n  static deserialize(deserializer: Deserializer): EntryFunction {\n    const module_name = ModuleId.deserialize(deserializer);\n    const function_name = Identifier.deserialize(deserializer);\n    const type_args = deserializer.deserializeVector(TypeTag);\n\n    const length = deserializer.deserializeUleb128AsU32();\n    const args: Array<EntryFunctionArgument> = new Array<EntryFunctionBytes>();\n\n    for (let i = 0; i < length; i += 1) {\n      const fixedBytesLength = deserializer.deserializeUleb128AsU32();\n      const fixedBytes = EntryFunctionBytes.deserialize(deserializer, fixedBytesLength);\n      args.push(fixedBytes);\n    }\n\n    return new EntryFunction(module_name, function_name, type_args, args);\n  }\n}\n\n/**\n * Representation of a Script that can serialized and deserialized\n */\nexport class Script {\n  /**\n   * The move module bytecode\n   */\n  public readonly bytecode: Uint8Array;\n\n  /**\n   * The type arguments that the bytecode function requires.\n   */\n  public readonly type_args: Array<TypeTag>;\n\n  /**\n   * The arguments that the bytecode function requires.\n   */\n  public readonly args: Array<ScriptFunctionArgument>;\n\n  /**\n   * Scripts contain the Move bytecodes payload that can be submitted to Aptos chain for execution.\n   *\n   * @param bytecode The move module bytecode\n   * @param type_args The type arguments that the bytecode function requires.\n   *\n   * @example\n   * A coin transfer function has one type argument \"CoinType\".\n   * ```\n   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)\n   * ```\n   * @param args The arguments that the bytecode function requires.\n   *\n   * @example\n   * A coin transfer function has three arguments \"from\", \"to\" and \"amount\".\n   * ```\n   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)\n   * ```\n   */\n  constructor(bytecode: Uint8Array, type_args: Array<TypeTag>, args: Array<ScriptFunctionArgument>) {\n    this.bytecode = bytecode;\n    this.type_args = type_args;\n    this.args = args;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.bytecode);\n    serializer.serializeVector<TypeTag>(this.type_args);\n    serializer.serializeU32AsUleb128(this.args.length);\n    this.args.forEach((item: ScriptFunctionArgument) => {\n      item.serializeForScriptFunction(serializer);\n    });\n  }\n\n  static deserialize(deserializer: Deserializer): Script {\n    const bytecode = deserializer.deserializeBytes();\n    const type_args = deserializer.deserializeVector(TypeTag);\n    const length = deserializer.deserializeUleb128AsU32();\n    const args = new Array<ScriptFunctionArgument>();\n    for (let i = 0; i < length; i += 1) {\n      // Note that we deserialize directly to the Move value, not its Script argument representation.\n      // We are abstracting away the Script argument representation because knowing about it is\n      // functionally useless.\n      const scriptArgument = deserializeFromScriptArgument(deserializer);\n      args.push(scriptArgument);\n    }\n    return new Script(bytecode, type_args, args);\n  }\n}\n\n/**\n * Representation of a MultiSig that can serialized and deserialized\n */\nexport class MultiSig {\n  public readonly multisig_address: AccountAddress;\n\n  public readonly transaction_payload?: MultisigTransactionPayload;\n\n  /**\n   * Contains the payload to run a multi-sig account transaction.\n   *\n   * @param multisig_address The multi-sig account address the transaction will be executed as.\n   *\n   * @param transaction_payload The payload of the multi-sig transaction. This is optional when executing a multi-sig\n   *  transaction whose payload is already stored on chain.\n   */\n  constructor(multisig_address: AccountAddress, transaction_payload?: MultisigTransactionPayload) {\n    this.multisig_address = multisig_address;\n    this.transaction_payload = transaction_payload;\n  }\n\n  serialize(serializer: Serializer): void {\n    this.multisig_address.serialize(serializer);\n    // Options are encoded with an extra u8 field before the value - 0x0 is none and 0x1 is present.\n    // We use serializeBool below to create this prefix value.\n    if (this.transaction_payload === undefined) {\n      serializer.serializeBool(false);\n    } else {\n      serializer.serializeBool(true);\n      this.transaction_payload.serialize(serializer);\n    }\n  }\n\n  static deserialize(deserializer: Deserializer): MultiSig {\n    const multisig_address = AccountAddress.deserialize(deserializer);\n    const payloadPresent = deserializer.deserializeBool();\n    let transaction_payload;\n    if (payloadPresent) {\n      transaction_payload = MultisigTransactionPayload.deserialize(deserializer);\n    }\n    return new MultiSig(multisig_address, transaction_payload);\n  }\n}\n\n/**\n * Representation of a MultiSig Transaction Payload from `multisig_account.move`\n * that can be serialized and deserialized\n\n * This class exists right now to represent an extensible transaction payload class for\n * transactions used in `multisig_account.move`. Eventually, this class will be able to\n * support script payloads when the `multisig_account.move` module supports them.\n */\nexport class MultisigTransactionPayload {\n  public readonly transaction_payload: EntryFunction;\n\n  /**\n   * Contains the payload to run a multi-sig account transaction.\n   *\n   * @param transaction_payload The payload of the multi-sig transaction.\n   * This can only be EntryFunction for now but,\n   * Script might be supported in the future.\n   */\n  constructor(transaction_payload: EntryFunction) {\n    this.transaction_payload = transaction_payload;\n  }\n\n  serialize(serializer: Serializer): void {\n    /**\n     * We can support multiple types of inner transaction payload in the future.\n     * For now, it's only EntryFunction but if we support more types,\n     * we need to serialize with the right enum values here\n     */\n    serializer.serializeU32AsUleb128(0);\n    this.transaction_payload.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): MultisigTransactionPayload {\n    // This is the enum value indicating which type of payload the multi-sig transaction contains.\n    deserializer.deserializeUleb128AsU32();\n    return new MultisigTransactionPayload(EntryFunction.deserialize(deserializer));\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializable, Serializer } from \"../../bcs/serializer\";\nimport { ChainId } from \"./chainId\";\nimport { AccountAddress } from \"../../core\";\nimport { TransactionPayload } from \"./transactionPayload\";\nimport { TransactionVariants } from \"../../types\";\n\n/**\n * Representation of a Raw Transaction that can serialized and deserialized\n */\nexport class RawTransaction extends Serializable {\n  public readonly sender: AccountAddress;\n\n  public readonly sequence_number: bigint;\n\n  public readonly payload: TransactionPayload;\n\n  public readonly max_gas_amount: bigint;\n\n  public readonly gas_unit_price: bigint;\n\n  public readonly expiration_timestamp_secs: bigint;\n\n  public readonly chain_id: ChainId;\n\n  /**\n   * RawTransactions contain the metadata and payloads that can be submitted to Aptos chain for execution.\n   * RawTransactions must be signed before Aptos chain can execute them.\n   *\n   * @param sender The sender Account Address\n   * @param sequence_number Sequence number of this transaction. This must match the sequence number stored in\n   *   the sender's account at the time the transaction executes.\n   * @param payload Instructions for the Aptos Blockchain, including publishing a module,\n   *   execute an entry function or execute a script payload.\n   * @param max_gas_amount Maximum total gas to spend for this transaction. The account must have more\n   *   than this gas or the transaction will be discarded during validation.\n   * @param gas_unit_price Price to be paid per gas unit.\n   * @param expiration_timestamp_secs The blockchain timestamp at which the blockchain would discard this transaction.\n   * @param chain_id The chain ID of the blockchain that this transaction is intended to be run on.\n   */\n  constructor(\n    sender: AccountAddress,\n    sequence_number: bigint,\n    payload: TransactionPayload,\n    max_gas_amount: bigint,\n    gas_unit_price: bigint,\n    expiration_timestamp_secs: bigint,\n    chain_id: ChainId,\n  ) {\n    super();\n    this.sender = sender;\n    this.sequence_number = sequence_number;\n    this.payload = payload;\n    this.max_gas_amount = max_gas_amount;\n    this.gas_unit_price = gas_unit_price;\n    this.expiration_timestamp_secs = expiration_timestamp_secs;\n    this.chain_id = chain_id;\n  }\n\n  serialize(serializer: Serializer): void {\n    this.sender.serialize(serializer);\n    serializer.serializeU64(this.sequence_number);\n    this.payload.serialize(serializer);\n    serializer.serializeU64(this.max_gas_amount);\n    serializer.serializeU64(this.gas_unit_price);\n    serializer.serializeU64(this.expiration_timestamp_secs);\n    this.chain_id.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): RawTransaction {\n    const sender = AccountAddress.deserialize(deserializer);\n    const sequence_number = deserializer.deserializeU64();\n    const payload = TransactionPayload.deserialize(deserializer);\n    const max_gas_amount = deserializer.deserializeU64();\n    const gas_unit_price = deserializer.deserializeU64();\n    const expiration_timestamp_secs = deserializer.deserializeU64();\n    const chain_id = ChainId.deserialize(deserializer);\n    return new RawTransaction(\n      sender,\n      sequence_number,\n      payload,\n      max_gas_amount,\n      gas_unit_price,\n      expiration_timestamp_secs,\n      chain_id,\n    );\n  }\n}\n\n/**\n * Representation of a Raw Transaction With Data that can serialized and deserialized\n */\nexport abstract class RawTransactionWithData extends Serializable {\n  /**\n   * Serialize a Raw Transaction With Data\n   */\n  abstract serialize(serializer: Serializer): void;\n\n  /**\n   * Deserialize a Raw Transaction With Data\n   */\n  static deserialize(deserializer: Deserializer): RawTransactionWithData {\n    // index enum variant\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case TransactionVariants.MultiAgentTransaction:\n        return MultiAgentRawTransaction.load(deserializer);\n      case TransactionVariants.FeePayerTransaction:\n        return FeePayerRawTransaction.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for RawTransactionWithData: ${index}`);\n    }\n  }\n}\n\n/**\n * Representation of a Multi Agent Transaction that can serialized and deserialized\n */\nexport class MultiAgentRawTransaction extends RawTransactionWithData {\n  /**\n   * The raw transaction\n   */\n  public readonly raw_txn: RawTransaction;\n\n  /**\n   * The secondary signers on this transaction\n   */\n  public readonly secondary_signer_addresses: Array<AccountAddress>;\n\n  constructor(raw_txn: RawTransaction, secondary_signer_addresses: Array<AccountAddress>) {\n    super();\n    this.raw_txn = raw_txn;\n    this.secondary_signer_addresses = secondary_signer_addresses;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionVariants.MultiAgentTransaction);\n    this.raw_txn.serialize(serializer);\n    serializer.serializeVector(this.secondary_signer_addresses);\n  }\n\n  static load(deserializer: Deserializer): MultiAgentRawTransaction {\n    const rawTxn = RawTransaction.deserialize(deserializer);\n    const secondarySignerAddresses = deserializer.deserializeVector(AccountAddress);\n\n    return new MultiAgentRawTransaction(rawTxn, secondarySignerAddresses);\n  }\n}\n\n/**\n * Representation of a Fee Payer Transaction that can serialized and deserialized\n */\nexport class FeePayerRawTransaction extends RawTransactionWithData {\n  /**\n   * The raw transaction\n   */\n  public readonly raw_txn: RawTransaction;\n\n  /**\n   * The secondary signers on this transaction - optional and can be empty\n   */\n  public readonly secondary_signer_addresses: Array<AccountAddress>;\n\n  /**\n   * The fee payer account address\n   */\n  public readonly fee_payer_address: AccountAddress;\n\n  constructor(\n    raw_txn: RawTransaction,\n    secondary_signer_addresses: Array<AccountAddress>,\n    fee_payer_address: AccountAddress,\n  ) {\n    super();\n    this.raw_txn = raw_txn;\n    this.secondary_signer_addresses = secondary_signer_addresses;\n    this.fee_payer_address = fee_payer_address;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(TransactionVariants.FeePayerTransaction);\n    this.raw_txn.serialize(serializer);\n    serializer.serializeVector(this.secondary_signer_addresses);\n    this.fee_payer_address.serialize(serializer);\n  }\n\n  static load(deserializer: Deserializer): FeePayerRawTransaction {\n    const rawTxn = RawTransaction.deserialize(deserializer);\n    const secondarySignerAddresses = deserializer.deserializeVector(AccountAddress);\n    const feePayerAddress = AccountAddress.deserialize(deserializer);\n\n    return new FeePayerRawTransaction(rawTxn, secondarySignerAddresses, feePayerAddress);\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { TransactionAuthenticator } from \"../authenticator/transaction\";\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializable, Serializer } from \"../../bcs/serializer\";\nimport { RawTransaction } from \"./rawTransaction\";\n\nexport class SignedTransaction extends Serializable {\n  public readonly raw_txn: RawTransaction;\n\n  public readonly authenticator: TransactionAuthenticator;\n\n  /**\n   * A SignedTransaction consists of a raw transaction and an authenticator. The authenticator\n   * contains a client's public key and the signature of the raw transaction.\n   *\n   * @see {@link https://aptos.dev/integration/creating-a-signed-transaction | Creating a Signed Transaction}\n   *\n   * @param raw_txn\n   * @param authenticator Contains a client's public key and the signature of the raw transaction.\n   * Authenticator has 3 flavors: single signature, multi-signature and multi-agent.\n   * @see {@link https://github.com/aptos-labs/aptos-core/blob/main/types/src/transaction/authenticator.rs} for details.\n   */\n  constructor(raw_txn: RawTransaction, authenticator: TransactionAuthenticator) {\n    super();\n    this.raw_txn = raw_txn;\n    this.authenticator = authenticator;\n  }\n\n  serialize(serializer: Serializer): void {\n    this.raw_txn.serialize(serializer);\n    this.authenticator.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): SignedTransaction {\n    const raw_txn = RawTransaction.deserialize(deserializer);\n    const authenticator = TransactionAuthenticator.deserialize(deserializer);\n    return new SignedTransaction(raw_txn, authenticator);\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  StructTag,\n  TypeTag,\n  TypeTagAddress,\n  TypeTagBool,\n  TypeTagGeneric,\n  TypeTagReference,\n  TypeTagSigner,\n  TypeTagStruct,\n  TypeTagU128,\n  TypeTagU16,\n  TypeTagU256,\n  TypeTagU32,\n  TypeTagU64,\n  TypeTagU8,\n  TypeTagVector,\n} from \".\";\nimport { AccountAddress } from \"../../core\";\nimport { Identifier } from \"../instances/identifier\";\n\nfunction isValidIdentifier(str: string) {\n  return !!str.match(/^[_a-zA-Z0-9]+$/);\n}\n\nfunction isValidWhitespaceCharacter(char: string) {\n  return !!char.match(/\\s/);\n}\n\nfunction consumeWhitespace(tagStr: string, pos: number) {\n  let i = pos;\n  for (; i < tagStr.length; i += 1) {\n    const innerChar = tagStr[i];\n\n    if (!isValidWhitespaceCharacter(innerChar)) {\n      // If it's not colons, and it's an invalid character, we will stop here\n      break;\n    }\n  }\n  return i;\n}\n\ntype TypeTagState = {\n  savedExpectedTypes: number;\n  savedStr: string;\n  savedTypes: Array<TypeTag>;\n};\n\nexport enum TypeTagParserErrorType {\n  InvalidTypeTag = \"unknown type\",\n  UnexpectedTypeArgumentClose = \"unexpected '>'\",\n  UnexpectedWhitespaceCharacter = \"unexpected whitespace character\",\n  UnexpectedComma = \"unexpected ','\",\n  TypeArgumentCountMismatch = \"type argument count doesn't match expected amount\",\n  MissingTypeArgumentClose = \"no matching '>' for '<'\",\n  UnexpectedPrimitiveTypeArguments = \"primitive types not expected to have type arguments\",\n  UnexpectedVectorTypeArgumentCount = \"vector type expected to have exactly one type argument\",\n  UnexpectedStructFormat = \"unexpected struct format, must be of the form 0xaddress::module_name::struct_name\",\n  InvalidModuleNameCharacter = \"module name must only contain alphanumeric or '_' characters\",\n  InvalidStructNameCharacter = \"struct name must only contain alphanumeric or '_' characters\",\n}\n\nexport class TypeTagParserError extends Error {\n  constructor(typeTagStr: string, invalidReason: TypeTagParserErrorType) {\n    super(`Failed to parse typeTag '${typeTagStr}', ${invalidReason}`);\n  }\n}\n\n/**\n * All types are made of a few parts they're either:\n * 1. A simple type e.g. u8\n * 2. A standalone struct e.g. 0x1::account::Account\n * 3. A nested struct e.g. 0x1::coin::Coin<0x1234::coin::MyCoin>\n *\n * There are a few more special cases that need to be handled, however.\n * 1. Multiple generics e.g 0x1::pair::Pair<u8, u16>\n * 2. Spacing in the generics e.g. 0x1::pair::Pair< u8 , u16>\n * 3. Nested generics of different depths e.g. 0x1::pair::Pair<0x1::coin::Coin<0x1234::coin::MyCoin>, u8>\n * 4. Generics for types in ABIs are filled in with placeholders e.g T1, T2, T3\n */\nexport function parseTypeTag(typeStr: string, options?: { allowGenerics?: boolean }) {\n  const allowGenerics = options?.allowGenerics ?? false;\n\n  const saved: Array<TypeTagState> = [];\n  // This represents the internal types for a type tag e.g. '0x1::coin::Coin<innerTypes>'\n  let innerTypes: Array<TypeTag> = [];\n  // This represents the current parsed types in a comma list e.g. 'u8, u8'\n  let curTypes: Array<TypeTag> = [];\n  // This represents the current character index\n  let cur: number = 0;\n  // This represents the current working string as a type or struct name\n  let currentStr: string = \"\";\n  let expectedTypes: number = 1;\n\n  // Iterate through each character, and handle the border conditions\n  while (cur < typeStr.length) {\n    const char = typeStr[cur];\n\n    if (char === \"<\") {\n      // Start of a type argument, push current state onto a stack\n      saved.push({\n        savedExpectedTypes: expectedTypes,\n        savedStr: currentStr,\n        savedTypes: curTypes,\n      });\n\n      // Clear current state\n      currentStr = \"\";\n      curTypes = [];\n      expectedTypes = 1;\n    } else if (char === \">\") {\n      // Process last type, if there is no type string, then don't parse it\n      if (currentStr !== \"\") {\n        const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);\n        curTypes.push(newType);\n      }\n\n      // Pop off stack outer type, if there's nothing left, there were too many '>'\n      const savedPop = saved.pop();\n      if (savedPop === undefined) {\n        throw new TypeTagParserError(typeStr, TypeTagParserErrorType.UnexpectedTypeArgumentClose);\n      }\n\n      // If the expected types don't match the number of commas, then we also fail\n      if (expectedTypes !== curTypes.length) {\n        throw new TypeTagParserError(typeStr, TypeTagParserErrorType.TypeArgumentCountMismatch);\n      }\n\n      // Add in the new created type, shifting the current types to the inner types\n      const { savedStr, savedTypes, savedExpectedTypes } = savedPop;\n      innerTypes = curTypes;\n      curTypes = savedTypes;\n      currentStr = savedStr;\n      expectedTypes = savedExpectedTypes;\n    } else if (char === \",\") {\n      // Comma means we need to start parsing a new tag, push the previous one to the curTypes\n      // Process last type, if there is no type string, then don't parse it\n      if (currentStr.length !== 0) {\n        const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);\n\n        // parse type tag and push it on the types\n        innerTypes = [];\n        curTypes.push(newType);\n        currentStr = \"\";\n        expectedTypes += 1;\n      }\n    } else if (isValidWhitespaceCharacter(char)) {\n      // This means we should save what we have and everything else should skip until the next\n      let parsedTypeTag = false;\n      if (currentStr.length !== 0) {\n        const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);\n\n        // parse type tag and push it on the types\n        innerTypes = [];\n        curTypes.push(newType);\n        currentStr = \"\";\n        parsedTypeTag = true;\n      }\n\n      // Skip ahead on any more whitespace\n      cur = consumeWhitespace(typeStr, cur);\n\n      // The next space MUST be a comma, or a closing > if there was something parsed before\n      // e.g. `u8 u8` is invalid but `u8, u8` is valid\n      const nextChar = typeStr[cur];\n      if (cur < typeStr.length && parsedTypeTag && nextChar !== \",\" && nextChar !== \">\") {\n        throw new TypeTagParserError(typeStr, TypeTagParserErrorType.UnexpectedWhitespaceCharacter);\n      }\n\n      // eslint-disable-next-line no-continue\n      continue;\n    } else {\n      // Any other characters just append to the current string\n      currentStr += char;\n    }\n\n    cur += 1;\n  }\n\n  // This prevents a missing '>' on type arguments\n  if (saved.length > 0) {\n    throw new TypeTagParserError(typeStr, TypeTagParserErrorType.MissingTypeArgumentClose);\n  }\n\n  // This prevents 'u8, u8' as an input\n  switch (curTypes.length) {\n    case 0:\n      return parseTypeTagInner(currentStr, innerTypes, allowGenerics);\n    case 1:\n      if (currentStr === \"\") {\n        return curTypes[0];\n      }\n      throw new TypeTagParserError(typeStr, TypeTagParserErrorType.UnexpectedComma);\n    default:\n      throw new TypeTagParserError(typeStr, TypeTagParserErrorType.UnexpectedWhitespaceCharacter);\n  }\n}\n\n/**\n * Parses a type tag with internal types associated\n * @param str\n * @param types\n */\nfunction parseTypeTagInner(str: string, types: Array<TypeTag>, allowGenerics: boolean): TypeTag {\n  // TODO: Parse references to any item not just signer\n  switch (str) {\n    case \"&signer\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedPrimitiveTypeArguments);\n      }\n      return new TypeTagReference(new TypeTagSigner());\n    case \"signer\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedPrimitiveTypeArguments);\n      }\n      return new TypeTagSigner();\n    case \"bool\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedPrimitiveTypeArguments);\n      }\n      return new TypeTagBool();\n    case \"address\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedPrimitiveTypeArguments);\n      }\n      return new TypeTagAddress();\n    case \"u8\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedPrimitiveTypeArguments);\n      }\n      return new TypeTagU8();\n    case \"u16\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedPrimitiveTypeArguments);\n      }\n      return new TypeTagU16();\n    case \"u32\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedPrimitiveTypeArguments);\n      }\n      return new TypeTagU32();\n    case \"u64\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedPrimitiveTypeArguments);\n      }\n      return new TypeTagU64();\n    case \"u128\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedPrimitiveTypeArguments);\n      }\n      return new TypeTagU128();\n    case \"u256\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedPrimitiveTypeArguments);\n      }\n      return new TypeTagU256();\n    case \"vector\":\n      if (types.length !== 1) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedVectorTypeArgumentCount);\n      }\n      return new TypeTagVector(types[0]);\n    default:\n      if (allowGenerics && str.match(/^T[0-9]+$/)) {\n        return new TypeTagGeneric(Number(str.split(\"T\")[1]));\n      }\n\n      // If the value doesn't contain a colon, then we'll assume it isn't trying to be a struct\n      if (!str.match(/.*:.*/)) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.InvalidTypeTag);\n      }\n\n      // Parse for a struct tag\n      // eslint-disable-next-line no-case-declarations\n      const structParts = str.split(\"::\");\n      if (structParts.length !== 3) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.UnexpectedStructFormat);\n      }\n\n      // Validate identifier characters\n      if (!isValidIdentifier(structParts[1])) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.InvalidModuleNameCharacter);\n      }\n      if (!isValidIdentifier(structParts[2])) {\n        throw new TypeTagParserError(str, TypeTagParserErrorType.InvalidStructNameCharacter);\n      }\n\n      return new TypeTagStruct(\n        new StructTag(\n          AccountAddress.fromString(structParts[0]),\n          new Identifier(structParts[1]),\n          new Identifier(structParts[2]),\n          types,\n        ),\n      );\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  EntryFunctionArgumentTypes,\n  InputGenerateTransactionPayloadData,\n  InputGenerateTransactionPayloadDataWithRemoteABI,\n  InputScriptData,\n  SimpleEntryFunctionArgumentTypes,\n} from \"../types\";\nimport { Bool, FixedBytes, MoveString, U128, U16, U256, U32, U64, U8 } from \"../../bcs\";\nimport { AccountAddress } from \"../../core\";\nimport { MoveFunction, MoveStructType } from \"../../types\";\n\nexport function isBool(arg: SimpleEntryFunctionArgumentTypes): arg is boolean {\n  return typeof arg === \"boolean\";\n}\n\nexport function isString(arg: any): arg is string {\n  return typeof arg === \"string\";\n}\n\nexport function isNumber(arg: SimpleEntryFunctionArgumentTypes): arg is number {\n  return typeof arg === \"number\";\n}\n\nexport function isLargeNumber(arg: SimpleEntryFunctionArgumentTypes): arg is number | bigint | string {\n  return typeof arg === \"number\" || typeof arg === \"bigint\" || typeof arg === \"string\";\n}\n\nexport function isNull(arg: SimpleEntryFunctionArgumentTypes): arg is null | undefined {\n  return arg === null || arg === undefined;\n}\n\nexport function isBcsBool(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is Bool {\n  return arg instanceof Bool;\n}\nexport function isBcsAddress(\n  arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes,\n): arg is AccountAddress {\n  return arg instanceof AccountAddress;\n}\nexport function isBcsString(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is MoveString {\n  return arg instanceof MoveString;\n}\nexport function isBcsFixedBytes(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is FixedBytes {\n  return arg instanceof FixedBytes;\n}\n\nexport function isBcsU8(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is U8 {\n  return arg instanceof U8;\n}\nexport function isBcsU16(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is U16 {\n  return arg instanceof U16;\n}\nexport function isBcsU32(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is U32 {\n  return arg instanceof U32;\n}\nexport function isBcsU64(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is U64 {\n  return arg instanceof U64;\n}\nexport function isBcsU128(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is U128 {\n  return arg instanceof U128;\n}\nexport function isBcsU256(arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes): arg is U256 {\n  return arg instanceof U256;\n}\n\nexport function isScriptDataInput(\n  arg: InputGenerateTransactionPayloadDataWithRemoteABI | InputGenerateTransactionPayloadData,\n): arg is InputScriptData {\n  return \"bytecode\" in arg;\n}\n\nexport function throwTypeMismatch(expectedType: string, position: number) {\n  throw new Error(`Type mismatch for argument ${position}, expected '${expectedType}'`);\n}\n\n/**\n * Finds first non-signer arg.\n *\n * A function is often defined with a `signer` or `&signer` arguments at the start, which are filled in\n * by signatures, and not by the caller.\n * @param functionAbi\n */\nexport function findFirstNonSignerArg(functionAbi: MoveFunction): number {\n  return functionAbi.params.findIndex((param) => param !== \"signer\" && param !== \"&signer\");\n}\n\nexport function getFunctionParts(functionArg: MoveStructType) {\n  const funcNameParts = functionArg.split(\"::\");\n  if (funcNameParts.length !== 3) {\n    throw new Error(`Invalid function ${functionArg}`);\n  }\n  const moduleAddress = funcNameParts[0];\n  const moduleName = funcNameParts[1];\n  const functionName = funcNameParts[2];\n  return { moduleAddress, moduleName, functionName };\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { parseTypeTag } from \"../typeTag/parser\";\nimport { TypeTag, TypeTagStruct } from \"../typeTag\";\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport { EntryFunctionArgumentTypes, SimpleEntryFunctionArgumentTypes, EntryFunctionABI } from \"../types\";\nimport { Bool, MoveOption, MoveString, MoveVector, U128, U16, U256, U32, U64, U8 } from \"../../bcs\";\nimport { AccountAddress, Hex } from \"../../core\";\nimport { getModule } from \"../../internal/account\";\nimport {\n  findFirstNonSignerArg,\n  isBcsAddress,\n  isBcsBool,\n  isBcsFixedBytes,\n  isBcsString,\n  isBcsU128,\n  isBcsU16,\n  isBcsU256,\n  isBcsU32,\n  isBcsU64,\n  isBcsU8,\n  isBool,\n  isLargeNumber,\n  isNull,\n  isNumber,\n  isString,\n  throwTypeMismatch,\n} from \"./helpers\";\n\n/**\n * Convert type arguments to only type tags, allowing for string representations of type tags\n */\nexport function standardizeTypeTags(typeArguments?: Array<TypeTag | string>): Array<TypeTag> {\n  return (\n    typeArguments?.map((typeArg: string | TypeTag): TypeTag => {\n      // Convert to TypeTag if it's a string representation\n      if (isString(typeArg)) {\n        return parseTypeTag(typeArg);\n      }\n      return typeArg;\n    }) ?? []\n  );\n}\n\n/**\n * Fetches the ABI for an entry function from the module\n *\n * @param moduleAddress\n * @param moduleName\n * @param functionName\n * @param aptosConfig\n */\nexport async function fetchEntryFunctionAbi(\n  moduleAddress: string,\n  moduleName: string,\n  functionName: string,\n  aptosConfig: AptosConfig,\n): Promise<EntryFunctionABI> {\n  // This fetch from the API is currently cached\n  const module = await getModule({ aptosConfig, accountAddress: moduleAddress, moduleName });\n\n  const functionAbi = module.abi?.exposed_functions.find((func) => func.name === functionName);\n\n  // If there's no ABI, then the function is invalid\n  if (!functionAbi) {\n    throw new Error(`Could not find entry function ABI for '${moduleAddress}::${moduleName}::${functionName}'`);\n  }\n\n  // Non-entry functions also can't be used\n  if (!functionAbi.is_entry) {\n    throw new Error(`'${moduleAddress}::${moduleName}::${functionName}' is not an entry function`);\n  }\n\n  // Remove the signer arguments\n  const first = findFirstNonSignerArg(functionAbi);\n  const params = [];\n  for (let i = first; i < functionAbi.params.length; i += 1) {\n    params.push(parseTypeTag(functionAbi.params[i], { allowGenerics: true }));\n  }\n\n  return {\n    typeParameters: functionAbi.generic_type_params,\n    parameters: params,\n  };\n}\n\n/**\n * Converts a non-BCS encoded argument into BCS encoded, if necessary\n * @param functionName\n * @param functionAbi\n * @param arg\n * @param position\n */\nexport function convertArgument(\n  functionName: string,\n  functionAbi: EntryFunctionABI,\n  arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes,\n  position: number,\n  genericTypeParams: Array<TypeTag>,\n) {\n  // Ensure not too many arguments\n  if (position >= functionAbi.parameters.length) {\n    throw new Error(`Too many arguments for '${functionName}', expected ${functionAbi.parameters.length}`);\n  }\n\n  // If the argument is bcs encoded, we can just use it directly\n  if (\n    isBcsBool(arg) ||\n    isBcsU8(arg) ||\n    isBcsU16(arg) ||\n    isBcsU32(arg) ||\n    isBcsU64(arg) ||\n    isBcsU128(arg) ||\n    isBcsU256(arg) ||\n    isBcsAddress(arg) ||\n    isBcsString(arg) ||\n    isBcsFixedBytes(arg) ||\n    arg instanceof MoveVector ||\n    arg instanceof MoveOption\n  ) {\n    // Ensure the type matches the ABI\n    checkType(functionAbi, arg, position);\n    return arg;\n  }\n\n  // If it is not BCS encoded, we will need to convert it with the ABI\n  return parseArg(arg, functionAbi.parameters[position], position, genericTypeParams);\n}\n\n/**\n * Parses a non-BCS encoded argument into a BCS encoded argument recursively\n * @param arg\n * @param param\n * @param position\n * @param genericTypeParams\n */\nfunction parseArg(\n  arg: SimpleEntryFunctionArgumentTypes,\n  param: TypeTag,\n  position: number,\n  genericTypeParams: Array<TypeTag>,\n): EntryFunctionArgumentTypes {\n  if (param.isBool()) {\n    if (isBool(arg)) {\n      return new Bool(arg);\n    }\n    throwTypeMismatch(\"boolean\", position);\n  }\n  // TODO: support uint8array?\n  if (param.isAddress()) {\n    if (isString(arg)) {\n      return AccountAddress.fromString(arg);\n    }\n    throwTypeMismatch(\"string\", position);\n  }\n  if (param.isU8()) {\n    if (isNumber(arg)) {\n      return new U8(arg);\n    }\n    throwTypeMismatch(\"number\", position);\n  }\n  if (param.isU16()) {\n    if (isNumber(arg)) {\n      return new U16(arg);\n    }\n    throwTypeMismatch(\"number\", position);\n  }\n  if (param.isU32()) {\n    if (isNumber(arg)) {\n      return new U32(arg);\n    }\n    throwTypeMismatch(\"number\", position);\n  }\n  if (param.isU64()) {\n    if (isLargeNumber(arg)) {\n      return new U64(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n  if (param.isU128()) {\n    if (isLargeNumber(arg)) {\n      return new U128(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n  if (param.isU256()) {\n    if (isLargeNumber(arg)) {\n      return new U256(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n\n  // Generic needs to use the sub-type\n  if (param.isGeneric()) {\n    const genericIndex = param.value;\n    if (genericIndex < 0 || genericIndex >= genericTypeParams.length) {\n      throw new Error(`Generic argument ${param.toString()} is invalid for argument ${position}`);\n    }\n\n    parseArg(arg, genericTypeParams[genericIndex], position, genericTypeParams);\n  }\n\n  // We have to special case some vectors for Vector<u8>\n  if (param.isVector()) {\n    // Check special case for Vector<u8>\n    if (param.value.isU8() && isString(arg)) {\n      // TODO: Improve message when hex is invalid\n      return MoveVector.U8(Hex.fromHexInput(arg).toUint8Array());\n    }\n\n    if (Array.isArray(arg)) {\n      return new MoveVector(arg.map((item) => parseArg(item, param.value, position, genericTypeParams)));\n    }\n\n    throw new Error(`Type mismatch for argument ${position}, type '${param.toString()}'`);\n  }\n\n  // Handle structs as they're more complex\n  if (param.isStruct()) {\n    if (param.isString()) {\n      if (isString(arg)) {\n        return new MoveString(arg);\n      }\n      throwTypeMismatch(\"string\", position);\n    }\n    if (param.isObject()) {\n      // The inner type of Object doesn't matter, since it's just syntactic sugar\n      if (isString(arg)) {\n        return AccountAddress.fromString(arg);\n      }\n      throwTypeMismatch(\"string\", position);\n    }\n\n    if (param.isOption()) {\n      // Empty option must be handled specially\n      if (isNull(arg)) {\n        // Note: This is a placeholder U8 type, and does not match the actual type, as that can't be dynamically grabbed\n        return new MoveOption<U8>(null);\n      }\n\n      return new MoveOption(parseArg(arg, param.value.type_args[0], position, genericTypeParams));\n    }\n\n    throw new Error(`Unsupported struct input type for argument ${position}, type '${param.toString()}'`);\n  }\n\n  throw new Error(`Type mismatch for argument ${position}, type '${param.toString()}'`);\n}\n\n/**\n * Checks that the type of an already BCS encoded argument matches the ABI\n * @param functionAbi\n * @param arg\n * @param position\n */\nfunction checkType(functionAbi: EntryFunctionABI, arg: EntryFunctionArgumentTypes, position: number) {\n  const param = functionAbi.parameters[position];\n  if (param.isBool()) {\n    if (isBcsBool(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"Bool\", position);\n  }\n  if (param.isAddress()) {\n    if (isBcsAddress(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"AccountAddress\", position);\n  }\n  if (param.isU8()) {\n    if (isBcsU8(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U8\", position);\n  }\n  if (param.isU16()) {\n    if (isBcsU16(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U16\", position);\n  }\n  if (param.isU32()) {\n    if (isBcsU32(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U32\", position);\n  }\n  if (param.isU64()) {\n    if (isBcsU64(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U64\", position);\n  }\n  if (param.isU128()) {\n    if (isBcsU128(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U128\", position);\n  }\n  if (param.isU256()) {\n    if (isBcsU256(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U256\", position);\n  }\n  if (param.isVector()) {\n    if (arg instanceof MoveVector) {\n      // TODO: More introspection to verify the type\n      return;\n    }\n    throwTypeMismatch(\"MoveVector\", position);\n  }\n\n  // Handle structs as they're more complex\n  if (param instanceof TypeTagStruct) {\n    if (param.isString()) {\n      if (isBcsString(arg)) {\n        return;\n      }\n      throwTypeMismatch(\"MoveString\", position);\n    }\n    if (param.isObject()) {\n      if (isBcsAddress(arg)) {\n        return;\n      }\n      throwTypeMismatch(\"AccountAddress\", position);\n    }\n    if (param.isOption()) {\n      if (arg instanceof MoveOption) {\n        // TODO: more introspection for the type\n        return;\n      }\n      throwTypeMismatch(\"MoveOption\", position);\n    }\n  }\n\n  throw new Error(`Type mismatch for argument ${position}, expected '${param.toString()}'`);\n}\n","/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/transaction_submission}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * transaction_submission namespace and without having a dependency cycle error.\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { MoveVector } from \"../bcs\";\nimport { postAptosFullNode } from \"../client\";\nimport { Account } from \"../core/account\";\nimport { AccountAuthenticator } from \"../transactions/authenticator/account\";\nimport {\n  buildTransaction,\n  generateTransactionPayload,\n  generateSignedTransactionForSimulation,\n  generateSignedTransaction,\n  sign,\n} from \"../transactions/transactionBuilder/transactionBuilder\";\nimport {\n  InputGenerateTransactionData,\n  AnyRawTransaction,\n  InputSimulateTransactionData,\n  InputGenerateTransactionOptions,\n  InputSingleSignerTransaction,\n  InputGenerateTransactionPayloadDataWithRemoteABI,\n} from \"../transactions/types\";\nimport { UserTransactionResponse, PendingTransactionResponse, MimeType, HexInput } from \"../types\";\n\n/**\n * Generates any transaction by passing in the required arguments\n *\n * @param args.sender The transaction sender's account address as a HexInput\n * @param args.data EntryFunctionData | ScriptData | MultiSigData\n * @param args.feePayerAddress optional. For a fee payer (aka sponsored) transaction\n * @param args.secondarySignerAddresses optional. For a multi-agent or fee payer (aka sponsored) transactions\n * @param args.options optional. GenerateTransactionOptions type\n *\n * @example\n * For a single signer entry function\n * move function name, move function type arguments, move function arguments\n * `\n * data: {\n *  function:\"0x1::aptos_account::transfer\",\n *  typeArguments:[]\n *  functionArguments :[receiverAddress,10]\n * }\n * `\n *\n * @example\n * For a single signer script function\n * module bytecode, move function type arguments, move function arguments\n * ```\n * data: {\n *  bytecode:\"0x001234567\",\n *  typeArguments:[],\n *  functionArguments :[receiverAddress,10]\n * }\n * ```\n *\n * @return A raw transaction type (note that it holds the raw transaction as a bcs serialized data)\n * ```\n * {\n *  rawTransaction: Uint8Array,\n *  secondarySignerAddresses? : Array<AccountAddress>,\n *  feePayerAddress?: AccountAddress\n * }\n * ```\n */\nexport async function generateTransaction(\n  args: { aptosConfig: AptosConfig } & InputGenerateTransactionData,\n): Promise<AnyRawTransaction> {\n  const { aptosConfig, sender, data, options, secondarySignerAddresses, feePayerAddress } = args;\n\n  // Merge in aptosConfig for remote ABI on non-script payloads\n  let generateTransactionPayloadData: InputGenerateTransactionPayloadDataWithRemoteABI;\n  if (\"bytecode\" in data) {\n    generateTransactionPayloadData = data;\n  } else if (\"multisigAddress\" in data) {\n    generateTransactionPayloadData = {\n      aptosConfig,\n      multisigAddress: data.multisigAddress,\n      function: data.function,\n      functionArguments: data.functionArguments,\n      typeArguments: data.typeArguments,\n    };\n  } else {\n    generateTransactionPayloadData = {\n      aptosConfig,\n      function: data.function,\n      functionArguments: data.functionArguments,\n      typeArguments: data.typeArguments,\n    };\n  }\n  const payload = await generateTransactionPayload(generateTransactionPayloadData);\n  return buildTransaction({\n    aptosConfig,\n    sender,\n    payload,\n    options,\n    secondarySignerAddresses,\n    feePayerAddress,\n  });\n}\n\n/**\n * Sign a transaction that can later be submitted to chain\n *\n * @param args.signer The signer account to sign the transaction\n * @param args.transaction A raw transaction type (note that it holds the raw transaction as a bcs serialized data)\n * ```\n * {\n *  rawTransaction: Uint8Array,\n *  secondarySignerAddresses? : Array<AccountAddress>,\n *  feePayerAddress?: AccountAddress\n * }\n * ```\n *\n * @return The signer AccountAuthenticator\n */\nexport function signTransaction(args: { signer: Account; transaction: AnyRawTransaction }): AccountAuthenticator {\n  const accountAuthenticator = sign({ ...args });\n  return accountAuthenticator;\n}\n\n/**\n * Simulates a transaction before singing it.\n *\n * @param args.signerPublicKey The signer public key\n * @param args.transaction The raw transaction to simulate\n * @param args.secondarySignersPublicKeys optional. For when the transaction is a multi signers transaction\n * @param args.feePayerPublicKey optional. For when the transaction is a fee payer (aka sponsored) transaction\n * @param args.options optional. A config to simulate the transaction with\n */\nexport async function simulateTransaction(\n  args: { aptosConfig: AptosConfig } & InputSimulateTransactionData,\n): Promise<Array<UserTransactionResponse>> {\n  const { aptosConfig, transaction, signerPublicKey, secondarySignersPublicKeys, feePayerPublicKey, options } = args;\n\n  const signedTransaction = generateSignedTransactionForSimulation({\n    transaction,\n    signerPublicKey,\n    secondarySignersPublicKeys,\n    feePayerPublicKey,\n    options,\n  });\n\n  const { data } = await postAptosFullNode<Uint8Array, Array<UserTransactionResponse>>({\n    aptosConfig,\n    body: signedTransaction,\n    path: \"transactions/simulate\",\n    params: {\n      estimate_gas_unit_price: args.options?.estimateGasUnitPrice ?? false,\n      estimate_max_gas_amount: args.options?.estimateMaxGasAmount ?? false,\n      estimate_prioritized_gas_unit_price: args.options?.estimatePrioritizedGasUnitPrice ?? false,\n    },\n    originMethod: \"simulateTransaction\",\n    contentType: MimeType.BCS_SIGNED_TRANSACTION,\n  });\n  return data;\n}\n\n/**\n * Submit transaction to chain\n *\n * @param args.transaction A aptos transaction type\n * @param args.senderAuthenticator The account authenticator of the transaction sender\n * @param args.secondarySignerAuthenticators optional. For when the transaction is a multi signers transaction\n *\n * @return PendingTransactionResponse\n */\nexport async function submitTransaction(args: {\n  aptosConfig: AptosConfig;\n  transaction: AnyRawTransaction;\n  senderAuthenticator: AccountAuthenticator;\n  secondarySignerAuthenticators?: {\n    feePayerAuthenticator?: AccountAuthenticator;\n    additionalSignersAuthenticators?: Array<AccountAuthenticator>;\n  };\n}): Promise<PendingTransactionResponse> {\n  const { aptosConfig } = args;\n  const signedTransaction = generateSignedTransaction({ ...args });\n  const { data } = await postAptosFullNode<Uint8Array, PendingTransactionResponse>({\n    aptosConfig,\n    body: signedTransaction,\n    path: \"transactions\",\n    originMethod: \"submitTransaction\",\n    contentType: MimeType.BCS_SIGNED_TRANSACTION,\n  });\n  return data;\n}\n\nexport async function signAndSubmitTransaction(args: {\n  aptosConfig: AptosConfig;\n  signer: Account;\n  transaction: AnyRawTransaction;\n}): Promise<PendingTransactionResponse> {\n  const { aptosConfig, signer, transaction } = args;\n  const authenticator = signTransaction({ signer, transaction });\n  return submitTransaction({\n    aptosConfig,\n    transaction,\n    senderAuthenticator: authenticator,\n  });\n}\n\nexport async function publicPackageTransaction(args: {\n  aptosConfig: AptosConfig;\n  account: HexInput;\n  metadataBytes: HexInput;\n  moduleBytecode: Array<HexInput>;\n  options?: InputGenerateTransactionOptions;\n}): Promise<InputSingleSignerTransaction> {\n  const { aptosConfig, account, metadataBytes, moduleBytecode, options } = args;\n\n  const totalByteCode = moduleBytecode.map((bytecode) => MoveVector.U8(bytecode));\n\n  const transaction = await generateTransaction({\n    aptosConfig,\n    sender: account,\n    data: {\n      function: \"0x1::code::publish_package_txn\",\n      functionArguments: [MoveVector.U8(metadataBytes), new MoveVector(totalByteCode)],\n    },\n    options,\n  });\n  return transaction as InputSingleSignerTransaction;\n}\n","import { AptosConfig } from \"../api/aptosConfig\";\nimport { U64 } from \"../bcs/serializable/movePrimitives\";\nimport { Account, AccountAddress } from \"../core\";\nimport { InputGenerateTransactionOptions, InputSingleSignerTransaction } from \"../transactions/types\";\nimport { HexInput, AnyNumber, MoveStructType } from \"../types\";\nimport { APTOS_COIN } from \"../utils/const\";\nimport { generateTransaction } from \"./transactionSubmission\";\nimport { parseTypeTag } from \"../transactions/typeTag/parser\";\n\nexport async function transferCoinTransaction(args: {\n  aptosConfig: AptosConfig;\n  sender: Account;\n  recipient: HexInput;\n  amount: AnyNumber;\n  coinType?: MoveStructType;\n  options?: InputGenerateTransactionOptions;\n}): Promise<InputSingleSignerTransaction> {\n  const { aptosConfig, sender, recipient, amount, coinType, options } = args;\n  const coinStructType = coinType ?? APTOS_COIN;\n  const transaction = await generateTransaction({\n    aptosConfig,\n    sender: sender.accountAddress.toString(),\n    data: {\n      function: \"0x1::aptos_account::transfer_coins\",\n      typeArguments: [parseTypeTag(coinStructType)],\n      functionArguments: [AccountAddress.fromHexInput(recipient), new U64(amount)],\n    },\n    options,\n  });\n\n  return transaction as InputSingleSignerTransaction;\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AptosConfig } from \"./aptosConfig\";\nimport { Account } from \"../core\";\nimport { transferCoinTransaction } from \"../internal/coin\";\nimport { InputSingleSignerTransaction, InputGenerateTransactionOptions } from \"../transactions/types\";\nimport { AnyNumber, HexInput, MoveStructType } from \"../types\";\n\n/**\n * A class to handle all `Coin` operations\n */\nexport class Coin {\n  readonly config: AptosConfig;\n\n  constructor(config: AptosConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Generate a transfer coin transaction that can be simulated and/or signed and submitted\n   *\n   * @param args.sender The sender account\n   * @param args.recipient The recipient address\n   * @param args.amount The amount to transfer\n   * @param args.coinType optional. The coin struct type to transfer. Defaults to 0x1::aptos_coin::AptosCoin\n   *\n   * @returns SingleSignerTransaction\n   */\n  async transferCoinTransaction(args: {\n    sender: Account;\n    recipient: HexInput;\n    amount: AnyNumber;\n    coinType?: MoveStructType;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<InputSingleSignerTransaction> {\n    return transferCoinTransaction({ aptosConfig: this.config, ...args });\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/digitalAsset}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * digitalAsset namespace and without having a dependency cycle error.\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { MoveString, MoveVector, Bool, U64, U8 } from \"../bcs\";\nimport { Account, Hex } from \"../core\";\nimport { InputGenerateTransactionOptions, InputSingleSignerTransaction } from \"../transactions/types\";\nimport {\n  AnyNumber,\n  GetCollectionDataResponse,\n  GetCurrentTokenOwnershipResponse,\n  GetOwnedTokensResponse,\n  GetTokenActivityResponse,\n  GetTokenDataResponse,\n  HexInput,\n  OrderBy,\n  PaginationArgs,\n  TokenStandard,\n} from \"../types\";\nimport {\n  GetCollectionDataQuery,\n  GetCurrentTokenOwnershipQuery,\n  GetTokenActivityQuery,\n  GetTokenDataQuery,\n} from \"../types/generated/operations\";\nimport {\n  GetCollectionData,\n  GetCurrentTokenOwnership,\n  GetTokenActivity,\n  GetTokenData,\n} from \"../types/generated/queries\";\nimport { queryIndexer } from \"./general\";\nimport { generateTransaction } from \"./transactionSubmission\";\nimport { MAX_U64_BIG_INT } from \"../bcs/consts\";\nimport { CurrentTokenOwnershipsV2BoolExp, TokenActivitiesV2BoolExp } from \"../types/generated/types\";\n\n// TODO: Support properties when minting.\nexport interface MintTokenOptions {\n  propertyKeys?: Array<string>;\n  propertyTypes?: Array<string>;\n  propertyValues?: Array<string>;\n}\n\nexport async function mintTokenTransaction(args: {\n  aptosConfig: AptosConfig;\n  creator: Account;\n  collection: string;\n  description: string;\n  name: string;\n  uri: string;\n  options?: InputGenerateTransactionOptions;\n}): Promise<InputSingleSignerTransaction> {\n  const { aptosConfig, options, creator } = args;\n  const transaction = await generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress.toString(),\n    data: {\n      function: \"0x4::aptos_token::mint\",\n      functionArguments: [\n        new MoveString(args.collection),\n        new MoveString(args.description),\n        new MoveString(args.name),\n        new MoveString(args.uri),\n        MoveVector.MoveString([]),\n        MoveVector.MoveString([]),\n        new MoveVector<MoveVector<U8>>([]),\n      ],\n    },\n    options,\n  });\n  return transaction as InputSingleSignerTransaction;\n}\n\nexport async function getTokenData(args: {\n  aptosConfig: AptosConfig;\n  tokenAddress: HexInput;\n}): Promise<GetTokenDataResponse> {\n  const { aptosConfig, tokenAddress } = args;\n\n  const whereCondition: any = {\n    token_data_id: { _eq: Hex.fromHexInput(tokenAddress).toString() },\n  };\n\n  const graphqlQuery = {\n    query: GetTokenData,\n    variables: {\n      where_condition: whereCondition,\n    },\n  };\n\n  const data = await queryIndexer<GetTokenDataQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getTokenData\",\n  });\n\n  return data.current_token_datas_v2[0];\n}\n\nexport async function getCurrentTokenOwnership(args: {\n  aptosConfig: AptosConfig;\n  tokenAddress: HexInput;\n}): Promise<GetCurrentTokenOwnershipResponse> {\n  const { aptosConfig, tokenAddress } = args;\n\n  const whereCondition: CurrentTokenOwnershipsV2BoolExp = {\n    token_data_id: { _eq: Hex.fromHexInput(tokenAddress).toString() },\n  };\n\n  const graphqlQuery = {\n    query: GetCurrentTokenOwnership,\n    variables: {\n      where_condition: whereCondition,\n    },\n  };\n\n  const data = await queryIndexer<GetCurrentTokenOwnershipQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getCurrentTokenOwnership\",\n  });\n\n  return data.current_token_ownerships_v2[0];\n}\n\nexport async function getOwnedTokens(args: {\n  aptosConfig: AptosConfig;\n  ownerAddress: HexInput;\n  options?: {\n    pagination?: PaginationArgs;\n    orderBy?: OrderBy<GetTokenActivityResponse[0]>;\n  };\n}): Promise<GetOwnedTokensResponse> {\n  const { aptosConfig, ownerAddress, options } = args;\n\n  const whereCondition: CurrentTokenOwnershipsV2BoolExp = {\n    owner_address: { _eq: Hex.fromHexInput(ownerAddress).toString() },\n  };\n\n  const graphqlQuery = {\n    query: GetCurrentTokenOwnership,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.pagination?.offset,\n      limit: options?.pagination?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetCurrentTokenOwnershipQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getOwnedTokens\",\n  });\n\n  return data.current_token_ownerships_v2;\n}\n\nexport async function getTokenActivity(args: {\n  aptosConfig: AptosConfig;\n  tokenAddress: HexInput;\n  options?: {\n    pagination?: PaginationArgs;\n    orderBy?: OrderBy<GetTokenActivityResponse[0]>;\n  };\n}): Promise<GetTokenActivityResponse> {\n  const { aptosConfig, tokenAddress, options } = args;\n\n  const whereCondition: TokenActivitiesV2BoolExp = {\n    token_data_id: { _eq: Hex.fromHexInput(tokenAddress).toString() },\n  };\n\n  const graphqlQuery = {\n    query: GetTokenActivity,\n    variables: {\n      where_condition: whereCondition,\n      offset: options?.pagination?.offset,\n      limit: options?.pagination?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetTokenActivityQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getTokenActivity\",\n  });\n\n  return data.token_activities_v2;\n}\n\nexport interface CreateCollectionOptions {\n  maxSupply?: AnyNumber;\n  mutableDescription?: boolean;\n  mutableRoyalty?: boolean;\n  mutableURI?: boolean;\n  mutableTokenDescription?: boolean;\n  mutableTokenName?: boolean;\n  mutableTokenProperties?: boolean;\n  mutableTokenURI?: boolean;\n  tokensBurnableByCreator?: boolean;\n  tokensFreezableByCreator?: boolean;\n  royaltyNumerator?: number;\n  royaltyDenominator?: number;\n}\n\nexport async function createCollectionTransaction(\n  args: {\n    aptosConfig: AptosConfig;\n    creator: Account;\n    description: string;\n    name: string;\n    uri: string;\n    options?: InputGenerateTransactionOptions;\n  } & CreateCollectionOptions,\n): Promise<InputSingleSignerTransaction> {\n  const { aptosConfig, options, creator } = args;\n  const transaction = await generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress.toString(),\n    data: {\n      function: \"0x4::aptos_token::create_collection\",\n      functionArguments: [\n        // Do not change the order\n        new MoveString(args.description),\n        new U64(args.maxSupply ?? MAX_U64_BIG_INT),\n        new MoveString(args.name),\n        new MoveString(args.uri),\n        new Bool(args.mutableDescription ?? true),\n        new Bool(args.mutableRoyalty ?? true),\n        new Bool(args.mutableURI ?? true),\n        new Bool(args.mutableTokenDescription ?? true),\n        new Bool(args.mutableTokenName ?? true),\n        new Bool(args.mutableTokenProperties ?? true),\n        new Bool(args.mutableTokenURI ?? true),\n        new Bool(args.tokensBurnableByCreator ?? true),\n        new Bool(args.tokensFreezableByCreator ?? true),\n        new U64(args.royaltyNumerator ?? 0),\n        new U64(args.royaltyDenominator ?? 1),\n      ],\n    },\n    options,\n  });\n  return transaction as InputSingleSignerTransaction;\n}\n\nexport async function getCollectionData(args: {\n  aptosConfig: AptosConfig;\n  creatorAddress: HexInput;\n  collectionName: string;\n  options?: {\n    tokenStandard?: TokenStandard;\n  };\n}): Promise<GetCollectionDataResponse> {\n  const { aptosConfig, creatorAddress, collectionName, options } = args;\n  const address = Hex.fromHexInput(creatorAddress).toString();\n\n  const whereCondition: any = {\n    collection_name: { _eq: collectionName },\n    creator_address: { _eq: address },\n  };\n\n  if (options?.tokenStandard) {\n    whereCondition.token_standard = { _eq: options?.tokenStandard ?? \"v2\" };\n  }\n\n  const graphqlQuery = {\n    query: GetCollectionData,\n    variables: {\n      where_condition: whereCondition,\n    },\n  };\n  const data = await queryIndexer<GetCollectionDataQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getCollectionData\",\n  });\n\n  return data.current_collections_v2[0];\n}\n\nexport async function getCollectionId(args: {\n  aptosConfig: AptosConfig;\n  creatorAddress: HexInput;\n  collectionName: string;\n  options?: {\n    tokenStandard?: TokenStandard;\n  };\n}): Promise<string> {\n  return (await getCollectionData(args)).collection_id;\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  GetCollectionDataResponse,\n  GetCurrentTokenOwnershipResponse,\n  GetOwnedTokensResponse,\n  GetTokenActivityResponse,\n  GetTokenDataResponse,\n  HexInput,\n  OrderBy,\n  PaginationArgs,\n  TokenStandard,\n} from \"../types\";\nimport { AptosConfig } from \"./aptosConfig\";\nimport { Account } from \"../core\";\nimport { InputGenerateTransactionOptions, InputSingleSignerTransaction } from \"../transactions/types\";\nimport {\n  CreateCollectionOptions,\n  createCollectionTransaction,\n  getCollectionData,\n  getCollectionId,\n  getCurrentTokenOwnership,\n  getOwnedTokens,\n  getTokenActivity,\n  getTokenData,\n  mintTokenTransaction,\n} from \"../internal/digitalAsset\";\n\n/**\n * A class to query all `DigitalAsset` related queries on Aptos.\n */\nexport class DigitalAsset {\n  readonly config: AptosConfig;\n\n  constructor(config: AptosConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Creates a new collection within the specified account\n   *\n   * @param args.creator the account of the collection's creator\n   * @param args.description the description of the collection\n   * @param args.name the name of the collection\n   * @param args.uri the URI to additional info about the collection\n   *\n   * The parameters below are optional.\n   * @param args.maxSupply controls the max supply of the tokens - defaults MAX_U64_BIG_INT\n   * @param args.mutableDescription controls mutability of the collection's description - defaults true\n   * @param args.mutableRoyalty controls mutability of the collection's description - defaults true\n   * @param args.mutableUri controls mutability of the collection's URI - defaults true\n   * @param args.mutableTokenDescription controls mutability of the token's description - defaults true\n   * @param args.mutableTokenName controls mutability of the token's name - defaults true\n   * @param args.mutableTokenProperties controls mutability of token's properties - defaults true\n   * @param args.mutableTokenUri controls mutability of the token's URI - defaults true\n   * @param args.tokensBurnableByCreator controls whether tokens can be burnable by the creator - defaults true\n   * @param args.tokensFreezableByCreator controls whether tokens can be frozen by the creator - defaults true\n   * @param args.royaltyNumerator the numerator of the royalty to be paid to the creator when a token is transferred - defaults 0\n   * @param args.royaltyDenominator the denominator of the royalty to be paid to the creator when a token is transferred -\n   *    defaults 1\n   *\n   * @returns A SingleSignerTransaction that when submitted will create the collection.\n   */\n  async createCollectionTransaction(\n    args: {\n      creator: Account;\n      description: string;\n      name: string;\n      uri: string;\n      options?: InputGenerateTransactionOptions;\n    } & CreateCollectionOptions,\n  ): Promise<InputSingleSignerTransaction> {\n    return createCollectionTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries data of a specific collection by the collection creator address and the collection name.\n   *\n   * If, for some reason, a creator account has 2 collections with the same name in v1 and v2,\n   * can pass an optional `tokenStandard` parameter to query a specific standard\n   *\n   * @param args.creatorAddress the address of the collection's creator\n   * @param args.collectionName the name of the collection\n   * @param args.options.tokenStandard the token standard to query\n   * @returns GetCollectionDataResponse response type\n   */\n  async getCollectionData(args: {\n    creatorAddress: HexInput;\n    collectionName: string;\n    options?: {\n      tokenStandard?: TokenStandard;\n    };\n  }): Promise<GetCollectionDataResponse> {\n    return getCollectionData({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries a collection's ID.\n   *\n   * This is the same as the collection's object address in V2, but V1 does\n   * not use objects, and does not have an address\n   *\n   * @param args.creatorAddress the address of the collection's creator\n   * @param args.collectionName the name of the collection\n   * @param args.options.tokenStandard the token standard to query\n   * @returns the collection id\n   */\n  async getCollectionId(args: {\n    creatorAddress: HexInput;\n    collectionName: string;\n    options?: {\n      tokenStandard?: TokenStandard;\n    };\n  }): Promise<string> {\n    return getCollectionId({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Create a transaction to mint a token into the creators account within an existing collection.\n   *\n   * @param args.creator the creator of the collection\n   * @param args.collection the name of the collection the token belongs to\n   * @param args.description the description of the token\n   * @param args.name the name of the token\n   * @param args.uri the URI to additional info about the token\n   *\n   * @returns A SingleSignerTransaction that can be simulated or submitted to chain\n   */\n  async mintTokenTransaction(args: {\n    creator: Account;\n    collection: string;\n    description: string;\n    name: string;\n    uri: string;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<InputSingleSignerTransaction> {\n    return mintTokenTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Gets token data given the address of a token.\n   *\n   * @param args.tokenAddress The address of the token\n   * @returns GetTokenDataResponse containing relevant data to the token.\n   */\n  async getTokenData(args: { tokenAddress: HexInput }): Promise<GetTokenDataResponse> {\n    return getTokenData({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Gets token ownership data given the address of a token.\n   *\n   * @param args.tokenAddress The address of the token\n   * @returns GetCurrentTokenOwnershipResponse containing relevant ownership data of the token.\n   */\n  async getCurrentTokenOwnership(args: { tokenAddress: HexInput }): Promise<GetCurrentTokenOwnershipResponse> {\n    return getCurrentTokenOwnership({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Gets the tokens that the given address owns.\n   *\n   * @param args.ownerAddress The address of the owner\n   * @returns GetOwnedTokensResponse containing ownership data of the tokens belonging to the ownerAddresss.\n   */\n  async getOwnedTokens(args: {\n    ownerAddress: HexInput;\n    options?: {\n      pagination?: PaginationArgs;\n      orderBy?: OrderBy<GetOwnedTokensResponse[0]>;\n    };\n  }): Promise<GetOwnedTokensResponse> {\n    return getOwnedTokens({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Gets the activity data given the address of a token.\n   *\n   * @param args.tokenAddress The address of the token\n   * @returns GetTokenActivityResponse containing relevant activity data to the token.\n   */\n  async getTokenActivity(args: {\n    tokenAddress: HexInput;\n    options?: {\n      pagination?: PaginationArgs;\n      orderBy?: OrderBy<GetTokenActivityResponse[0]>;\n    };\n  }): Promise<GetTokenActivityResponse> {\n    return getTokenActivity({ aptosConfig: this.config, ...args });\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/event}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * event namespace and without having a dependency cycle error.\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { AccountAddress } from \"../core\";\nimport { AnyNumber, GetEventsResponse, HexInput, PaginationArgs, MoveStructType, OrderBy } from \"../types\";\nimport { GetEventsQuery } from \"../types/generated/operations\";\nimport { GetEvents } from \"../types/generated/queries\";\nimport { EventsBoolExp } from \"../types/generated/types\";\nimport { queryIndexer } from \"./general\";\n\nexport async function getAccountEventsByCreationNumber(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: HexInput;\n  creationNumber: AnyNumber;\n}): Promise<GetEventsResponse> {\n  const { accountAddress, aptosConfig, creationNumber } = args;\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n\n  const whereCondition: EventsBoolExp = {\n    account_address: { _eq: address },\n    creation_number: { _eq: creationNumber },\n  };\n\n  return getEvents({ aptosConfig, options: { where: whereCondition } });\n}\n\nexport async function getAccountEventsByEventType(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: HexInput;\n  eventType: MoveStructType;\n  options?: {\n    pagination?: PaginationArgs;\n    orderBy?: OrderBy<GetEventsResponse[0]>;\n  };\n}): Promise<GetEventsResponse> {\n  const { accountAddress, aptosConfig, eventType, options } = args;\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n\n  const whereCondition: EventsBoolExp = {\n    account_address: { _eq: address },\n    type: { _eq: eventType },\n  };\n\n  const customOptions = {\n    where: whereCondition,\n    pagination: options?.pagination,\n    orderBy: options?.orderBy,\n  };\n\n  return getEvents({ aptosConfig, options: customOptions });\n}\n\nexport async function getEvents(args: {\n  aptosConfig: AptosConfig;\n  options?: {\n    where?: EventsBoolExp;\n    pagination?: PaginationArgs;\n    orderBy?: OrderBy<GetEventsResponse[0]>;\n  };\n}): Promise<GetEventsResponse> {\n  const { aptosConfig, options } = args;\n\n  const graphqlQuery = {\n    query: GetEvents,\n    variables: {\n      where_condition: options?.where,\n      offset: options?.pagination?.offset,\n      limit: options?.pagination?.limit,\n      order_by: options?.orderBy,\n    },\n  };\n\n  const data = await queryIndexer<GetEventsQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getEvents\",\n  });\n\n  return data.events;\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AptosConfig } from \"./aptosConfig\";\nimport { getAccountEventsByCreationNumber, getAccountEventsByEventType, getEvents } from \"../internal/event\";\nimport { AnyNumber, GetEventsResponse, HexInput, MoveStructType, OrderBy, PaginationArgs } from \"../types\";\nimport { EventsBoolExp } from \"../types/generated/types\";\n\n/**\n * A class to query all `Event` Aptos related queries\n */\nexport class Event {\n  readonly config: AptosConfig;\n\n  constructor(config: AptosConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Get events by creation number and an account address\n   *\n   * @param args.accountAddress - The account address\n   * @param args.creationNumber - The event creation number\n   *\n   * @returns Promise<GetEventsResponse>\n   */\n  async getAccountEventsByCreationNumber(args: {\n    accountAddress: HexInput;\n    creationNumber: AnyNumber;\n  }): Promise<GetEventsResponse> {\n    return getAccountEventsByCreationNumber({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Get events by event type and an account address\n   *\n   * @param args.accountAddress - The account address\n   * @param args.eventType - The event type\n   *\n   * @returns Promise<GetEventsResponse>\n   */\n  async getAccountEventsByEventType(args: {\n    accountAddress: HexInput;\n    eventType: MoveStructType;\n    options?: {\n      pagination?: PaginationArgs;\n      orderBy?: OrderBy<GetEventsResponse[0]>;\n    };\n  }): Promise<GetEventsResponse> {\n    return getAccountEventsByEventType({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Get all events\n   *\n   * An optional `where` can be passed in to filter out the response.\n   *\n   * @example\n   * ```\n   * { where:\n   *  {\n   *   transaction_version: { _eq: 123456 },\n   *  }\n   * }\n   * ```\n   *\n   * @returns GetEventsQuery response type\n   */\n  async getEvents(args?: {\n    options?: {\n      where?: EventsBoolExp;\n      pagination?: PaginationArgs;\n      orderBy?: OrderBy<GetEventsResponse[0]>;\n    };\n  }): Promise<GetEventsResponse> {\n    return getEvents({ aptosConfig: this.config, ...args });\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/faucet}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * faucet namespace and without having a dependency cycle error.\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { postAptosFaucet } from \"../client\";\nimport { AccountAddress } from \"../core\";\nimport { HexInput, WaitForTransactionOptions } from \"../types\";\nimport { DEFAULT_TXN_TIMEOUT_SEC } from \"../utils/const\";\nimport { waitForTransaction } from \"./transaction\";\n\nexport async function fundAccount(args: {\n  aptosConfig: AptosConfig;\n  accountAddress: HexInput;\n  amount: number;\n  options?: WaitForTransactionOptions;\n}): Promise<string> {\n  const { aptosConfig, accountAddress, amount, options } = args;\n  const timeout = options?.timeoutSecs || DEFAULT_TXN_TIMEOUT_SEC;\n  const { data } = await postAptosFaucet<any, { txn_hashes: Array<string> }>({\n    aptosConfig,\n    path: \"fund\",\n    body: {\n      address: AccountAddress.fromHexInput(accountAddress).toString(),\n      amount,\n    },\n    originMethod: \"fundAccount\",\n  });\n\n  const txnHash = data.txn_hashes[0];\n\n  await waitForTransaction({\n    aptosConfig,\n    transactionHash: txnHash,\n    options: {\n      timeoutSecs: timeout,\n      checkSuccess: options?.checkSuccess,\n      indexerVersionCheck: options?.indexerVersionCheck,\n    },\n  });\n\n  return txnHash;\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AptosConfig } from \"./aptosConfig\";\nimport { fundAccount } from \"../internal/faucet\";\nimport { HexInput, WaitForTransactionOptions } from \"../types\";\n\n/**\n * A class to query all `Faucet` related queries on Aptos.\n */\nexport class Faucet {\n  readonly config: AptosConfig;\n\n  constructor(config: AptosConfig) {\n    this.config = config;\n  }\n\n  /**\n   * This creates an account if it does not exist and mints the specified amount of\n   * coins into that account\n   *\n   * @param args.accountAddress Address of the account to fund\n   * @param args.amount Amount of tokens to fund the account with\n   * @param args.options Configuration options for waitForTransaction\n   * @returns Transaction hash of the transaction that funded the account\n   */\n  async fundAccount(args: {\n    accountAddress: HexInput;\n    amount: number;\n    options?: WaitForTransactionOptions;\n  }): Promise<string> {\n    return fundAccount({ aptosConfig: this.config, ...args });\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/fungible_asset}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * fungible_asset namespace and without having a dependency cycle error.\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport {\n  GetCurrentFungibleAssetBalancesResponse,\n  GetFungibleAssetActivitiesResponse,\n  GetFungibleAssetMetadataResponse,\n  PaginationArgs,\n} from \"../types\";\nimport { queryIndexer } from \"./general\";\nimport {\n  GetCurrentFungibleAssetBalances,\n  GetFungibleAssetActivities,\n  GetFungibleAssetMetadata,\n} from \"../types/generated/queries\";\nimport {\n  GetCurrentFungibleAssetBalancesQuery,\n  GetFungibleAssetActivitiesQuery,\n  GetFungibleAssetMetadataQuery,\n} from \"../types/generated/operations\";\nimport {\n  CurrentFungibleAssetBalancesBoolExp,\n  FungibleAssetActivitiesBoolExp,\n  FungibleAssetMetadataBoolExp,\n} from \"../types/generated/types\";\n\nexport async function getFungibleAssetMetadata(args: {\n  aptosConfig: AptosConfig;\n  options?: {\n    pagination?: PaginationArgs;\n    where?: FungibleAssetMetadataBoolExp;\n  };\n}): Promise<GetFungibleAssetMetadataResponse> {\n  const { aptosConfig, options } = args;\n\n  const graphqlQuery = {\n    query: GetFungibleAssetMetadata,\n    variables: {\n      where_condition: options?.where,\n      limit: options?.pagination?.limit,\n      offset: options?.pagination?.offset,\n    },\n  };\n\n  const data = await queryIndexer<GetFungibleAssetMetadataQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getFungibleAssetMetadata\",\n  });\n\n  return data.fungible_asset_metadata;\n}\n\nexport async function getFungibleAssetActivities(args: {\n  aptosConfig: AptosConfig;\n  options?: {\n    pagination?: PaginationArgs;\n    where?: FungibleAssetActivitiesBoolExp;\n  };\n}): Promise<GetFungibleAssetActivitiesResponse> {\n  const { aptosConfig, options } = args;\n\n  const graphqlQuery = {\n    query: GetFungibleAssetActivities,\n    variables: {\n      where_condition: options?.where,\n      limit: options?.pagination?.limit,\n      offset: options?.pagination?.offset,\n    },\n  };\n\n  const data = await queryIndexer<GetFungibleAssetActivitiesQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getFungibleAssetActivities\",\n  });\n\n  return data.fungible_asset_activities;\n}\n\nexport async function getCurrentFungibleAssetBalances(args: {\n  aptosConfig: AptosConfig;\n  options?: {\n    pagination?: PaginationArgs;\n    where?: CurrentFungibleAssetBalancesBoolExp;\n  };\n}): Promise<GetCurrentFungibleAssetBalancesResponse> {\n  const { aptosConfig, options } = args;\n\n  const graphqlQuery = {\n    query: GetCurrentFungibleAssetBalances,\n    variables: {\n      where_condition: options?.where,\n      limit: options?.pagination?.limit,\n      offset: options?.pagination?.offset,\n    },\n  };\n\n  const data = await queryIndexer<GetCurrentFungibleAssetBalancesQuery>({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getCurrentFungibleAssetBalances\",\n  });\n\n  return data.current_fungible_asset_balances;\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  GetCurrentFungibleAssetBalancesResponse,\n  GetFungibleAssetActivitiesResponse,\n  GetFungibleAssetMetadataResponse,\n  PaginationArgs,\n} from \"../types\";\nimport { AptosConfig } from \"./aptosConfig\";\nimport {\n  getCurrentFungibleAssetBalances,\n  getFungibleAssetActivities,\n  getFungibleAssetMetadata,\n} from \"../internal/fungibleAsset\";\nimport {\n  CurrentFungibleAssetBalancesBoolExp,\n  FungibleAssetActivitiesBoolExp,\n  FungibleAssetMetadataBoolExp,\n} from \"../types/generated/types\";\n\n/**\n * A class to query all `FungibleAsset` related queries on Aptos.\n */\nexport class FungibleAsset {\n  readonly config: AptosConfig;\n\n  constructor(config: AptosConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Queries the current fungible asset metadata.\n   *\n   * This query returns the fungible asset metadata for all fungible assets.\n   * It can be filtered by creator address and asset type.\n   *\n   * @returns getFungibleAssetMetadata A list of fungible asset metadata\n   */\n  async getFungibleAssetMetadata(args?: {\n    options?: {\n      pagination?: PaginationArgs;\n      where?: FungibleAssetMetadataBoolExp;\n    };\n  }): Promise<GetFungibleAssetMetadataResponse> {\n    return getFungibleAssetMetadata({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries the current specific fungible asset metadata\n   *\n   * This query returns the fungible asset metadata for a specific fungible asset.\n   *\n   * @param assetType The asset type of the fungible asset.\n   * e.g\n   * \"0x1::aptos_coin::AptosCoin\" for Aptos Coin\n   * \"0xc2948283c2ce03aafbb294821de7ee684b06116bb378ab614fa2de07a99355a8\" - address format if this is fungible asset\n   *\n   * @returns getFungibleAssetMetadata A fungible asset metadata item\n   */\n  async getFungibleAssetMetadataByAssetType(assetType: string): Promise<GetFungibleAssetMetadataResponse[0]> {\n    const data = await getFungibleAssetMetadata({\n      aptosConfig: this.config,\n      options: {\n        where: {\n          asset_type: { _eq: assetType },\n        },\n      },\n    });\n\n    return data[0];\n  }\n\n  /**\n   * Queries the fungible asset activities\n   *\n   * This query returns the fungible asset activities.\n   * It can be filtered by owner address, asset type, and type.\n   *\n   * @returns GetFungibleAssetActivitiesResponse A list of fungible asset metadata\n   */\n  async getFungibleAssetActivities(args?: {\n    options?: {\n      pagination?: PaginationArgs;\n      where?: FungibleAssetActivitiesBoolExp;\n    };\n  }): Promise<GetFungibleAssetActivitiesResponse> {\n    return getFungibleAssetActivities({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries the fungible asset balance\n   *\n   * This query returns the fungible asset balance.\n   * It can be filtered by owner address, and asset type\n   *\n   * @returns GetCurrentFungibleAssetBalancesResponse A list of fungible asset metadata\n   */\n  async getCurrentFungibleAssetBalances(args?: {\n    options?: {\n      pagination?: PaginationArgs;\n      where?: CurrentFungibleAssetBalancesBoolExp;\n    };\n  }): Promise<GetCurrentFungibleAssetBalancesResponse> {\n    return getCurrentFungibleAssetBalances({ aptosConfig: this.config, ...args });\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AptosConfig } from \"./aptosConfig\";\nimport {\n  getBlockByHeight,\n  getBlockByVersion,\n  getChainTopUserTransactions,\n  getIndexerLastSuccessVersion,\n  getLedgerInfo,\n  getTableItem,\n  queryIndexer,\n  view,\n} from \"../internal/general\";\nimport {\n  AnyNumber,\n  Block,\n  GetChainTopUserTransactionsResponse,\n  GraphqlQuery,\n  LedgerInfo,\n  LedgerVersion,\n  MoveValue,\n  TableItemRequest,\n  ViewRequestData,\n} from \"../types\";\n\n/**\n * A class to query all `General` Aptos related queries\n */\nexport class General {\n  readonly config: AptosConfig;\n\n  constructor(config: AptosConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Queries for the Aptos ledger info\n   *\n   * @returns Aptos Ledger Info\n   *\n   * @example An example of the returned data\n   * ```\n   * {\n   * \"chain_id\": 4,\n   * \"epoch\": \"8\",\n   * \"ledger_version\": \"714\",\n   * \"oldest_ledger_version\": \"0\",\n   * \"ledger_timestamp\": \"1694695496521775\",\n   * \"node_role\": \"validator\",\n   * \"oldest_block_height\": \"0\",\n   * \"block_height\": \"359\",\n   * \"git_hash\": \"c82193f36f4e185fed9f68c4ad21f6c6dd390c6e\"\n   * }\n   * ```\n   */\n  async getLedgerInfo(): Promise<LedgerInfo> {\n    return getLedgerInfo({ aptosConfig: this.config });\n  }\n\n  /**\n   * Queries for the chain id\n   *\n   * @returns The chain id\n   */\n  async getChainId(): Promise<number> {\n    const result = await this.getLedgerInfo();\n    return result.chain_id;\n  }\n\n  /**\n   * Queries for block by transaction version\n   *\n   * @param args.ledgerVersion Ledger version to lookup block information for\n   * @param args.options.withTransactions If set to true, include all transactions in the block\n   *\n   * @returns Block information with optional transactions\n   */\n  async getBlockByVersion(args: {\n    ledgerVersion: AnyNumber;\n    options?: { withTransactions?: boolean };\n  }): Promise<Block> {\n    return getBlockByVersion({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Get block by block height\n   *\n   * @param args.blockHeight Block height to lookup.  Starts at 0\n   * @param args.options.withTransactions If set to true, include all transactions in the block\n   *\n   * @returns Block with optional transactions\n   */\n  async getBlockByHeight(args: { blockHeight: AnyNumber; options?: { withTransactions?: boolean } }): Promise<Block> {\n    return getBlockByHeight({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries for a table item for a table identified by the handle and the key for the item.\n   * Key and value types need to be passed in to help with key serialization and value deserialization.\n   * @param args.handle A pointer to where that table is stored\n   * @param args.data Object that describes table item\n   * @param args.options.ledgerVersion The ledger version to query, if not provided it will get the latest version\n   *\n   * @example https://fullnode.devnet.aptoslabs.com/v1/accounts/0x1/resource/0x1::coin::CoinInfo%3C0x1::aptos_coin::AptosCoin%3E\n   * {\n   *  data.key_type = \"address\" // Move type of table key\n   *  data.value_type = \"u128\" // Move type of table value\n   *  data.key = \"0x619dc29a0aac8fa146714058e8dd6d2d0f3bdf5f6331907bf91f3acd81e6935\" // Value of table key\n   * }\n   *\n   * @returns Table item value rendered in JSON\n   */\n  async getTableItem(args: { handle: string; data: TableItemRequest; options?: LedgerVersion }): Promise<any> {\n    return getTableItem({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries for a Move view function\n   * @param args.payload Payload for the view function\n   * @param args.options.ledgerVersion The ledger version to query, if not provided it will get the latest version\n   * @example\n   * `\n   * const payload: ViewRequest = {\n   *  function: \"0x1::coin::balance\",\n   *  typeArguments: [\"0x1::aptos_coin::AptosCoin\"],\n   *  functionArguments: [accountAddress],\n   * };\n   * `\n   *\n   * @returns an array of Move values\n   */\n  async view(args: { payload: ViewRequestData; options?: LedgerVersion }): Promise<Array<MoveValue>> {\n    return view({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries top user transactions\n   *\n   * @param args.limit The number of transactions to return\n   * @returns GetChainTopUserTransactionsResponse\n   */\n  async getChainTopUserTransactions(args: { limit: number }): Promise<GetChainTopUserTransactionsResponse> {\n    return getChainTopUserTransactions({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * A generic function for retrieving data from Aptos Indexer.\n   * For more detailed queries specification see\n   * {@link https://cloud.hasura.io/public/graphiql?endpoint=https://indexer.mainnet.aptoslabs.com/v1/graphql}\n   *\n   * @param args.query.query A GraphQL query\n   * @param args.query.variables The variables for the query\n   * @example\n   * ```\n   * {\n   *  query: `query MyQuery {\n        ledger_infos {\n          chain_id\n        }\n      }`;\n   * }\n   * ```\n   *\n   * @return The provided T type\n   */\n  async queryIndexer<T>(args: { query: GraphqlQuery }): Promise<T> {\n    return queryIndexer<T>({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries for the last successful indexer version\n   *\n   * This is useful to tell what ledger version the indexer is updated to, as it can be behind the full nodes.\n   */\n  async getIndexerLastSuccessVersion(): Promise<number> {\n    return getIndexerLastSuccessVersion({ aptosConfig: this.config });\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/staking}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * faucet namespace and without having a dependency cycle error.\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { Hex } from \"../core\";\nimport { GetDelegatedStakingActivitiesResponse, GetNumberOfDelegatorsResponse, HexInput, OrderBy } from \"../types\";\nimport { GetDelegatedStakingActivitiesQuery, GetNumberOfDelegatorsQuery } from \"../types/generated/operations\";\nimport { GetDelegatedStakingActivities, GetNumberOfDelegators } from \"../types/generated/queries\";\nimport { queryIndexer } from \"./general\";\n\nexport async function getNumberOfDelegators(args: {\n  aptosConfig: AptosConfig;\n  poolAddress: HexInput;\n}): Promise<number> {\n  const { aptosConfig, poolAddress } = args;\n  const address = Hex.fromHexInput(poolAddress).toString();\n  const query = {\n    query: GetNumberOfDelegators,\n    variables: { where_condition: { pool_address: { _eq: address } } },\n  };\n  const data: GetNumberOfDelegatorsQuery = await queryIndexer<GetNumberOfDelegatorsQuery>({ aptosConfig, query });\n  if (data.num_active_delegator_per_pool.length === 0) {\n    throw Error(\"Delegator pool not found\");\n  }\n  return data.num_active_delegator_per_pool[0].num_active_delegator;\n}\n\nexport async function getNumberOfDelegatorsForAllPools(args: {\n  aptosConfig: AptosConfig;\n  options?: {\n    orderBy?: OrderBy<GetNumberOfDelegatorsResponse[0]>;\n  };\n}): Promise<GetNumberOfDelegatorsResponse> {\n  const { aptosConfig, options } = args;\n  const query = {\n    query: GetNumberOfDelegators,\n    variables: { where_condition: {}, order_by: options?.orderBy },\n  };\n  const data: GetNumberOfDelegatorsQuery = await queryIndexer<GetNumberOfDelegatorsQuery>({\n    aptosConfig,\n    query,\n  });\n  return data.num_active_delegator_per_pool;\n}\n\nexport async function getDelegatedStakingActivities(args: {\n  aptosConfig: AptosConfig;\n  delegatorAddress: HexInput;\n  poolAddress: HexInput;\n}): Promise<GetDelegatedStakingActivitiesResponse> {\n  const { aptosConfig, delegatorAddress, poolAddress } = args;\n  const query = {\n    query: GetDelegatedStakingActivities,\n    variables: {\n      delegatorAddress: Hex.fromHexInput(delegatorAddress).toString(),\n      poolAddress: Hex.fromHexInput(poolAddress).toString(),\n    },\n  };\n  const data = await queryIndexer<GetDelegatedStakingActivitiesQuery>({ aptosConfig, query });\n  return data.delegated_staking_activities;\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AptosConfig } from \"./aptosConfig\";\nimport {\n  getDelegatedStakingActivities,\n  getNumberOfDelegators,\n  getNumberOfDelegatorsForAllPools,\n} from \"../internal/staking\";\nimport { GetDelegatedStakingActivitiesResponse, GetNumberOfDelegatorsResponse, HexInput, OrderBy } from \"../types\";\n\n/**\n * A class to query all `Staking` related queries on Aptos.\n */\nexport class Staking {\n  readonly config: AptosConfig;\n\n  constructor(config: AptosConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Queries current number of delegators in a pool.  Throws an error if the pool is not found.\n   *\n   * @param args.poolAddress Pool address\n   * @returns The number of delegators for the given pool\n   */\n  async getNumberOfDelegators(args: { poolAddress: HexInput }): Promise<number> {\n    return getNumberOfDelegators({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries current number of delegators in a pool.  Throws an error if the pool is not found.\n   *\n   * @returns GetNumberOfDelegatorsForAllPoolsResponse response type\n   */\n  async getNumberOfDelegatorsForAllPools(args?: {\n    options?: {\n      orderBy?: OrderBy<GetNumberOfDelegatorsResponse[0]>;\n    };\n  }): Promise<GetNumberOfDelegatorsResponse> {\n    return getNumberOfDelegatorsForAllPools({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Queries delegated staking activities\n   *\n   * @param args.delegatorAddress Delegator address\n   * @param args.poolAddress Pool address\n   * @returns GetDelegatedStakingActivitiesResponse response type\n   */\n  async getDelegatedStakingActivities(args: {\n    delegatorAddress: HexInput;\n    poolAddress: HexInput;\n  }): Promise<GetDelegatedStakingActivitiesResponse> {\n    return getDelegatedStakingActivities({ aptosConfig: this.config, ...args });\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AptosConfig } from \"./aptosConfig\";\nimport {\n  getGasPriceEstimation,\n  getTransactionByHash,\n  getTransactionByVersion,\n  getTransactions,\n  isTransactionPending,\n  waitForTransaction,\n} from \"../internal/transaction\";\nimport {\n  AnyNumber,\n  GasEstimation,\n  HexInput,\n  PaginationArgs,\n  TransactionResponse,\n  WaitForTransactionOptions,\n} from \"../types\";\n\nexport class Transaction {\n  readonly config: AptosConfig;\n\n  constructor(config: AptosConfig) {\n    this.config = config;\n  }\n\n  /**\n   * Queries on-chain transactions. This function will not return pending\n   * transactions. For that, use `getTransactionsByHash`.\n   *\n   * @param args.options.offset The number transaction to start with\n   * @param args.options.limit Number of results to return\n   *\n   * @returns Array of on-chain transactions\n   */\n  async getTransactions(args?: { options?: PaginationArgs }): Promise<TransactionResponse[]> {\n    return getTransactions({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries on-chain transaction by version. This function will not return pending transactions.\n   *\n   * @param args.ledgerVersion - Transaction version is an unsigned 64-bit number.\n   * @returns On-chain transaction. Only on-chain transactions have versions, so this\n   * function cannot be used to query pending transactions.\n   */\n  async getTransactionByVersion(args: { ledgerVersion: AnyNumber }): Promise<TransactionResponse> {\n    return getTransactionByVersion({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Queries on-chain transaction by transaction hash. This function will return pending transactions.\n   * @param args.transactionHash - Transaction hash should be hex-encoded bytes string with 0x prefix.\n   * @returns Transaction from mempool (pending) or on-chain (committed) transaction\n   */\n  async getTransactionByHash(args: { transactionHash: HexInput }): Promise<TransactionResponse> {\n    return getTransactionByHash({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Defines if specified transaction is currently in pending state\n   *\n   * To create a transaction hash:\n   *\n   * 1. Create a hash message from the bytes: \"Aptos::Transaction\" bytes + the BCS-serialized Transaction bytes.\n   * 2. Apply hash algorithm SHA3-256 to the hash message bytes.\n   * 3. Hex-encode the hash bytes with 0x prefix.\n   *\n   * @param args.transactionHash A hash of transaction\n   * @returns `true` if transaction is in pending state and `false` otherwise\n   */\n  async isPendingTransaction(args: { transactionHash: HexInput }): Promise<boolean> {\n    return isTransactionPending({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Waits for a transaction to move past the pending state.\n   *\n   * There are 4 cases.\n   * 1. Transaction is successfully processed and committed to the chain.\n   *    - The function will resolve with the transaction response from the API.\n   * 2. Transaction is rejected for some reason, and is therefore not committed to the blockchain.\n   *    - The function will throw an AptosApiError with an HTTP status code indicating some problem with the request.\n   * 3. Transaction is committed but execution failed, meaning no changes were\n   *    written to the blockchain state.\n   *    - If `checkSuccess` is true, the function will throw a FailedTransactionError\n   *      If `checkSuccess` is false, the function will resolve with the transaction response where the `success` field is false.\n   * 4. Transaction does not move past the pending state within `args.options.timeoutSecs` seconds.\n   *    - The function will throw a WaitForTransactionError\n   *\n   *\n   * @param args.transactionHash The hash of a transaction previously submitted to the blockchain.\n   * @param args.options.timeoutSecs Timeout in seconds. Defaults to 20 seconds.\n   * @param args.options.checkSuccess A boolean which controls whether the function will error if the transaction failed.\n   *   Defaults to true.  See case 3 above.\n   * @returns The transaction on-chain.  See above for more details.\n   */\n  async waitForTransaction(args: {\n    transactionHash: HexInput;\n    options?: WaitForTransactionOptions;\n  }): Promise<TransactionResponse> {\n    return waitForTransaction({\n      aptosConfig: this.config,\n      ...args,\n    });\n  }\n\n  /**\n   * Gives an estimate of the gas unit price required to get a\n   * transaction on chain in a reasonable amount of time.\n   * For more information {@link https://fullnode.mainnet.aptoslabs.com/v1/spec#/operations/estimate_gas_price}\n   *\n   * @returns Object holding the outputs of the estimate gas API\n   * @example\n   * ```\n   * {\n   *  gas_estimate: number;\n   *  deprioritized_gas_estimate?: number;\n   *  prioritized_gas_estimate?: number;\n   * }\n   * ```\n   */\n  async getGasPriceEstimation(): Promise<GasEstimation> {\n    return getGasPriceEstimation({\n      aptosConfig: this.config,\n    });\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AptosConfig } from \"./aptosConfig\";\nimport { Account } from \"../core\";\nimport { AccountAuthenticator } from \"../transactions/authenticator/account\";\nimport {\n  AnyRawTransaction,\n  InputFeePayerTransaction,\n  InputGenerateMultiAgentRawTransactionData,\n  InputGenerateTransactionData,\n  InputGenerateFeePayerRawTransactionData,\n  InputGenerateSingleSignerRawTransactionData,\n  InputMultiAgentTransaction,\n  InputSingleSignerTransaction,\n  InputSimulateTransactionData,\n  InputGenerateTransactionOptions,\n} from \"../transactions/types\";\nimport { UserTransactionResponse, PendingTransactionResponse, HexInput } from \"../types\";\nimport {\n  generateTransaction,\n  publicPackageTransaction,\n  signAndSubmitTransaction,\n  signTransaction,\n  simulateTransaction,\n  submitTransaction,\n} from \"../internal/transactionSubmission\";\n\nexport class TransactionSubmission {\n  readonly config: AptosConfig;\n\n  constructor(config: AptosConfig) {\n    this.config = config;\n  }\n\n  /**\n   * We are defining function signatures, each with its specific input and output.\n   * These are the possible function signature for `generateTransaction` function.\n   * When we call `generateTransaction` function with the relevant type properties,\n   * Typescript can infer the return type based on the appropriate function overload.\n   */\n  async generateTransaction(args: InputGenerateSingleSignerRawTransactionData): Promise<InputSingleSignerTransaction>;\n  async generateTransaction(args: InputGenerateFeePayerRawTransactionData): Promise<InputFeePayerTransaction>;\n  async generateTransaction(args: InputGenerateMultiAgentRawTransactionData): Promise<InputMultiAgentTransaction>;\n  async generateTransaction(args: InputGenerateTransactionData): Promise<AnyRawTransaction>;\n\n  /**\n   * Generates any transaction by passing in the required arguments\n   *\n   * @param args.sender The transaction sender's account address as a HexInput\n   * @param args.data EntryFunctionData | ScriptData | MultiSigData\n   * @param args.feePayerAddress optional. For a fee payer (aka sponsored) transaction\n   * @param args.secondarySignerAddresses optional. For a multi-agent or fee payer (aka sponsored) transactions\n   * @param args.options optional. GenerateTransactionOptions type\n   *\n   * @example\n   * For a single signer entry function\n   * move function name, move function type arguments, move function arguments\n   * `\n   * data: {\n   *  function: \"0x1::aptos_account::transfer\",\n   *  typeArguments: []\n   *  functionArguments: [receiverAddress,10]\n   * }\n   * `\n   *\n   * @example\n   * For a single signer script function\n   * module bytecode, move function type arguments, move function arguments\n   * ```\n   * data: {\n   *  bytecode: \"0x001234567\",\n   *  typeArguments: [],\n   *  functionArguments: [receiverAddress,10]\n   * }\n   * ```\n   *\n   * @return A raw transaction type (note that it holds the raw transaction as a bcs serialized data)\n   * ```\n   * {\n   *  rawTransaction: Uint8Array,\n   *  secondarySignerAddresses? : Array<AccountAddress>,\n   *  feePayerAddress?: AccountAddress\n   * }\n   * ```\n   */\n  async generateTransaction(args: InputGenerateTransactionData): Promise<AnyRawTransaction> {\n    return generateTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Sign a transaction that can later be submitted to chain\n   *\n   * @param args.signer The signer account to sign the transaction\n   * @param args.transaction A raw transaction type (note that it holds the raw transaction as a bcs serialized data)\n   * ```\n   * {\n   *  rawTransaction: Uint8Array,\n   *  secondarySignerAddresses? : Array<AccountAddress>,\n   *  feePayerAddress?: AccountAddress\n   * }\n   * ```\n   *\n   * @return The signer AccountAuthenticator\n   */\n  /* eslint-disable class-methods-use-this */\n  signTransaction(args: { signer: Account; transaction: AnyRawTransaction }): AccountAuthenticator {\n    return signTransaction({ ...args });\n  }\n\n  /**\n   * Simulates a transaction before singing it.\n   *\n   * @param args.signerPublicKey The signer public key\n   * @param args.transaction The raw transaction to simulate\n   * @param args.secondarySignersPublicKeys optional. For when the transaction is a multi signers transaction\n   * @param args.feePayerPublicKey optional. For when the transaction is a fee payer (aka sponsored) transaction\n   * @param args.options optional. A config to simulate the transaction with\n   */\n  async simulateTransaction(args: InputSimulateTransactionData): Promise<Array<UserTransactionResponse>> {\n    return simulateTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Submit transaction to chain\n   *\n   * @param args.transaction A aptos transaction type\n   * @param args.senderAuthenticator The account authenticator of the transaction sender\n   * @param args.secondarySignerAuthenticators optional. For when the transaction is a multi signers transaction\n   *\n   * @return PendingTransactionResponse\n   */\n  async submitTransaction(args: {\n    transaction: AnyRawTransaction;\n    senderAuthenticator: AccountAuthenticator;\n    secondarySignerAuthenticators?: {\n      feePayerAuthenticator?: AccountAuthenticator;\n      additionalSignersAuthenticators?: Array<AccountAuthenticator>;\n    };\n  }): Promise<PendingTransactionResponse> {\n    return submitTransaction({ aptosConfig: this.config, ...args });\n  }\n\n  /**\n   * Sign and submit a single signer transaction to chain\n   *\n   * @param args.signer The signer account to sign the transaction\n   * @param args.transaction A raw transaction type (note that it holds the raw transaction as a bcs serialized data)\n   * ```\n   * {\n   *  rawTransaction: Uint8Array,\n   *  secondarySignerAddresses? : Array<AccountAddress>,\n   *  feePayerAddress?: AccountAddress\n   * }\n   * ```\n   *\n   * @return PendingTransactionResponse\n   */\n  async signAndSubmitTransaction(args: {\n    signer: Account;\n    transaction: AnyRawTransaction;\n  }): Promise<PendingTransactionResponse> {\n    const { signer, transaction } = args;\n    return signAndSubmitTransaction({\n      aptosConfig: this.config,\n      signer,\n      transaction,\n    });\n  }\n\n  /**\n   * Generates a transaction to publish a move package to chain.\n   *\n   * To get the `metadataBytes` and `byteCode`, can compile using Aptos CLI with command\n   * `aptos move compile --save-metadata ...`,\n   * For more info {@link https://aptos.dev/tutorials/your-first-dapp/#step-4-publish-a-move-module}\n   *\n   * @param args.account The publisher account\n   * @param args.metadataBytes The package metadata bytes\n   * @param args.moduleBytecode An array of the bytecode of each module in the package in compiler output order\n   *\n   * @returns A SingleSignerTransaction that can be simulated or submitted to chain\n   */\n  async publishPackageTransaction(args: {\n    account: HexInput;\n    metadataBytes: HexInput;\n    moduleBytecode: Array<HexInput>;\n    options?: InputGenerateTransactionOptions;\n  }): Promise<InputSingleSignerTransaction> {\n    return publicPackageTransaction({ aptosConfig: this.config, ...args });\n  }\n}\n","// Copyright  Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Account } from \"./account\";\nimport { AptosConfig } from \"./aptosConfig\";\nimport { Coin } from \"./coin\";\nimport { DigitalAsset } from \"./digitalAsset\";\nimport { Event } from \"./event\";\nimport { Faucet } from \"./faucet\";\nimport { FungibleAsset } from \"./fungibleAsset\";\nimport { General } from \"./general\";\nimport { Staking } from \"./staking\";\nimport { Transaction } from \"./transaction\";\nimport { TransactionSubmission } from \"./transactionSubmission\";\n\n/**\n * This class is the main entry point into Aptos's\n * APIs and separates functionality into different namespaces.\n *\n * To use the SDK, create a new Aptos instance to get access\n * to all the sdk functionality.\n */\nexport class Aptos {\n  readonly config: AptosConfig;\n\n  readonly account: Account;\n\n  readonly coin: Coin;\n\n  readonly digitalAsset: DigitalAsset;\n\n  readonly event: Event;\n\n  readonly faucet: Faucet;\n\n  readonly fungibleAsset: FungibleAsset;\n\n  readonly general: General;\n\n  readonly staking: Staking;\n\n  readonly transaction: Transaction;\n\n  readonly transactionSubmission: TransactionSubmission;\n\n  constructor(settings?: AptosConfig) {\n    this.config = new AptosConfig(settings);\n    this.account = new Account(this.config);\n    this.coin = new Coin(this.config);\n    this.digitalAsset = new DigitalAsset(this.config);\n    this.event = new Event(this.config);\n    this.faucet = new Faucet(this.config);\n    this.fungibleAsset = new FungibleAsset(this.config);\n    this.general = new General(this.config);\n    this.staking = new Staking(this.config);\n    this.transaction = new Transaction(this.config);\n    this.transactionSubmission = new TransactionSubmission(this.config);\n  }\n}\n\nexport interface Aptos\n  extends Account,\n    Coin,\n    DigitalAsset,\n    Event,\n    Faucet,\n    FungibleAsset,\n    General,\n    Staking,\n    Transaction,\n    TransactionSubmission {}\n\n/**\nIn TypeScript, we cant inherit or extend from more than one class,\nMixins helps us to get around that by creating a partial classes \nthat we can combine to form a single class that contains all the methods and properties from the partial classes.\n{@link https://www.typescriptlang.org/docs/handbook/mixins.html#alternative-pattern}\n\nHere, we combine any subclass and the Aptos class.\n*/\nfunction applyMixin(targetClass: any, baseClass: any, baseClassProp: string) {\n  // Mixin instance methods\n  Object.getOwnPropertyNames(baseClass.prototype).forEach((propertyName) => {\n    const propertyDescriptor = Object.getOwnPropertyDescriptor(baseClass.prototype, propertyName);\n    if (!propertyDescriptor) return;\n    // eslint-disable-next-line func-names\n    propertyDescriptor.value = function (...args: any) {\n      return (this as any)[baseClassProp][propertyName](...args);\n    };\n    Object.defineProperty(targetClass.prototype, propertyName, propertyDescriptor);\n  });\n}\n\napplyMixin(Aptos, Account, \"account\");\napplyMixin(Aptos, Coin, \"coin\");\napplyMixin(Aptos, DigitalAsset, \"digitalAsset\");\napplyMixin(Aptos, Event, \"event\");\napplyMixin(Aptos, Faucet, \"faucet\");\napplyMixin(Aptos, FungibleAsset, \"fungibleAsset\");\napplyMixin(Aptos, General, \"general\");\napplyMixin(Aptos, Staking, \"staking\");\napplyMixin(Aptos, Transaction, \"transaction\");\napplyMixin(Aptos, TransactionSubmission, \"transactionSubmission\");\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}