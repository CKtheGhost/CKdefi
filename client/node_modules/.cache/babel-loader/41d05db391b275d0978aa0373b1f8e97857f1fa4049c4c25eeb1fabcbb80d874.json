{"ast":null,"code":"import { AptosClient, FaucetClient, TokenClient, CoinClient } from 'aptos';\nimport { Types } from 'aptos';\n\n// Supported wallet providers\nconst WALLET_PROVIDERS = {\n  PETRA: 'petra',\n  MARTIAN: 'martian',\n  PONTEM: 'pontem',\n  RISE: 'rise'\n  // Add other wallet providers as needed\n};\nclass WalletService {\n  constructor(network = 'mainnet') {\n    this.network = network;\n    this.client = this.getClientForNetwork(network);\n    this.coinClient = new CoinClient(this.client);\n    this.tokenClient = new TokenClient(this.client);\n    this.currentProvider = null;\n    this.connectedAddress = null;\n  }\n\n  // Initialize client based on selected network\n  getClientForNetwork(network) {\n    const networkUrls = {\n      mainnet: 'https://fullnode.mainnet.aptoslabs.com/v1',\n      testnet: 'https://fullnode.testnet.aptoslabs.com/v1',\n      devnet: 'https://fullnode.devnet.aptoslabs.com/v1',\n      local: 'http://localhost:8080/v1'\n    };\n    const url = networkUrls[network] || networkUrls.mainnet;\n    return new AptosClient(url);\n  }\n\n  // Get the Aptos client instance\n  getClient() {\n    return this.client;\n  }\n\n  // Check if wallet extension is installed\n  async checkWalletExtension(provider) {\n    switch (provider) {\n      case WALLET_PROVIDERS.PETRA:\n        return !!window.aptos;\n      case WALLET_PROVIDERS.MARTIAN:\n        return !!window.martian;\n      case WALLET_PROVIDERS.PONTEM:\n        return !!window.pontem;\n      case WALLET_PROVIDERS.RISE:\n        return !!window.rise;\n      default:\n        // If no specific provider, check for any compatible wallet\n        return !!(window.aptos || window.martian || window.pontem || window.rise);\n    }\n  }\n\n  // Get available wallet providers\n  async getAvailableWallets() {\n    const available = [];\n    if (await this.checkWalletExtension(WALLET_PROVIDERS.PETRA)) {\n      available.push({\n        name: 'Petra',\n        id: WALLET_PROVIDERS.PETRA,\n        icon: '/assets/images/wallets/petra.png',\n        installed: true\n      });\n    }\n    if (await this.checkWalletExtension(WALLET_PROVIDERS.MARTIAN)) {\n      available.push({\n        name: 'Martian',\n        id: WALLET_PROVIDERS.MARTIAN,\n        icon: '/assets/images/wallets/martian.png',\n        installed: true\n      });\n    }\n    if (await this.checkWalletExtension(WALLET_PROVIDERS.PONTEM)) {\n      available.push({\n        name: 'Pontem',\n        id: WALLET_PROVIDERS.PONTEM,\n        icon: '/assets/images/wallets/pontem.png',\n        installed: true\n      });\n    }\n    if (await this.checkWalletExtension(WALLET_PROVIDERS.RISE)) {\n      available.push({\n        name: 'Rise',\n        id: WALLET_PROVIDERS.RISE,\n        icon: '/assets/images/wallets/rise.png',\n        installed: true\n      });\n    }\n\n    // Add non-installed wallets for discovery\n    if (!available.some(wallet => wallet.id === WALLET_PROVIDERS.PETRA)) {\n      available.push({\n        name: 'Petra',\n        id: WALLET_PROVIDERS.PETRA,\n        icon: '/assets/images/wallets/petra.png',\n        installed: false,\n        url: 'https://petra.app/'\n      });\n    }\n\n    // Add other non-installed wallets as needed\n\n    return available;\n  }\n\n  // Connect to wallet\n  async connect(preferredProvider = null) {\n    try {\n      // Check if wallet extensions are available\n      const hasExtension = await this.checkWalletExtension(preferredProvider);\n      if (!hasExtension) {\n        throw new Error('No compatible wallet extension found. Please install a wallet extension first.');\n      }\n\n      // Get provider instance\n      let provider;\n      let providerName;\n      if (preferredProvider === WALLET_PROVIDERS.PETRA || !preferredProvider && window.aptos) {\n        provider = window.aptos;\n        providerName = 'Petra';\n      } else if (preferredProvider === WALLET_PROVIDERS.MARTIAN || !preferredProvider && window.martian) {\n        provider = window.martian;\n        providerName = 'Martian';\n      } else if (preferredProvider === WALLET_PROVIDERS.PONTEM || !preferredProvider && window.pontem) {\n        provider = window.pontem;\n        providerName = 'Pontem';\n      } else if (preferredProvider === WALLET_PROVIDERS.RISE || !preferredProvider && window.rise) {\n        provider = window.rise;\n        providerName = 'Rise';\n      } else {\n        throw new Error('No supported wallet provider found');\n      }\n\n      // Connect to the provider\n      await provider.connect();\n\n      // Get account information\n      const account = await provider.account();\n      const {\n        address,\n        publicKey\n      } = account;\n      if (!address) {\n        throw new Error('Failed to get wallet address');\n      }\n\n      // Store connected provider and address\n      this.currentProvider = provider;\n      this.connectedAddress = address;\n      this.providerName = providerName;\n\n      // Return wallet information\n      return {\n        address,\n        publicKey,\n        provider: preferredProvider || this.detectProviderType(provider),\n        providerName\n      };\n    } catch (error) {\n      console.error('Wallet connection error:', error);\n      throw new Error(`Failed to connect wallet: ${error.message}`);\n    }\n  }\n\n  // Detect wallet provider type\n  detectProviderType(provider) {\n    if (provider === window.aptos) return WALLET_PROVIDERS.PETRA;\n    if (provider === window.martian) return WALLET_PROVIDERS.MARTIAN;\n    if (provider === window.pontem) return WALLET_PROVIDERS.PONTEM;\n    if (provider === window.rise) return WALLET_PROVIDERS.RISE;\n    return 'unknown';\n  }\n\n  // Disconnect from wallet\n  async disconnect() {\n    try {\n      if (this.currentProvider && this.currentProvider.disconnect) {\n        await this.currentProvider.disconnect();\n      }\n      this.currentProvider = null;\n      this.connectedAddress = null;\n      this.providerName = null;\n      return true;\n    } catch (error) {\n      console.error('Wallet disconnection error:', error);\n      throw new Error(`Failed to disconnect wallet: ${error.message}`);\n    }\n  }\n\n  // Get wallet balance\n  async getBalance(address = this.connectedAddress) {\n    if (!address) {\n      throw new Error('Wallet address not provided');\n    }\n    try {\n      const resources = await this.client.getAccountResources(address);\n\n      // Find APT coin resource\n      const accountResource = resources.find(r => r.type === '0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>');\n      if (!accountResource) {\n        return 0;\n      }\n\n      // Convert from octas (10^8) to APT\n      const balance = parseInt(accountResource.data.coin.value) / 100000000;\n      return balance;\n    } catch (error) {\n      console.error('Balance fetch error:', error);\n      throw new Error(`Failed to fetch balance: ${error.message}`);\n    }\n  }\n\n  // Execute transaction\n  async executeTransaction(payload, options = {}) {\n    if (!this.currentProvider || !this.connectedAddress) {\n      throw new Error('Wallet not connected');\n    }\n    try {\n      // Create transaction payload\n      const txPayload = {\n        function: payload.function,\n        type_arguments: payload.type_arguments || [],\n        arguments: payload.arguments || []\n      };\n\n      // Set transaction options\n      const txOptions = {\n        max_gas_amount: options.maxGasAmount || '1000',\n        gas_unit_price: options.gasUnitPrice || '100',\n        ...options\n      };\n\n      // Sign and submit transaction\n      const pendingTransaction = await this.currentProvider.signAndSubmitTransaction(txPayload, txOptions);\n\n      // Wait for transaction confirmation\n      const txResult = await this.client.waitForTransactionWithResult(pendingTransaction.hash, {\n        timeoutSecs: options.timeoutSecs || 30\n      });\n\n      // Check transaction status\n      if (txResult.success === false) {\n        throw new Error('Transaction failed: ' + (txResult.vm_status || 'Unknown error'));\n      }\n      return {\n        success: true,\n        hash: pendingTransaction.hash,\n        result: txResult\n      };\n    } catch (error) {\n      console.error('Transaction execution error:', error);\n      throw new Error(`Transaction failed: ${error.message}`);\n    }\n  }\n\n  // Get transaction status\n  async getTransactionStatus(txHash) {\n    try {\n      const txInfo = await this.client.getTransactionByHash(txHash);\n      return {\n        status: txInfo.success ? 'success' : 'failed',\n        info: txInfo\n      };\n    } catch (error) {\n      console.error('Transaction status check error:', error);\n      throw new Error(`Failed to check transaction status: ${error.message}`);\n    }\n  }\n\n  // Get recent transactions\n  async getRecentTransactions(address = this.connectedAddress, limit = 10) {\n    if (!address) {\n      throw new Error('Wallet address not provided');\n    }\n    try {\n      const transactions = await this.client.getAccountTransactions(address, {\n        limit\n      });\n      return transactions.map(tx => {\n        return {\n          hash: tx.hash,\n          type: this.determineTransactionType(tx),\n          timestamp: tx.timestamp,\n          success: tx.success,\n          gasUsed: tx.gas_used,\n          version: tx.version\n        };\n      });\n    } catch (error) {\n      console.error('Recent transactions fetch error:', error);\n      throw new Error(`Failed to fetch recent transactions: ${error.message}`);\n    }\n  }\n\n  // Determine transaction type (staking, swap, etc.)\n  determineTransactionType(tx) {\n    try {\n      var _tx$payload$function;\n      if (!tx.payload) return 'unknown';\n      const functionName = ((_tx$payload$function = tx.payload.function) === null || _tx$payload$function === void 0 ? void 0 : _tx$payload$function.toLowerCase()) || '';\n      if (functionName.includes('::staking::')) return 'staking';\n      if (functionName.includes('::unstake') || functionName.includes('::withdraw')) return 'unstaking';\n      if (functionName.includes('::swap')) return 'swap';\n      if (functionName.includes('::transfer')) return 'transfer';\n      if (functionName.includes('::add_liquidity')) return 'add liquidity';\n      if (functionName.includes('::remove_liquidity')) return 'remove liquidity';\n      if (functionName.includes('::mint')) return 'mint';\n      if (functionName.includes('::burn')) return 'burn';\n      if (functionName.includes('::claim')) return 'claim rewards';\n      return 'transaction';\n    } catch (error) {\n      return 'transaction';\n    }\n  }\n}\nexport default WalletService;","map":{"version":3,"names":["AptosClient","FaucetClient","TokenClient","CoinClient","Types","WALLET_PROVIDERS","PETRA","MARTIAN","PONTEM","RISE","WalletService","constructor","network","client","getClientForNetwork","coinClient","tokenClient","currentProvider","connectedAddress","networkUrls","mainnet","testnet","devnet","local","url","getClient","checkWalletExtension","provider","window","aptos","martian","pontem","rise","getAvailableWallets","available","push","name","id","icon","installed","some","wallet","connect","preferredProvider","hasExtension","Error","providerName","account","address","publicKey","detectProviderType","error","console","message","disconnect","getBalance","resources","getAccountResources","accountResource","find","r","type","balance","parseInt","data","coin","value","executeTransaction","payload","options","txPayload","function","type_arguments","arguments","txOptions","max_gas_amount","maxGasAmount","gas_unit_price","gasUnitPrice","pendingTransaction","signAndSubmitTransaction","txResult","waitForTransactionWithResult","hash","timeoutSecs","success","vm_status","result","getTransactionStatus","txHash","txInfo","getTransactionByHash","status","info","getRecentTransactions","limit","transactions","getAccountTransactions","map","tx","determineTransactionType","timestamp","gasUsed","gas_used","version","_tx$payload$function","functionName","toLowerCase","includes"],"sources":["/home/ck/compoundefi/client/src/services/walletService.js"],"sourcesContent":["import { AptosClient, FaucetClient, TokenClient, CoinClient } from 'aptos';\r\nimport { Types } from 'aptos';\r\n\r\n// Supported wallet providers\r\nconst WALLET_PROVIDERS = {\r\n  PETRA: 'petra',\r\n  MARTIAN: 'martian',\r\n  PONTEM: 'pontem',\r\n  RISE: 'rise',\r\n  // Add other wallet providers as needed\r\n};\r\n\r\nclass WalletService {\r\n  constructor(network = 'mainnet') {\r\n    this.network = network;\r\n    this.client = this.getClientForNetwork(network);\r\n    this.coinClient = new CoinClient(this.client);\r\n    this.tokenClient = new TokenClient(this.client);\r\n    this.currentProvider = null;\r\n    this.connectedAddress = null;\r\n  }\r\n\r\n  // Initialize client based on selected network\r\n  getClientForNetwork(network) {\r\n    const networkUrls = {\r\n      mainnet: 'https://fullnode.mainnet.aptoslabs.com/v1',\r\n      testnet: 'https://fullnode.testnet.aptoslabs.com/v1',\r\n      devnet: 'https://fullnode.devnet.aptoslabs.com/v1',\r\n      local: 'http://localhost:8080/v1',\r\n    };\r\n\r\n    const url = networkUrls[network] || networkUrls.mainnet;\r\n    return new AptosClient(url);\r\n  }\r\n\r\n  // Get the Aptos client instance\r\n  getClient() {\r\n    return this.client;\r\n  }\r\n\r\n  // Check if wallet extension is installed\r\n  async checkWalletExtension(provider) {\r\n    switch (provider) {\r\n      case WALLET_PROVIDERS.PETRA:\r\n        return !!window.aptos;\r\n      case WALLET_PROVIDERS.MARTIAN:\r\n        return !!window.martian;\r\n      case WALLET_PROVIDERS.PONTEM:\r\n        return !!window.pontem;\r\n      case WALLET_PROVIDERS.RISE:\r\n        return !!window.rise;\r\n      default:\r\n        // If no specific provider, check for any compatible wallet\r\n        return !!(window.aptos || window.martian || window.pontem || window.rise);\r\n    }\r\n  }\r\n\r\n  // Get available wallet providers\r\n  async getAvailableWallets() {\r\n    const available = [];\r\n    \r\n    if (await this.checkWalletExtension(WALLET_PROVIDERS.PETRA)) {\r\n      available.push({\r\n        name: 'Petra',\r\n        id: WALLET_PROVIDERS.PETRA,\r\n        icon: '/assets/images/wallets/petra.png',\r\n        installed: true\r\n      });\r\n    }\r\n    \r\n    if (await this.checkWalletExtension(WALLET_PROVIDERS.MARTIAN)) {\r\n      available.push({\r\n        name: 'Martian',\r\n        id: WALLET_PROVIDERS.MARTIAN,\r\n        icon: '/assets/images/wallets/martian.png',\r\n        installed: true\r\n      });\r\n    }\r\n    \r\n    if (await this.checkWalletExtension(WALLET_PROVIDERS.PONTEM)) {\r\n      available.push({\r\n        name: 'Pontem',\r\n        id: WALLET_PROVIDERS.PONTEM,\r\n        icon: '/assets/images/wallets/pontem.png',\r\n        installed: true\r\n      });\r\n    }\r\n    \r\n    if (await this.checkWalletExtension(WALLET_PROVIDERS.RISE)) {\r\n      available.push({\r\n        name: 'Rise',\r\n        id: WALLET_PROVIDERS.RISE,\r\n        icon: '/assets/images/wallets/rise.png',\r\n        installed: true\r\n      });\r\n    }\r\n    \r\n    // Add non-installed wallets for discovery\r\n    if (!available.some(wallet => wallet.id === WALLET_PROVIDERS.PETRA)) {\r\n      available.push({\r\n        name: 'Petra',\r\n        id: WALLET_PROVIDERS.PETRA,\r\n        icon: '/assets/images/wallets/petra.png',\r\n        installed: false,\r\n        url: 'https://petra.app/'\r\n      });\r\n    }\r\n    \r\n    // Add other non-installed wallets as needed\r\n    \r\n    return available;\r\n  }\r\n\r\n  // Connect to wallet\r\n  async connect(preferredProvider = null) {\r\n    try {\r\n      // Check if wallet extensions are available\r\n      const hasExtension = await this.checkWalletExtension(preferredProvider);\r\n      if (!hasExtension) {\r\n        throw new Error('No compatible wallet extension found. Please install a wallet extension first.');\r\n      }\r\n      \r\n      // Get provider instance\r\n      let provider;\r\n      let providerName;\r\n      \r\n      if (preferredProvider === WALLET_PROVIDERS.PETRA || (!preferredProvider && window.aptos)) {\r\n        provider = window.aptos;\r\n        providerName = 'Petra';\r\n      } else if (preferredProvider === WALLET_PROVIDERS.MARTIAN || (!preferredProvider && window.martian)) {\r\n        provider = window.martian;\r\n        providerName = 'Martian';\r\n      } else if (preferredProvider === WALLET_PROVIDERS.PONTEM || (!preferredProvider && window.pontem)) {\r\n        provider = window.pontem;\r\n        providerName = 'Pontem';\r\n      } else if (preferredProvider === WALLET_PROVIDERS.RISE || (!preferredProvider && window.rise)) {\r\n        provider = window.rise;\r\n        providerName = 'Rise';\r\n      } else {\r\n        throw new Error('No supported wallet provider found');\r\n      }\r\n      \r\n      // Connect to the provider\r\n      await provider.connect();\r\n      \r\n      // Get account information\r\n      const account = await provider.account();\r\n      const { address, publicKey } = account;\r\n      \r\n      if (!address) {\r\n        throw new Error('Failed to get wallet address');\r\n      }\r\n      \r\n      // Store connected provider and address\r\n      this.currentProvider = provider;\r\n      this.connectedAddress = address;\r\n      this.providerName = providerName;\r\n      \r\n      // Return wallet information\r\n      return {\r\n        address,\r\n        publicKey,\r\n        provider: preferredProvider || this.detectProviderType(provider),\r\n        providerName\r\n      };\r\n    } catch (error) {\r\n      console.error('Wallet connection error:', error);\r\n      throw new Error(`Failed to connect wallet: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  // Detect wallet provider type\r\n  detectProviderType(provider) {\r\n    if (provider === window.aptos) return WALLET_PROVIDERS.PETRA;\r\n    if (provider === window.martian) return WALLET_PROVIDERS.MARTIAN;\r\n    if (provider === window.pontem) return WALLET_PROVIDERS.PONTEM;\r\n    if (provider === window.rise) return WALLET_PROVIDERS.RISE;\r\n    return 'unknown';\r\n  }\r\n\r\n  // Disconnect from wallet\r\n  async disconnect() {\r\n    try {\r\n      if (this.currentProvider && this.currentProvider.disconnect) {\r\n        await this.currentProvider.disconnect();\r\n      }\r\n      \r\n      this.currentProvider = null;\r\n      this.connectedAddress = null;\r\n      this.providerName = null;\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Wallet disconnection error:', error);\r\n      throw new Error(`Failed to disconnect wallet: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  // Get wallet balance\r\n  async getBalance(address = this.connectedAddress) {\r\n    if (!address) {\r\n      throw new Error('Wallet address not provided');\r\n    }\r\n    \r\n    try {\r\n      const resources = await this.client.getAccountResources(address);\r\n      \r\n      // Find APT coin resource\r\n      const accountResource = resources.find(r => r.type === '0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>');\r\n      \r\n      if (!accountResource) {\r\n        return 0;\r\n      }\r\n      \r\n      // Convert from octas (10^8) to APT\r\n      const balance = parseInt(accountResource.data.coin.value) / 100000000;\r\n      \r\n      return balance;\r\n    } catch (error) {\r\n      console.error('Balance fetch error:', error);\r\n      throw new Error(`Failed to fetch balance: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  // Execute transaction\r\n  async executeTransaction(payload, options = {}) {\r\n    if (!this.currentProvider || !this.connectedAddress) {\r\n      throw new Error('Wallet not connected');\r\n    }\r\n    \r\n    try {\r\n      // Create transaction payload\r\n      const txPayload = {\r\n        function: payload.function,\r\n        type_arguments: payload.type_arguments || [],\r\n        arguments: payload.arguments || []\r\n      };\r\n      \r\n      // Set transaction options\r\n      const txOptions = {\r\n        max_gas_amount: options.maxGasAmount || '1000',\r\n        gas_unit_price: options.gasUnitPrice || '100',\r\n        ...options\r\n      };\r\n      \r\n      // Sign and submit transaction\r\n      const pendingTransaction = await this.currentProvider.signAndSubmitTransaction(txPayload, txOptions);\r\n      \r\n      // Wait for transaction confirmation\r\n      const txResult = await this.client.waitForTransactionWithResult(\r\n        pendingTransaction.hash,\r\n        { timeoutSecs: options.timeoutSecs || 30 }\r\n      );\r\n      \r\n      // Check transaction status\r\n      if (txResult.success === false) {\r\n        throw new Error('Transaction failed: ' + (txResult.vm_status || 'Unknown error'));\r\n      }\r\n      \r\n      return {\r\n        success: true,\r\n        hash: pendingTransaction.hash,\r\n        result: txResult\r\n      };\r\n    } catch (error) {\r\n      console.error('Transaction execution error:', error);\r\n      throw new Error(`Transaction failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  // Get transaction status\r\n  async getTransactionStatus(txHash) {\r\n    try {\r\n      const txInfo = await this.client.getTransactionByHash(txHash);\r\n      return {\r\n        status: txInfo.success ? 'success' : 'failed',\r\n        info: txInfo\r\n      };\r\n    } catch (error) {\r\n      console.error('Transaction status check error:', error);\r\n      throw new Error(`Failed to check transaction status: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  // Get recent transactions\r\n  async getRecentTransactions(address = this.connectedAddress, limit = 10) {\r\n    if (!address) {\r\n      throw new Error('Wallet address not provided');\r\n    }\r\n    \r\n    try {\r\n      const transactions = await this.client.getAccountTransactions(address, { limit });\r\n      \r\n      return transactions.map(tx => {\r\n        return {\r\n          hash: tx.hash,\r\n          type: this.determineTransactionType(tx),\r\n          timestamp: tx.timestamp,\r\n          success: tx.success,\r\n          gasUsed: tx.gas_used,\r\n          version: tx.version\r\n        };\r\n      });\r\n    } catch (error) {\r\n      console.error('Recent transactions fetch error:', error);\r\n      throw new Error(`Failed to fetch recent transactions: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  // Determine transaction type (staking, swap, etc.)\r\n  determineTransactionType(tx) {\r\n    try {\r\n      if (!tx.payload) return 'unknown';\r\n      \r\n      const functionName = tx.payload.function?.toLowerCase() || '';\r\n      \r\n      if (functionName.includes('::staking::')) return 'staking';\r\n      if (functionName.includes('::unstake') || functionName.includes('::withdraw')) return 'unstaking';\r\n      if (functionName.includes('::swap')) return 'swap';\r\n      if (functionName.includes('::transfer')) return 'transfer';\r\n      if (functionName.includes('::add_liquidity')) return 'add liquidity';\r\n      if (functionName.includes('::remove_liquidity')) return 'remove liquidity';\r\n      if (functionName.includes('::mint')) return 'mint';\r\n      if (functionName.includes('::burn')) return 'burn';\r\n      if (functionName.includes('::claim')) return 'claim rewards';\r\n      \r\n      return 'transaction';\r\n    } catch (error) {\r\n      return 'transaction';\r\n    }\r\n  }\r\n}\r\n\r\nexport default WalletService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}