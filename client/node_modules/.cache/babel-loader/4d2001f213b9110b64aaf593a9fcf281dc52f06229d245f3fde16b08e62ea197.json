{"ast":null,"code":"var _jsxFileName = \"/home/ck/compoundefi/client/src/context/TransactionContext.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n// src/context/TransactionContext.jsx\n\nimport React, { createContext, useState, useEffect, useCallback, useContext } from 'react';\nimport { useWalletContext } from './WalletContext';\nimport { executeStrategy, executeTransaction } from '../services/transactionService';\nimport { showNotification } from '../utils/animations';\n\n// Create the context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const TransactionContext = /*#__PURE__*/createContext({});\n\n/**\r\n * Provider component for transaction-related functionality\r\n */\nexport function TransactionProvider({\n  children\n}) {\n  _s();\n  // State variables\n  const [pendingTransactions, setPendingTransactions] = useState([]);\n  const [transactionHistory, setTransactionHistory] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [currentTransaction, setCurrentTransaction] = useState(null);\n  const [error, setError] = useState(null);\n  const {\n    wallet,\n    isConnected,\n    refreshPortfolio\n  } = useWalletContext();\n\n  // Load transaction history from localStorage on mount\n  useEffect(() => {\n    const loadHistory = () => {\n      try {\n        const savedHistory = localStorage.getItem('transactionHistory');\n        if (savedHistory) {\n          setTransactionHistory(JSON.parse(savedHistory));\n        }\n      } catch (err) {\n        console.error('Error loading transaction history:', err);\n      }\n    };\n    loadHistory();\n  }, []);\n\n  // Save transaction history to localStorage when it changes\n  useEffect(() => {\n    if (transactionHistory.length > 0) {\n      try {\n        localStorage.setItem('transactionHistory', JSON.stringify(transactionHistory));\n      } catch (err) {\n        console.error('Error saving transaction history:', err);\n      }\n    }\n  }, [transactionHistory]);\n\n  // Add a transaction to history\n  const addTransaction = useCallback(transaction => {\n    setTransactionHistory(prev => {\n      // Add to the beginning of the array\n      const updated = [transaction, ...prev];\n\n      // Limit history to 50 items\n      if (updated.length > 50) {\n        updated.length = 50;\n      }\n      return updated;\n    });\n  }, []);\n\n  // Execute a transaction\n  const executeTransactionWithState = useCallback(async (payload, options = {}) => {\n    if (!isConnected || !wallet) {\n      throw new Error('Wallet not connected');\n    }\n    setIsLoading(true);\n    setError(null);\n    try {\n      // Add to pending transactions\n      const pendingTx = {\n        id: Date.now().toString(),\n        type: payload.type || 'transaction',\n        status: 'pending',\n        timestamp: new Date().toISOString(),\n        payload\n      };\n      setPendingTransactions(prev => [pendingTx, ...prev]);\n      setCurrentTransaction(pendingTx);\n\n      // Execute the transaction\n      const result = await executeTransaction(wallet, payload, options);\n\n      // Update the transaction status\n      const completedTx = {\n        ...pendingTx,\n        status: result.success ? 'success' : 'failed',\n        result,\n        error: result.error\n      };\n      setPendingTransactions(prev => prev.filter(tx => tx.id !== pendingTx.id));\n\n      // Add to history\n      addTransaction(completedTx);\n\n      // Clear current transaction\n      setCurrentTransaction(null);\n\n      // Show notification\n      if (result.success) {\n        showNotification('Transaction successful!', 'success');\n      } else {\n        showNotification(`Transaction failed: ${result.error}`, 'error');\n      }\n\n      // Refresh portfolio after successful transaction\n      if (result.success) {\n        setTimeout(() => refreshPortfolio(), 2000);\n      }\n      return result;\n    } catch (err) {\n      console.error('Transaction execution error:', err);\n      setError(err.message || 'Transaction failed');\n\n      // Add failed transaction to history\n      const failedTx = {\n        id: Date.now().toString(),\n        type: payload.type || 'transaction',\n        status: 'failed',\n        timestamp: new Date().toISOString(),\n        payload,\n        error: err.message\n      };\n      addTransaction(failedTx);\n\n      // Clear from pending\n      setPendingTransactions(prev => prev.filter(tx => tx.id !== ((currentTransaction === null || currentTransaction === void 0 ? void 0 : currentTransaction.id) || '')));\n\n      // Clear current transaction\n      setCurrentTransaction(null);\n\n      // Show notification\n      showNotification(err.message || 'Transaction failed', 'error');\n      throw err;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [isConnected, wallet, addTransaction, refreshPortfolio]);\n\n  // Execute a strategy (multiple transactions)\n  const executeStrategyWithState = useCallback(async (operations, options = {}, onProgress = null) => {\n    if (!isConnected || !wallet) {\n      throw new Error('Wallet not connected');\n    }\n    setIsLoading(true);\n    setError(null);\n    try {\n      // Create strategy transaction record\n      const strategyTx = {\n        id: Date.now().toString(),\n        type: 'strategy',\n        status: 'pending',\n        timestamp: new Date().toISOString(),\n        operations,\n        progress: 0\n      };\n      setPendingTransactions(prev => [strategyTx, ...prev]);\n      setCurrentTransaction(strategyTx);\n\n      // Progress callback\n      const handleProgress = (index, result) => {\n        // Update progress\n        const progress = Math.round((index + 1) / operations.length * 100);\n\n        // Update pending transaction\n        setPendingTransactions(prev => {\n          return prev.map(tx => {\n            if (tx.id === strategyTx.id) {\n              return {\n                ...tx,\n                progress\n              };\n            }\n            return tx;\n          });\n        });\n\n        // Update current transaction\n        setCurrentTransaction(prev => {\n          if (prev && prev.id === strategyTx.id) {\n            return {\n              ...prev,\n              progress\n            };\n          }\n          return prev;\n        });\n\n        // Call external progress handler if provided\n        if (onProgress) {\n          onProgress(index, result, progress);\n        }\n      };\n\n      // Execute the strategy\n      const result = await executeStrategy(wallet, operations, options, handleProgress);\n\n      // Update the transaction status\n      const completedStrategy = {\n        ...strategyTx,\n        status: result.success ? 'success' : result.operations.length > 0 ? 'partial' : 'failed',\n        result,\n        error: result.error,\n        operations: result.operations,\n        failedOperations: result.failedOperations,\n        progress: 100\n      };\n\n      // Remove from pending\n      setPendingTransactions(prev => prev.filter(tx => tx.id !== strategyTx.id));\n\n      // Add to history\n      addTransaction(completedStrategy);\n\n      // Clear current transaction\n      setCurrentTransaction(null);\n\n      // Show notification\n      if (result.success) {\n        showNotification(`Strategy executed successfully with ${result.operations.length} operations!`, 'success');\n      } else if (result.operations.length > 0) {\n        showNotification(`Strategy partially executed with ${result.failedOperations.length} failures`, 'warning');\n      } else {\n        showNotification(`Strategy execution failed: ${result.error}`, 'error');\n      }\n\n      // Refresh portfolio after execution\n      setTimeout(() => refreshPortfolio(), 2000);\n      return result;\n    } catch (err) {\n      console.error('Strategy execution error:', err);\n      setError(err.message || 'Strategy execution failed');\n\n      // Add failed strategy to history\n      const failedStrategy = {\n        id: Date.now().toString(),\n        type: 'strategy',\n        status: 'failed',\n        timestamp: new Date().toISOString(),\n        operations,\n        error: err.message\n      };\n      addTransaction(failedStrategy);\n\n      // Remove from pending\n      setPendingTransactions(prev => prev.filter(tx => tx.id !== ((currentTransaction === null || currentTransaction === void 0 ? void 0 : currentTransaction.id) || '')));\n\n      // Clear current transaction\n      setCurrentTransaction(null);\n\n      // Show notification\n      showNotification(err.message || 'Strategy execution failed', 'error');\n      throw err;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [isConnected, wallet, addTransaction, refreshPortfolio]);\n\n  // Clear transaction history\n  const clearHistory = useCallback(() => {\n    setTransactionHistory([]);\n    localStorage.removeItem('transactionHistory');\n  }, []);\n\n  // Context value\n  const contextValue = {\n    pendingTransactions,\n    transactionHistory,\n    isLoading,\n    currentTransaction,\n    error,\n    executeTransaction: executeTransactionWithState,\n    executeStrategyTransaction: executeStrategyWithState,\n    addTransaction,\n    clearHistory\n  };\n  return /*#__PURE__*/_jsxDEV(TransactionContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 307,\n    columnNumber: 5\n  }, this);\n}\n\n// Custom hook to use the TransactionContext\n_s(TransactionProvider, \"1rDdux3q5hsQ/nWiZG7oDFhntvc=\", false, function () {\n  return [useWalletContext];\n});\n_c = TransactionProvider;\nexport const useTransactionContext = () => {\n  _s2();\n  return useContext(TransactionContext);\n};\n_s2(useTransactionContext, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nexport default TransactionContext;\nvar _c;\n$RefreshReg$(_c, \"TransactionProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useCallback","useContext","useWalletContext","executeStrategy","executeTransaction","showNotification","jsxDEV","_jsxDEV","TransactionContext","TransactionProvider","children","_s","pendingTransactions","setPendingTransactions","transactionHistory","setTransactionHistory","isLoading","setIsLoading","currentTransaction","setCurrentTransaction","error","setError","wallet","isConnected","refreshPortfolio","loadHistory","savedHistory","localStorage","getItem","JSON","parse","err","console","length","setItem","stringify","addTransaction","transaction","prev","updated","executeTransactionWithState","payload","options","Error","pendingTx","id","Date","now","toString","type","status","timestamp","toISOString","result","completedTx","success","filter","tx","setTimeout","message","failedTx","executeStrategyWithState","operations","onProgress","strategyTx","progress","handleProgress","index","Math","round","map","completedStrategy","failedOperations","failedStrategy","clearHistory","removeItem","contextValue","executeStrategyTransaction","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useTransactionContext","_s2","$RefreshReg$"],"sources":["/home/ck/compoundefi/client/src/context/TransactionContext.jsx"],"sourcesContent":["// src/context/TransactionContext.jsx\r\n\r\nimport React, { createContext, useState, useEffect, useCallback, useContext } from 'react';\r\nimport { useWalletContext } from './WalletContext';\r\nimport { executeStrategy, executeTransaction } from '../services/transactionService';\r\nimport { showNotification } from '../utils/animations';\r\n\r\n// Create the context\r\nexport const TransactionContext = createContext({});\r\n\r\n/**\r\n * Provider component for transaction-related functionality\r\n */\r\nexport function TransactionProvider({ children }) {\r\n  // State variables\r\n  const [pendingTransactions, setPendingTransactions] = useState([]);\r\n  const [transactionHistory, setTransactionHistory] = useState([]);\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [currentTransaction, setCurrentTransaction] = useState(null);\r\n  const [error, setError] = useState(null);\r\n\r\n  const { wallet, isConnected, refreshPortfolio } = useWalletContext();\r\n\r\n  // Load transaction history from localStorage on mount\r\n  useEffect(() => {\r\n    const loadHistory = () => {\r\n      try {\r\n        const savedHistory = localStorage.getItem('transactionHistory');\r\n        if (savedHistory) {\r\n          setTransactionHistory(JSON.parse(savedHistory));\r\n        }\r\n      } catch (err) {\r\n        console.error('Error loading transaction history:', err);\r\n      }\r\n    };\r\n\r\n    loadHistory();\r\n  }, []);\r\n\r\n  // Save transaction history to localStorage when it changes\r\n  useEffect(() => {\r\n    if (transactionHistory.length > 0) {\r\n      try {\r\n        localStorage.setItem('transactionHistory', JSON.stringify(transactionHistory));\r\n      } catch (err) {\r\n        console.error('Error saving transaction history:', err);\r\n      }\r\n    }\r\n  }, [transactionHistory]);\r\n\r\n  // Add a transaction to history\r\n  const addTransaction = useCallback((transaction) => {\r\n    setTransactionHistory(prev => {\r\n      // Add to the beginning of the array\r\n      const updated = [transaction, ...prev];\r\n      \r\n      // Limit history to 50 items\r\n      if (updated.length > 50) {\r\n        updated.length = 50;\r\n      }\r\n      \r\n      return updated;\r\n    });\r\n  }, []);\r\n\r\n  // Execute a transaction\r\n  const executeTransactionWithState = useCallback(async (payload, options = {}) => {\r\n    if (!isConnected || !wallet) {\r\n      throw new Error('Wallet not connected');\r\n    }\r\n\r\n    setIsLoading(true);\r\n    setError(null);\r\n    \r\n    try {\r\n      // Add to pending transactions\r\n      const pendingTx = {\r\n        id: Date.now().toString(),\r\n        type: payload.type || 'transaction',\r\n        status: 'pending',\r\n        timestamp: new Date().toISOString(),\r\n        payload\r\n      };\r\n      \r\n      setPendingTransactions(prev => [pendingTx, ...prev]);\r\n      setCurrentTransaction(pendingTx);\r\n      \r\n      // Execute the transaction\r\n      const result = await executeTransaction(\r\n        wallet,\r\n        payload,\r\n        options\r\n      );\r\n      \r\n      // Update the transaction status\r\n      const completedTx = {\r\n        ...pendingTx,\r\n        status: result.success ? 'success' : 'failed',\r\n        result,\r\n        error: result.error\r\n      };\r\n      \r\n      setPendingTransactions(prev => \r\n        prev.filter(tx => tx.id !== pendingTx.id)\r\n      );\r\n      \r\n      // Add to history\r\n      addTransaction(completedTx);\r\n      \r\n      // Clear current transaction\r\n      setCurrentTransaction(null);\r\n      \r\n      // Show notification\r\n      if (result.success) {\r\n        showNotification('Transaction successful!', 'success');\r\n      } else {\r\n        showNotification(`Transaction failed: ${result.error}`, 'error');\r\n      }\r\n      \r\n      // Refresh portfolio after successful transaction\r\n      if (result.success) {\r\n        setTimeout(() => refreshPortfolio(), 2000);\r\n      }\r\n      \r\n      return result;\r\n    } catch (err) {\r\n      console.error('Transaction execution error:', err);\r\n      setError(err.message || 'Transaction failed');\r\n      \r\n      // Add failed transaction to history\r\n      const failedTx = {\r\n        id: Date.now().toString(),\r\n        type: payload.type || 'transaction',\r\n        status: 'failed',\r\n        timestamp: new Date().toISOString(),\r\n        payload,\r\n        error: err.message\r\n      };\r\n      \r\n      addTransaction(failedTx);\r\n      \r\n      // Clear from pending\r\n      setPendingTransactions(prev => \r\n        prev.filter(tx => tx.id !== (currentTransaction?.id || ''))\r\n      );\r\n      \r\n      // Clear current transaction\r\n      setCurrentTransaction(null);\r\n      \r\n      // Show notification\r\n      showNotification(err.message || 'Transaction failed', 'error');\r\n      \r\n      throw err;\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [isConnected, wallet, addTransaction, refreshPortfolio]);\r\n\r\n  // Execute a strategy (multiple transactions)\r\n  const executeStrategyWithState = useCallback(async (operations, options = {}, onProgress = null) => {\r\n    if (!isConnected || !wallet) {\r\n      throw new Error('Wallet not connected');\r\n    }\r\n\r\n    setIsLoading(true);\r\n    setError(null);\r\n    \r\n    try {\r\n      // Create strategy transaction record\r\n      const strategyTx = {\r\n        id: Date.now().toString(),\r\n        type: 'strategy',\r\n        status: 'pending',\r\n        timestamp: new Date().toISOString(),\r\n        operations,\r\n        progress: 0\r\n      };\r\n      \r\n      setPendingTransactions(prev => [strategyTx, ...prev]);\r\n      setCurrentTransaction(strategyTx);\r\n      \r\n      // Progress callback\r\n      const handleProgress = (index, result) => {\r\n        // Update progress\r\n        const progress = Math.round(((index + 1) / operations.length) * 100);\r\n        \r\n        // Update pending transaction\r\n        setPendingTransactions(prev => {\r\n          return prev.map(tx => {\r\n            if (tx.id === strategyTx.id) {\r\n              return { ...tx, progress };\r\n            }\r\n            return tx;\r\n          });\r\n        });\r\n        \r\n        // Update current transaction\r\n        setCurrentTransaction(prev => {\r\n          if (prev && prev.id === strategyTx.id) {\r\n            return { ...prev, progress };\r\n          }\r\n          return prev;\r\n        });\r\n        \r\n        // Call external progress handler if provided\r\n        if (onProgress) {\r\n          onProgress(index, result, progress);\r\n        }\r\n      };\r\n      \r\n      // Execute the strategy\r\n      const result = await executeStrategy(\r\n        wallet,\r\n        operations,\r\n        options,\r\n        handleProgress\r\n      );\r\n      \r\n      // Update the transaction status\r\n      const completedStrategy = {\r\n        ...strategyTx,\r\n        status: result.success ? 'success' : result.operations.length > 0 ? 'partial' : 'failed',\r\n        result,\r\n        error: result.error,\r\n        operations: result.operations,\r\n        failedOperations: result.failedOperations,\r\n        progress: 100\r\n      };\r\n      \r\n      // Remove from pending\r\n      setPendingTransactions(prev => \r\n        prev.filter(tx => tx.id !== strategyTx.id)\r\n      );\r\n      \r\n      // Add to history\r\n      addTransaction(completedStrategy);\r\n      \r\n      // Clear current transaction\r\n      setCurrentTransaction(null);\r\n      \r\n      // Show notification\r\n      if (result.success) {\r\n        showNotification(`Strategy executed successfully with ${result.operations.length} operations!`, 'success');\r\n      } else if (result.operations.length > 0) {\r\n        showNotification(`Strategy partially executed with ${result.failedOperations.length} failures`, 'warning');\r\n      } else {\r\n        showNotification(`Strategy execution failed: ${result.error}`, 'error');\r\n      }\r\n      \r\n      // Refresh portfolio after execution\r\n      setTimeout(() => refreshPortfolio(), 2000);\r\n      \r\n      return result;\r\n    } catch (err) {\r\n      console.error('Strategy execution error:', err);\r\n      setError(err.message || 'Strategy execution failed');\r\n      \r\n      // Add failed strategy to history\r\n      const failedStrategy = {\r\n        id: Date.now().toString(),\r\n        type: 'strategy',\r\n        status: 'failed',\r\n        timestamp: new Date().toISOString(),\r\n        operations,\r\n        error: err.message\r\n      };\r\n      \r\n      addTransaction(failedStrategy);\r\n      \r\n      // Remove from pending\r\n      setPendingTransactions(prev => \r\n        prev.filter(tx => tx.id !== (currentTransaction?.id || ''))\r\n      );\r\n      \r\n      // Clear current transaction\r\n      setCurrentTransaction(null);\r\n      \r\n      // Show notification\r\n      showNotification(err.message || 'Strategy execution failed', 'error');\r\n      \r\n      throw err;\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [isConnected, wallet, addTransaction, refreshPortfolio]);\r\n\r\n  // Clear transaction history\r\n  const clearHistory = useCallback(() => {\r\n    setTransactionHistory([]);\r\n    localStorage.removeItem('transactionHistory');\r\n  }, []);\r\n\r\n  // Context value\r\n  const contextValue = {\r\n    pendingTransactions,\r\n    transactionHistory,\r\n    isLoading,\r\n    currentTransaction,\r\n    error,\r\n    executeTransaction: executeTransactionWithState,\r\n    executeStrategyTransaction: executeStrategyWithState,\r\n    addTransaction,\r\n    clearHistory\r\n  };\r\n\r\n  return (\r\n    <TransactionContext.Provider value={contextValue}>\r\n      {children}\r\n    </TransactionContext.Provider>\r\n  );\r\n}\r\n\r\n// Custom hook to use the TransactionContext\r\nexport const useTransactionContext = () => useContext(TransactionContext);\r\n\r\nexport default TransactionContext;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}