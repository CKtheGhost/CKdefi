{"ast":null,"code":"var _jsxFileName = \"/home/ck/compoundefi/client/src/context/TransactionContext.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n// src/context/TransactionContext.jsx\nimport React, { createContext, useState, useCallback, useEffect, useContext } from 'react';\nimport { WalletContext } from './WalletContext';\nimport { NotificationContext } from './NotificationContext';\n\n// Create context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const TransactionContext = /*#__PURE__*/createContext();\nexport const TransactionProvider = ({\n  children\n}) => {\n  _s();\n  const {\n    wallet,\n    address,\n    isConnected\n  } = useContext(WalletContext);\n  const {\n    showNotification\n  } = useContext(NotificationContext);\n  const [pendingTransactions, setPendingTransactions] = useState([]);\n  const [recentTransactions, setRecentTransactions] = useState([]);\n  const [isExecuting, setIsExecuting] = useState(false);\n  const [status, setStatus] = useState('idle'); // idle, pending, success, error\n  const [error, setError] = useState(null);\n  const [result, setResult] = useState(null);\n\n  // Load transaction history from localStorage on mount\n  useEffect(() => {\n    try {\n      const savedTransactions = localStorage.getItem('recentTransactions');\n      if (savedTransactions) {\n        setRecentTransactions(JSON.parse(savedTransactions));\n      }\n    } catch (error) {\n      console.error('Failed to load transaction history:', error);\n    }\n  }, []);\n\n  // Save transaction history to localStorage when it changes\n  useEffect(() => {\n    if (recentTransactions.length > 0) {\n      localStorage.setItem('recentTransactions', JSON.stringify(recentTransactions));\n    }\n  }, [recentTransactions]);\n\n  // Execute a single transaction\n  const executeTransaction = useCallback(async payload => {\n    if (!isConnected || !wallet) {\n      setError('Wallet not connected');\n      showNotification('Please connect your wallet to execute transactions', 'error');\n      throw new Error('Wallet not connected');\n    }\n    try {\n      var _payload$function;\n      setIsExecuting(true);\n      setStatus('pending');\n      setError(null);\n\n      // Add to pending transactions\n      const txId = Date.now().toString();\n      const pendingTx = {\n        id: txId,\n        payload,\n        status: 'pending',\n        timestamp: Date.now()\n      };\n      setPendingTransactions(prev => [...prev, pendingTx]);\n\n      // Show notification\n      showNotification('Confirm the transaction in your wallet', 'info');\n\n      // Send transaction to wallet for signing\n      const response = await wallet.signAndSubmitTransaction(payload);\n\n      // Update status based on response\n      const txHash = response.hash || `tx_${txId}`;\n\n      // Simulate transaction confirmation\n      // In production, you'd use an Aptos client to wait for the transaction\n      const txResult = {\n        success: true,\n        hash: txHash,\n        gas_used: Math.floor(Math.random() * 1000),\n        vm_status: \"Executed successfully\"\n      };\n\n      // Update transaction history\n      const txRecord = {\n        id: txId,\n        hash: txResult.hash,\n        success: txResult.success,\n        timestamp: Date.now(),\n        type: ((_payload$function = payload.function) === null || _payload$function === void 0 ? void 0 : _payload$function.split('::').pop()) || 'transaction',\n        gasFee: txResult.gas_used || 0,\n        payload\n      };\n      setRecentTransactions(prev => [txRecord, ...prev]);\n\n      // Remove from pending\n      setPendingTransactions(prev => prev.filter(tx => tx.id !== txId));\n\n      // Update status and result\n      setStatus('success');\n      setResult(txResult);\n\n      // Show notification\n      showNotification('Transaction completed successfully', 'success');\n      return txResult;\n    } catch (error) {\n      var _error$message, _error$message2;\n      console.error('Transaction failed:', error);\n      setStatus('error');\n      setError(error.message || 'Transaction failed');\n\n      // Check if user rejected transaction\n      if ((_error$message = error.message) !== null && _error$message !== void 0 && _error$message.includes('reject') || (_error$message2 = error.message) !== null && _error$message2 !== void 0 && _error$message2.includes('user denied')) {\n        showNotification('Transaction was rejected', 'warning');\n      } else {\n        showNotification(`Transaction failed: ${error.message}`, 'error');\n      }\n      throw error;\n    } finally {\n      setIsExecuting(false);\n    }\n  }, [wallet, address, isConnected, showNotification]);\n\n  // Execute AI-recommended strategy\n  const executeAIStrategy = useCallback(async operations => {\n    if (!operations || operations.length === 0) {\n      throw new Error('No operations provided for strategy execution');\n    }\n    try {\n      setIsExecuting(true);\n      setStatus('pending');\n      setError(null);\n      const results = {\n        success: true,\n        operations: [],\n        failedOperations: [],\n        timestamp: Date.now()\n      };\n\n      // Show strategy execution notification\n      showNotification('Executing investment strategy...', 'info');\n\n      // Execute each operation sequentially\n      for (let i = 0; i < operations.length; i++) {\n        const operation = operations[i];\n        try {\n          // Convert amount to octas (Aptos uses 8 decimal places)\n          const amountInOctas = Math.floor(parseFloat(operation.amount) * 100000000).toString();\n\n          // Create transaction payload\n          const txPayload = {\n            function: `${operation.contractAddress}${operation.functionName}`,\n            type_arguments: [],\n            arguments: [amountInOctas]\n          };\n\n          // Execute transaction\n          const txResult = await executeTransaction(txPayload);\n\n          // Add to successful operations\n          results.operations.push({\n            ...operation,\n            hash: txResult.hash,\n            status: 'success'\n          });\n\n          // Show success notification for each step\n          showNotification(`Successfully executed ${operation.type} on ${operation.protocol}`, 'success');\n        } catch (error) {\n          console.error(`Operation failed: ${operation.type} on ${operation.protocol}`, error);\n\n          // Add to failed operations\n          results.failedOperations.push({\n            ...operation,\n            error: error.message,\n            status: 'failed'\n          });\n          results.success = false;\n\n          // Show error notification\n          showNotification(`Failed to execute ${operation.type} on ${operation.protocol}: ${error.message}`, 'error');\n        }\n      }\n\n      // Update status and result\n      setStatus(results.success ? 'success' : 'partial');\n      setResult(results);\n\n      // Show final notification\n      showNotification(results.success ? `Strategy executed successfully! ${results.operations.length} operations completed.` : `Strategy completed with ${results.failedOperations.length} failures out of ${operations.length} operations.`, results.success ? 'success' : 'warning');\n      return results;\n    } catch (error) {\n      console.error('Strategy execution failed:', error);\n      setStatus('error');\n      setError(error.message || 'Strategy execution failed');\n      showNotification(`Strategy execution failed: ${error.message}`, 'error');\n      throw error;\n    } finally {\n      setIsExecuting(false);\n    }\n  }, [executeTransaction, showNotification]);\n\n  // Add a transaction to history (for tracking external transactions)\n  const addTransaction = useCallback(transaction => {\n    setRecentTransactions(prev => [transaction, ...prev]);\n  }, []);\n\n  // Clear transaction history\n  const clearTransactionHistory = useCallback(() => {\n    setRecentTransactions([]);\n    localStorage.removeItem('recentTransactions');\n  }, []);\n  return /*#__PURE__*/_jsxDEV(TransactionContext.Provider, {\n    value: {\n      pendingTransactions,\n      recentTransactions,\n      isExecuting,\n      status,\n      error,\n      result,\n      executeTransaction,\n      executeAIStrategy,\n      addTransaction,\n      clearTransactionHistory\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 237,\n    columnNumber: 5\n  }, this);\n};\n_s(TransactionProvider, \"hjIG1G1iWz3ZcMsO9nQf09e5QnY=\");\n_c = TransactionProvider;\nexport const useTransactionContext = () => {\n  _s2();\n  const context = React.useContext(TransactionContext);\n  if (context === undefined) {\n    throw new Error('useTransactionContext must be used within a TransactionProvider');\n  }\n  return context;\n};\n_s2(useTransactionContext, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"TransactionProvider\");","map":{"version":3,"names":["React","createContext","useState","useCallback","useEffect","useContext","WalletContext","NotificationContext","jsxDEV","_jsxDEV","TransactionContext","TransactionProvider","children","_s","wallet","address","isConnected","showNotification","pendingTransactions","setPendingTransactions","recentTransactions","setRecentTransactions","isExecuting","setIsExecuting","status","setStatus","error","setError","result","setResult","savedTransactions","localStorage","getItem","JSON","parse","console","length","setItem","stringify","executeTransaction","payload","Error","_payload$function","txId","Date","now","toString","pendingTx","id","timestamp","prev","response","signAndSubmitTransaction","txHash","hash","txResult","success","gas_used","Math","floor","random","vm_status","txRecord","type","function","split","pop","gasFee","filter","tx","_error$message","_error$message2","message","includes","executeAIStrategy","operations","results","failedOperations","i","operation","amountInOctas","parseFloat","amount","txPayload","contractAddress","functionName","type_arguments","arguments","push","protocol","addTransaction","transaction","clearTransactionHistory","removeItem","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useTransactionContext","_s2","context","undefined","$RefreshReg$"],"sources":["/home/ck/compoundefi/client/src/context/TransactionContext.jsx"],"sourcesContent":["// src/context/TransactionContext.jsx\r\nimport React, { createContext, useState, useCallback, useEffect, useContext } from 'react';\r\nimport { WalletContext } from './WalletContext';\r\nimport { NotificationContext } from './NotificationContext';\r\n\r\n// Create context\r\nexport const TransactionContext = createContext();\r\n\r\nexport const TransactionProvider = ({ children }) => {\r\n  const { wallet, address, isConnected } = useContext(WalletContext);\r\n  const { showNotification } = useContext(NotificationContext);\r\n  \r\n  const [pendingTransactions, setPendingTransactions] = useState([]);\r\n  const [recentTransactions, setRecentTransactions] = useState([]);\r\n  const [isExecuting, setIsExecuting] = useState(false);\r\n  const [status, setStatus] = useState('idle'); // idle, pending, success, error\r\n  const [error, setError] = useState(null);\r\n  const [result, setResult] = useState(null);\r\n\r\n  // Load transaction history from localStorage on mount\r\n  useEffect(() => {\r\n    try {\r\n      const savedTransactions = localStorage.getItem('recentTransactions');\r\n      if (savedTransactions) {\r\n        setRecentTransactions(JSON.parse(savedTransactions));\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to load transaction history:', error);\r\n    }\r\n  }, []);\r\n\r\n  // Save transaction history to localStorage when it changes\r\n  useEffect(() => {\r\n    if (recentTransactions.length > 0) {\r\n      localStorage.setItem('recentTransactions', JSON.stringify(recentTransactions));\r\n    }\r\n  }, [recentTransactions]);\r\n\r\n  // Execute a single transaction\r\n  const executeTransaction = useCallback(async (payload) => {\r\n    if (!isConnected || !wallet) {\r\n      setError('Wallet not connected');\r\n      showNotification('Please connect your wallet to execute transactions', 'error');\r\n      throw new Error('Wallet not connected');\r\n    }\r\n\r\n    try {\r\n      setIsExecuting(true);\r\n      setStatus('pending');\r\n      setError(null);\r\n      \r\n      // Add to pending transactions\r\n      const txId = Date.now().toString();\r\n      const pendingTx = { \r\n        id: txId, \r\n        payload, \r\n        status: 'pending',\r\n        timestamp: Date.now()\r\n      };\r\n      \r\n      setPendingTransactions(prev => [...prev, pendingTx]);\r\n      \r\n      // Show notification\r\n      showNotification('Confirm the transaction in your wallet', 'info');\r\n\r\n      // Send transaction to wallet for signing\r\n      const response = await wallet.signAndSubmitTransaction(payload);\r\n      \r\n      // Update status based on response\r\n      const txHash = response.hash || `tx_${txId}`;\r\n      \r\n      // Simulate transaction confirmation\r\n      // In production, you'd use an Aptos client to wait for the transaction\r\n      const txResult = {\r\n        success: true,\r\n        hash: txHash,\r\n        gas_used: Math.floor(Math.random() * 1000),\r\n        vm_status: \"Executed successfully\"\r\n      };\r\n      \r\n      // Update transaction history\r\n      const txRecord = {\r\n        id: txId,\r\n        hash: txResult.hash,\r\n        success: txResult.success,\r\n        timestamp: Date.now(),\r\n        type: payload.function?.split('::').pop() || 'transaction',\r\n        gasFee: txResult.gas_used || 0,\r\n        payload\r\n      };\r\n      \r\n      setRecentTransactions(prev => [txRecord, ...prev]);\r\n      \r\n      // Remove from pending\r\n      setPendingTransactions(prev => prev.filter(tx => tx.id !== txId));\r\n      \r\n      // Update status and result\r\n      setStatus('success');\r\n      setResult(txResult);\r\n      \r\n      // Show notification\r\n      showNotification(\r\n        'Transaction completed successfully',\r\n        'success'\r\n      );\r\n      \r\n      return txResult;\r\n    } catch (error) {\r\n      console.error('Transaction failed:', error);\r\n      \r\n      setStatus('error');\r\n      setError(error.message || 'Transaction failed');\r\n      \r\n      // Check if user rejected transaction\r\n      if (error.message?.includes('reject') || error.message?.includes('user denied')) {\r\n        showNotification('Transaction was rejected', 'warning');\r\n      } else {\r\n        showNotification(`Transaction failed: ${error.message}`, 'error');\r\n      }\r\n      \r\n      throw error;\r\n    } finally {\r\n      setIsExecuting(false);\r\n    }\r\n  }, [wallet, address, isConnected, showNotification]);\r\n\r\n  // Execute AI-recommended strategy\r\n  const executeAIStrategy = useCallback(async (operations) => {\r\n    if (!operations || operations.length === 0) {\r\n      throw new Error('No operations provided for strategy execution');\r\n    }\r\n\r\n    try {\r\n      setIsExecuting(true);\r\n      setStatus('pending');\r\n      setError(null);\r\n      \r\n      const results = {\r\n        success: true,\r\n        operations: [],\r\n        failedOperations: [],\r\n        timestamp: Date.now()\r\n      };\r\n      \r\n      // Show strategy execution notification\r\n      showNotification('Executing investment strategy...', 'info');\r\n      \r\n      // Execute each operation sequentially\r\n      for (let i = 0; i < operations.length; i++) {\r\n        const operation = operations[i];\r\n        \r\n        try {\r\n          // Convert amount to octas (Aptos uses 8 decimal places)\r\n          const amountInOctas = Math.floor(parseFloat(operation.amount) * 100000000).toString();\r\n          \r\n          // Create transaction payload\r\n          const txPayload = {\r\n            function: `${operation.contractAddress}${operation.functionName}`,\r\n            type_arguments: [],\r\n            arguments: [amountInOctas]\r\n          };\r\n          \r\n          // Execute transaction\r\n          const txResult = await executeTransaction(txPayload);\r\n          \r\n          // Add to successful operations\r\n          results.operations.push({\r\n            ...operation,\r\n            hash: txResult.hash,\r\n            status: 'success'\r\n          });\r\n          \r\n          // Show success notification for each step\r\n          showNotification(\r\n            `Successfully executed ${operation.type} on ${operation.protocol}`,\r\n            'success'\r\n          );\r\n          \r\n        } catch (error) {\r\n          console.error(`Operation failed: ${operation.type} on ${operation.protocol}`, error);\r\n          \r\n          // Add to failed operations\r\n          results.failedOperations.push({\r\n            ...operation,\r\n            error: error.message,\r\n            status: 'failed'\r\n          });\r\n          \r\n          results.success = false;\r\n          \r\n          // Show error notification\r\n          showNotification(\r\n            `Failed to execute ${operation.type} on ${operation.protocol}: ${error.message}`,\r\n            'error'\r\n          );\r\n        }\r\n      }\r\n      \r\n      // Update status and result\r\n      setStatus(results.success ? 'success' : 'partial');\r\n      setResult(results);\r\n      \r\n      // Show final notification\r\n      showNotification(\r\n        results.success \r\n          ? `Strategy executed successfully! ${results.operations.length} operations completed.` \r\n          : `Strategy completed with ${results.failedOperations.length} failures out of ${operations.length} operations.`,\r\n        results.success ? 'success' : 'warning'\r\n      );\r\n      \r\n      return results;\r\n    } catch (error) {\r\n      console.error('Strategy execution failed:', error);\r\n      \r\n      setStatus('error');\r\n      setError(error.message || 'Strategy execution failed');\r\n      \r\n      showNotification(`Strategy execution failed: ${error.message}`, 'error');\r\n      throw error;\r\n    } finally {\r\n      setIsExecuting(false);\r\n    }\r\n  }, [executeTransaction, showNotification]);\r\n\r\n  // Add a transaction to history (for tracking external transactions)\r\n  const addTransaction = useCallback((transaction) => {\r\n    setRecentTransactions(prev => [transaction, ...prev]);\r\n  }, []);\r\n\r\n  // Clear transaction history\r\n  const clearTransactionHistory = useCallback(() => {\r\n    setRecentTransactions([]);\r\n    localStorage.removeItem('recentTransactions');\r\n  }, []);\r\n\r\n  return (\r\n    <TransactionContext.Provider\r\n      value={{\r\n        pendingTransactions,\r\n        recentTransactions,\r\n        isExecuting,\r\n        status,\r\n        error,\r\n        result,\r\n        executeTransaction,\r\n        executeAIStrategy,\r\n        addTransaction,\r\n        clearTransactionHistory\r\n      }}\r\n    >\r\n      {children}\r\n    </TransactionContext.Provider>\r\n  );\r\n};\r\n\r\nexport const useTransactionContext = () => {\r\n  const context = React.useContext(TransactionContext);\r\n  if (context === undefined) {\r\n    throw new Error('useTransactionContext must be used within a TransactionProvider');\r\n  }\r\n  return context;\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}