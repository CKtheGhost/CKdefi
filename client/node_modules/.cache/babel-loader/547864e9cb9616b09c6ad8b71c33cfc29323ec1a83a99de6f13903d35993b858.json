{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useContext, useCallback } from 'react';\nimport axios from 'axios';\nimport { NotificationContext } from '../context/NotificationContext';\nimport { DataContext } from '../context/DataContext';\n\n/**\r\n * Custom hook for fetching and managing market data\r\n * Handles staking rates, token prices, news, and protocol comparisons\r\n */\nconst useMarketData = () => {\n  _s();\n  const {\n    setNotification\n  } = useContext(NotificationContext);\n  const {\n    setMarketData\n  } = useContext(DataContext);\n\n  // Local state for loading indicators and error handling\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [lastUpdated, setLastUpdated] = useState(null);\n  const [refreshIntervals, setRefreshIntervals] = useState({\n    stakingRates: 10 * 60 * 1000,\n    // 10 minutes\n    tokenPrices: 3 * 60 * 1000,\n    // 3 minutes\n    news: 15 * 60 * 1000,\n    // 15 minutes\n    protocols: 30 * 60 * 1000 // 30 minutes\n  });\n\n  // State for different data types\n  const [stakingRates, setStakingRates] = useState({});\n  const [tokenPrices, setTokenPrices] = useState({});\n  const [news, setNews] = useState([]);\n  const [protocols, setProtocols] = useState({});\n  const [strategies, setStrategies] = useState([]);\n\n  /**\r\n   * Fetch all market data\r\n   */\n  const fetchAllData = useCallback(async () => {\n    setLoading(true);\n    setError(null);\n    try {\n      // Fetch data in parallel for better performance\n      const [stakingResponse, tokensResponse, newsResponse, protocolsResponse] = await Promise.all([axios.get('/api/staking/rates'), axios.get('/api/tokens/latest'), axios.get('/api/news/latest'), axios.get('/api/protocols')]);\n\n      // Update individual data states\n      setStakingRates(stakingResponse.data.protocols || {});\n      setTokenPrices(tokensResponse.data.coins || []);\n      setNews(newsResponse.data.articles || []);\n      setProtocols(protocolsResponse.data.protocols || {});\n\n      // If strategies are included in staking response\n      if (stakingResponse.data.strategies) {\n        setStrategies(stakingResponse.data.strategies);\n      }\n\n      // Update last updated timestamp\n      setLastUpdated(new Date().toISOString());\n\n      // Update global market data context\n      setMarketData({\n        stakingRates: stakingResponse.data.protocols || {},\n        tokenPrices: tokensResponse.data.coins || [],\n        news: newsResponse.data.articles || [],\n        protocols: protocolsResponse.data.protocols || {},\n        strategies: stakingResponse.data.strategies || [],\n        lastUpdated: new Date().toISOString()\n      });\n      setLoading(false);\n    } catch (err) {\n      console.error('Error fetching market data:', err);\n      setError(err.message || 'Failed to fetch market data');\n      setNotification({\n        type: 'error',\n        message: 'Failed to fetch market data. Please try again later.'\n      });\n      setLoading(false);\n    }\n  }, [setNotification, setMarketData]);\n\n  /**\r\n   * Refresh staking rates data\r\n   */\n  const refreshStakingRates = useCallback(async () => {\n    try {\n      const response = await axios.get('/api/staking/rates');\n      setStakingRates(response.data.protocols || {});\n      if (response.data.strategies) {\n        setStrategies(response.data.strategies);\n      }\n      setLastUpdated(new Date().toISOString());\n      return response.data;\n    } catch (err) {\n      console.error('Error refreshing staking rates:', err);\n      setNotification({\n        type: 'error',\n        message: 'Failed to refresh staking rates'\n      });\n      throw err;\n    }\n  }, [setNotification]);\n\n  /**\r\n   * Refresh token prices data\r\n   */\n  const refreshTokenPrices = useCallback(async () => {\n    try {\n      const response = await axios.get('/api/tokens/latest');\n      setTokenPrices(response.data.coins || []);\n      setLastUpdated(new Date().toISOString());\n      return response.data;\n    } catch (err) {\n      console.error('Error refreshing token prices:', err);\n      setNotification({\n        type: 'error',\n        message: 'Failed to refresh token prices'\n      });\n      throw err;\n    }\n  }, [setNotification]);\n\n  /**\r\n   * Refresh news data\r\n   */\n  const refreshNews = useCallback(async () => {\n    try {\n      const response = await axios.get('/api/news/latest');\n      setNews(response.data.articles || []);\n      setLastUpdated(new Date().toISOString());\n      return response.data;\n    } catch (err) {\n      console.error('Error refreshing news:', err);\n      setNotification({\n        type: 'error',\n        message: 'Failed to refresh news'\n      });\n      throw err;\n    }\n  }, [setNotification]);\n\n  /**\r\n   * Get the price of a specific token\r\n   * @param {string} tokenId - Token identifier (e.g., 'aptos')\r\n   * @returns {Promise<number>} - Token price\r\n   */\n  const getTokenPrice = useCallback(async tokenId => {\n    try {\n      // Check if we already have the price in local state\n      const tokenData = tokenPrices.find(token => {\n        var _token$id, _token$symbol;\n        return ((_token$id = token.id) === null || _token$id === void 0 ? void 0 : _token$id.toLowerCase()) === tokenId.toLowerCase() || ((_token$symbol = token.symbol) === null || _token$symbol === void 0 ? void 0 : _token$symbol.toLowerCase()) === tokenId.toLowerCase();\n      });\n      if (tokenData !== null && tokenData !== void 0 && tokenData.price) {\n        return tokenData.price;\n      }\n\n      // If not, fetch it from the API\n      const response = await axios.get(`/api/tokens/price/${tokenId}`);\n      if (response.data && response.data.price) {\n        return response.data.price;\n      }\n      throw new Error(`Could not get price for ${tokenId}`);\n    } catch (err) {\n      console.error(`Error getting price for ${tokenId}:`, err);\n      // Default fallbacks for common tokens\n      if (tokenId.toLowerCase() === 'aptos' || tokenId.toLowerCase() === 'apt') {\n        return 10.50; // Default APT price\n      }\n      throw err;\n    }\n  }, [tokenPrices]);\n\n  /**\r\n   * Compare APY/APR rates across protocols\r\n   * @returns {Object} Comparison data for visualization\r\n   */\n  const compareProtocolRates = useCallback(() => {\n    const comparison = {\n      protocols: [],\n      rates: [],\n      bestApr: 0,\n      bestProtocol: ''\n    };\n    try {\n      // Extract protocols and their staking APRs\n      Object.entries(stakingRates).forEach(([protocol, data]) => {\n        if (data.staking && data.staking.apr) {\n          const apr = parseFloat(data.staking.apr);\n          comparison.protocols.push(protocol);\n          comparison.rates.push(apr);\n          if (apr > comparison.bestApr) {\n            comparison.bestApr = apr;\n            comparison.bestProtocol = protocol;\n          }\n        }\n      });\n      return comparison;\n    } catch (err) {\n      console.error('Error comparing protocol rates:', err);\n      return comparison;\n    }\n  }, [stakingRates]);\n\n  /**\r\n   * Get recommended strategy based on risk profile\r\n   * @param {string} riskProfile - User's risk profile (conservative, balanced, aggressive)\r\n   * @returns {Object} Recommended strategy\r\n   */\n  const getRecommendedStrategy = useCallback((riskProfile = 'balanced') => {\n    try {\n      // Filter strategies by risk profile\n      const matchingStrategies = strategies.filter(strategy => {\n        var _strategy$riskProfile;\n        return ((_strategy$riskProfile = strategy.riskProfile) === null || _strategy$riskProfile === void 0 ? void 0 : _strategy$riskProfile.toLowerCase()) === riskProfile.toLowerCase();\n      });\n      if (matchingStrategies.length > 0) {\n        // Sort by APR (highest first)\n        return matchingStrategies.sort((a, b) => parseFloat(b.apr) - parseFloat(a.apr))[0];\n      }\n\n      // If no matching strategies, return the first one or null\n      return strategies.length > 0 ? strategies[0] : null;\n    } catch (err) {\n      console.error('Error getting recommended strategy:', err);\n      return null;\n    }\n  }, [strategies]);\n\n  /**\r\n   * Update refresh intervals for different data types\r\n   * @param {Object} intervals - New intervals in milliseconds\r\n   */\n  const updateRefreshIntervals = useCallback(intervals => {\n    setRefreshIntervals(prev => ({\n      ...prev,\n      ...intervals\n    }));\n  }, []);\n\n  // Set up automatic refresh intervals when component mounts\n  useEffect(() => {\n    // Initial data fetch\n    fetchAllData();\n\n    // Set up interval for staking rates\n    const stakingInterval = setInterval(() => {\n      refreshStakingRates().catch(err => console.error('Auto-refresh staking error:', err));\n    }, refreshIntervals.stakingRates);\n\n    // Set up interval for token prices\n    const tokensInterval = setInterval(() => {\n      refreshTokenPrices().catch(err => console.error('Auto-refresh tokens error:', err));\n    }, refreshIntervals.tokenPrices);\n\n    // Set up interval for news\n    const newsInterval = setInterval(() => {\n      refreshNews().catch(err => console.error('Auto-refresh news error:', err));\n    }, refreshIntervals.news);\n\n    // Clear intervals on unmount\n    return () => {\n      clearInterval(stakingInterval);\n      clearInterval(tokensInterval);\n      clearInterval(newsInterval);\n    };\n  }, [fetchAllData, refreshStakingRates, refreshTokenPrices, refreshNews, refreshIntervals]);\n  return {\n    // Data states\n    stakingRates,\n    tokenPrices,\n    news,\n    protocols,\n    strategies,\n    // Status indicators\n    loading,\n    error,\n    lastUpdated,\n    // Methods\n    fetchAllData,\n    refreshStakingRates,\n    refreshTokenPrices,\n    refreshNews,\n    getTokenPrice,\n    compareProtocolRates,\n    getRecommendedStrategy,\n    updateRefreshIntervals\n  };\n};\n_s(useMarketData, \"Lll7ZN0FvyShk250nh/86PEA5Us=\");\nconst useMarketDataHook = (...args) => {\n  // Implementation\n};\nexport default useMarketDataHook;","map":{"version":3,"names":["useState","useEffect","useContext","useCallback","axios","NotificationContext","DataContext","useMarketData","_s","setNotification","setMarketData","loading","setLoading","error","setError","lastUpdated","setLastUpdated","refreshIntervals","setRefreshIntervals","stakingRates","tokenPrices","news","protocols","setStakingRates","setTokenPrices","setNews","setProtocols","strategies","setStrategies","fetchAllData","stakingResponse","tokensResponse","newsResponse","protocolsResponse","Promise","all","get","data","coins","articles","Date","toISOString","err","console","message","type","refreshStakingRates","response","refreshTokenPrices","refreshNews","getTokenPrice","tokenId","tokenData","find","token","_token$id","_token$symbol","id","toLowerCase","symbol","price","Error","compareProtocolRates","comparison","rates","bestApr","bestProtocol","Object","entries","forEach","protocol","staking","apr","parseFloat","push","getRecommendedStrategy","riskProfile","matchingStrategies","filter","strategy","_strategy$riskProfile","length","sort","a","b","updateRefreshIntervals","intervals","prev","stakingInterval","setInterval","catch","tokensInterval","newsInterval","clearInterval","useMarketDataHook","args"],"sources":["/home/ck/compoundefi/client/src/hooks/useMarketData.js"],"sourcesContent":["import { useState, useEffect, useContext, useCallback } from 'react';\r\nimport axios from 'axios';\r\nimport { NotificationContext } from '../context/NotificationContext';\r\nimport { DataContext } from '../context/DataContext';\r\n\r\n/**\r\n * Custom hook for fetching and managing market data\r\n * Handles staking rates, token prices, news, and protocol comparisons\r\n */\r\nconst useMarketData = () => {\r\n  const { setNotification } = useContext(NotificationContext);\r\n  const { setMarketData } = useContext(DataContext);\r\n  \r\n  // Local state for loading indicators and error handling\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState(null);\r\n  const [lastUpdated, setLastUpdated] = useState(null);\r\n  const [refreshIntervals, setRefreshIntervals] = useState({\r\n    stakingRates: 10 * 60 * 1000, // 10 minutes\r\n    tokenPrices: 3 * 60 * 1000,   // 3 minutes\r\n    news: 15 * 60 * 1000,         // 15 minutes\r\n    protocols: 30 * 60 * 1000     // 30 minutes\r\n  });\r\n\r\n  // State for different data types\r\n  const [stakingRates, setStakingRates] = useState({});\r\n  const [tokenPrices, setTokenPrices] = useState({});\r\n  const [news, setNews] = useState([]);\r\n  const [protocols, setProtocols] = useState({});\r\n  const [strategies, setStrategies] = useState([]);\r\n\r\n  /**\r\n   * Fetch all market data\r\n   */\r\n  const fetchAllData = useCallback(async () => {\r\n    setLoading(true);\r\n    setError(null);\r\n    \r\n    try {\r\n      // Fetch data in parallel for better performance\r\n      const [stakingResponse, tokensResponse, newsResponse, protocolsResponse] = await Promise.all([\r\n        axios.get('/api/staking/rates'),\r\n        axios.get('/api/tokens/latest'),\r\n        axios.get('/api/news/latest'),\r\n        axios.get('/api/protocols')\r\n      ]);\r\n      \r\n      // Update individual data states\r\n      setStakingRates(stakingResponse.data.protocols || {});\r\n      setTokenPrices(tokensResponse.data.coins || []);\r\n      setNews(newsResponse.data.articles || []);\r\n      setProtocols(protocolsResponse.data.protocols || {});\r\n      \r\n      // If strategies are included in staking response\r\n      if (stakingResponse.data.strategies) {\r\n        setStrategies(stakingResponse.data.strategies);\r\n      }\r\n      \r\n      // Update last updated timestamp\r\n      setLastUpdated(new Date().toISOString());\r\n      \r\n      // Update global market data context\r\n      setMarketData({\r\n        stakingRates: stakingResponse.data.protocols || {},\r\n        tokenPrices: tokensResponse.data.coins || [],\r\n        news: newsResponse.data.articles || [],\r\n        protocols: protocolsResponse.data.protocols || {},\r\n        strategies: stakingResponse.data.strategies || [],\r\n        lastUpdated: new Date().toISOString()\r\n      });\r\n      \r\n      setLoading(false);\r\n    } catch (err) {\r\n      console.error('Error fetching market data:', err);\r\n      setError(err.message || 'Failed to fetch market data');\r\n      setNotification({\r\n        type: 'error',\r\n        message: 'Failed to fetch market data. Please try again later.'\r\n      });\r\n      setLoading(false);\r\n    }\r\n  }, [setNotification, setMarketData]);\r\n\r\n  /**\r\n   * Refresh staking rates data\r\n   */\r\n  const refreshStakingRates = useCallback(async () => {\r\n    try {\r\n      const response = await axios.get('/api/staking/rates');\r\n      setStakingRates(response.data.protocols || {});\r\n      \r\n      if (response.data.strategies) {\r\n        setStrategies(response.data.strategies);\r\n      }\r\n      \r\n      setLastUpdated(new Date().toISOString());\r\n      return response.data;\r\n    } catch (err) {\r\n      console.error('Error refreshing staking rates:', err);\r\n      setNotification({\r\n        type: 'error',\r\n        message: 'Failed to refresh staking rates'\r\n      });\r\n      throw err;\r\n    }\r\n  }, [setNotification]);\r\n\r\n  /**\r\n   * Refresh token prices data\r\n   */\r\n  const refreshTokenPrices = useCallback(async () => {\r\n    try {\r\n      const response = await axios.get('/api/tokens/latest');\r\n      setTokenPrices(response.data.coins || []);\r\n      setLastUpdated(new Date().toISOString());\r\n      return response.data;\r\n    } catch (err) {\r\n      console.error('Error refreshing token prices:', err);\r\n      setNotification({\r\n        type: 'error',\r\n        message: 'Failed to refresh token prices'\r\n      });\r\n      throw err;\r\n    }\r\n  }, [setNotification]);\r\n\r\n  /**\r\n   * Refresh news data\r\n   */\r\n  const refreshNews = useCallback(async () => {\r\n    try {\r\n      const response = await axios.get('/api/news/latest');\r\n      setNews(response.data.articles || []);\r\n      setLastUpdated(new Date().toISOString());\r\n      return response.data;\r\n    } catch (err) {\r\n      console.error('Error refreshing news:', err);\r\n      setNotification({\r\n        type: 'error',\r\n        message: 'Failed to refresh news'\r\n      });\r\n      throw err;\r\n    }\r\n  }, [setNotification]);\r\n\r\n  /**\r\n   * Get the price of a specific token\r\n   * @param {string} tokenId - Token identifier (e.g., 'aptos')\r\n   * @returns {Promise<number>} - Token price\r\n   */\r\n  const getTokenPrice = useCallback(async (tokenId) => {\r\n    try {\r\n      // Check if we already have the price in local state\r\n      const tokenData = tokenPrices.find(token => \r\n        token.id?.toLowerCase() === tokenId.toLowerCase() || \r\n        token.symbol?.toLowerCase() === tokenId.toLowerCase()\r\n      );\r\n      \r\n      if (tokenData?.price) {\r\n        return tokenData.price;\r\n      }\r\n      \r\n      // If not, fetch it from the API\r\n      const response = await axios.get(`/api/tokens/price/${tokenId}`);\r\n      \r\n      if (response.data && response.data.price) {\r\n        return response.data.price;\r\n      }\r\n      \r\n      throw new Error(`Could not get price for ${tokenId}`);\r\n    } catch (err) {\r\n      console.error(`Error getting price for ${tokenId}:`, err);\r\n      // Default fallbacks for common tokens\r\n      if (tokenId.toLowerCase() === 'aptos' || tokenId.toLowerCase() === 'apt') {\r\n        return 10.50; // Default APT price\r\n      }\r\n      throw err;\r\n    }\r\n  }, [tokenPrices]);\r\n\r\n  /**\r\n   * Compare APY/APR rates across protocols\r\n   * @returns {Object} Comparison data for visualization\r\n   */\r\n  const compareProtocolRates = useCallback(() => {\r\n    const comparison = {\r\n      protocols: [],\r\n      rates: [],\r\n      bestApr: 0,\r\n      bestProtocol: ''\r\n    };\r\n    \r\n    try {\r\n      // Extract protocols and their staking APRs\r\n      Object.entries(stakingRates).forEach(([protocol, data]) => {\r\n        if (data.staking && data.staking.apr) {\r\n          const apr = parseFloat(data.staking.apr);\r\n          comparison.protocols.push(protocol);\r\n          comparison.rates.push(apr);\r\n          \r\n          if (apr > comparison.bestApr) {\r\n            comparison.bestApr = apr;\r\n            comparison.bestProtocol = protocol;\r\n          }\r\n        }\r\n      });\r\n      \r\n      return comparison;\r\n    } catch (err) {\r\n      console.error('Error comparing protocol rates:', err);\r\n      return comparison;\r\n    }\r\n  }, [stakingRates]);\r\n\r\n  /**\r\n   * Get recommended strategy based on risk profile\r\n   * @param {string} riskProfile - User's risk profile (conservative, balanced, aggressive)\r\n   * @returns {Object} Recommended strategy\r\n   */\r\n  const getRecommendedStrategy = useCallback((riskProfile = 'balanced') => {\r\n    try {\r\n      // Filter strategies by risk profile\r\n      const matchingStrategies = strategies.filter(strategy => \r\n        strategy.riskProfile?.toLowerCase() === riskProfile.toLowerCase()\r\n      );\r\n      \r\n      if (matchingStrategies.length > 0) {\r\n        // Sort by APR (highest first)\r\n        return matchingStrategies.sort((a, b) => parseFloat(b.apr) - parseFloat(a.apr))[0];\r\n      }\r\n      \r\n      // If no matching strategies, return the first one or null\r\n      return strategies.length > 0 ? strategies[0] : null;\r\n    } catch (err) {\r\n      console.error('Error getting recommended strategy:', err);\r\n      return null;\r\n    }\r\n  }, [strategies]);\r\n\r\n  /**\r\n   * Update refresh intervals for different data types\r\n   * @param {Object} intervals - New intervals in milliseconds\r\n   */\r\n  const updateRefreshIntervals = useCallback((intervals) => {\r\n    setRefreshIntervals(prev => ({\r\n      ...prev,\r\n      ...intervals\r\n    }));\r\n  }, []);\r\n\r\n  // Set up automatic refresh intervals when component mounts\r\n  useEffect(() => {\r\n    // Initial data fetch\r\n    fetchAllData();\r\n    \r\n    // Set up interval for staking rates\r\n    const stakingInterval = setInterval(() => {\r\n      refreshStakingRates().catch(err => console.error('Auto-refresh staking error:', err));\r\n    }, refreshIntervals.stakingRates);\r\n    \r\n    // Set up interval for token prices\r\n    const tokensInterval = setInterval(() => {\r\n      refreshTokenPrices().catch(err => console.error('Auto-refresh tokens error:', err));\r\n    }, refreshIntervals.tokenPrices);\r\n    \r\n    // Set up interval for news\r\n    const newsInterval = setInterval(() => {\r\n      refreshNews().catch(err => console.error('Auto-refresh news error:', err));\r\n    }, refreshIntervals.news);\r\n    \r\n    // Clear intervals on unmount\r\n    return () => {\r\n      clearInterval(stakingInterval);\r\n      clearInterval(tokensInterval);\r\n      clearInterval(newsInterval);\r\n    };\r\n  }, [fetchAllData, refreshStakingRates, refreshTokenPrices, refreshNews, refreshIntervals]);\r\n\r\n  return {\r\n    // Data states\r\n    stakingRates,\r\n    tokenPrices,\r\n    news,\r\n    protocols,\r\n    strategies,\r\n    \r\n    // Status indicators\r\n    loading,\r\n    error,\r\n    lastUpdated,\r\n    \r\n    // Methods\r\n    fetchAllData,\r\n    refreshStakingRates,\r\n    refreshTokenPrices,\r\n    refreshNews,\r\n    getTokenPrice,\r\n    compareProtocolRates,\r\n    getRecommendedStrategy,\r\n    updateRefreshIntervals\r\n  };\r\n};\r\n\r\nconst useMarketDataHook = (...args) => {\r\n  // Implementation\r\n};\r\n\r\nexport default useMarketDataHook;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}