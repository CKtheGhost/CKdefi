{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--) if (decorator = decorators[i]) result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\n\n// src/client/types.ts\nvar AptosApiError = class extends Error {\n  constructor(request2, response, message) {\n    super(message);\n    this.name = \"AptosApiError\";\n    this.url = response.url;\n    this.status = response.status;\n    this.statusText = response.statusText;\n    this.data = response.data;\n    this.request = request2;\n  }\n};\n\n// src/version.ts\nvar VERSION = \"2.0.0\";\n\n// src/types/index.ts\nvar MimeType = /* @__PURE__ */(MimeType2 => {\n  MimeType2[\"JSON\"] = \"application/json\";\n  MimeType2[\"BCS\"] = \"application/x-bcs\";\n  MimeType2[\"BCS_SIGNED_TRANSACTION\"] = \"application/x.aptos.signed_transaction+bcs\";\n  return MimeType2;\n})(MimeType || {});\nvar TypeTagVariants = /* @__PURE__ */(TypeTagVariants2 => {\n  TypeTagVariants2[TypeTagVariants2[\"Bool\"] = 0] = \"Bool\";\n  TypeTagVariants2[TypeTagVariants2[\"U8\"] = 1] = \"U8\";\n  TypeTagVariants2[TypeTagVariants2[\"U64\"] = 2] = \"U64\";\n  TypeTagVariants2[TypeTagVariants2[\"U128\"] = 3] = \"U128\";\n  TypeTagVariants2[TypeTagVariants2[\"Address\"] = 4] = \"Address\";\n  TypeTagVariants2[TypeTagVariants2[\"Signer\"] = 5] = \"Signer\";\n  TypeTagVariants2[TypeTagVariants2[\"Vector\"] = 6] = \"Vector\";\n  TypeTagVariants2[TypeTagVariants2[\"Struct\"] = 7] = \"Struct\";\n  TypeTagVariants2[TypeTagVariants2[\"U16\"] = 8] = \"U16\";\n  TypeTagVariants2[TypeTagVariants2[\"U32\"] = 9] = \"U32\";\n  TypeTagVariants2[TypeTagVariants2[\"U256\"] = 10] = \"U256\";\n  TypeTagVariants2[TypeTagVariants2[\"Reference\"] = 254] = \"Reference\";\n  TypeTagVariants2[TypeTagVariants2[\"Generic\"] = 255] = \"Generic\";\n  return TypeTagVariants2;\n})(TypeTagVariants || {});\nvar ScriptTransactionArgumentVariants = /* @__PURE__ */(ScriptTransactionArgumentVariants2 => {\n  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2[\"U8\"] = 0] = \"U8\";\n  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2[\"U64\"] = 1] = \"U64\";\n  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2[\"U128\"] = 2] = \"U128\";\n  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2[\"Address\"] = 3] = \"Address\";\n  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2[\"U8Vector\"] = 4] = \"U8Vector\";\n  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2[\"Bool\"] = 5] = \"Bool\";\n  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2[\"U16\"] = 6] = \"U16\";\n  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2[\"U32\"] = 7] = \"U32\";\n  ScriptTransactionArgumentVariants2[ScriptTransactionArgumentVariants2[\"U256\"] = 8] = \"U256\";\n  return ScriptTransactionArgumentVariants2;\n})(ScriptTransactionArgumentVariants || {});\nvar TransactionPayloadVariants = /* @__PURE__ */(TransactionPayloadVariants2 => {\n  TransactionPayloadVariants2[TransactionPayloadVariants2[\"Script\"] = 0] = \"Script\";\n  TransactionPayloadVariants2[TransactionPayloadVariants2[\"EntryFunction\"] = 2] = \"EntryFunction\";\n  TransactionPayloadVariants2[TransactionPayloadVariants2[\"Multisig\"] = 3] = \"Multisig\";\n  return TransactionPayloadVariants2;\n})(TransactionPayloadVariants || {});\nvar TransactionVariants = /* @__PURE__ */(TransactionVariants2 => {\n  TransactionVariants2[TransactionVariants2[\"MultiAgentTransaction\"] = 0] = \"MultiAgentTransaction\";\n  TransactionVariants2[TransactionVariants2[\"FeePayerTransaction\"] = 1] = \"FeePayerTransaction\";\n  return TransactionVariants2;\n})(TransactionVariants || {});\nvar TransactionAuthenticatorVariant = /* @__PURE__ */(TransactionAuthenticatorVariant2 => {\n  TransactionAuthenticatorVariant2[TransactionAuthenticatorVariant2[\"Ed25519\"] = 0] = \"Ed25519\";\n  TransactionAuthenticatorVariant2[TransactionAuthenticatorVariant2[\"MultiEd25519\"] = 1] = \"MultiEd25519\";\n  TransactionAuthenticatorVariant2[TransactionAuthenticatorVariant2[\"MultiAgent\"] = 2] = \"MultiAgent\";\n  TransactionAuthenticatorVariant2[TransactionAuthenticatorVariant2[\"FeePayer\"] = 3] = \"FeePayer\";\n  TransactionAuthenticatorVariant2[TransactionAuthenticatorVariant2[\"SingleSender\"] = 4] = \"SingleSender\";\n  return TransactionAuthenticatorVariant2;\n})(TransactionAuthenticatorVariant || {});\nvar AccountAuthenticatorVariant = /* @__PURE__ */(AccountAuthenticatorVariant2 => {\n  AccountAuthenticatorVariant2[AccountAuthenticatorVariant2[\"Ed25519\"] = 0] = \"Ed25519\";\n  AccountAuthenticatorVariant2[AccountAuthenticatorVariant2[\"MultiEd25519\"] = 1] = \"MultiEd25519\";\n  AccountAuthenticatorVariant2[AccountAuthenticatorVariant2[\"SingleKey\"] = 2] = \"SingleKey\";\n  AccountAuthenticatorVariant2[AccountAuthenticatorVariant2[\"MultiKey\"] = 3] = \"MultiKey\";\n  return AccountAuthenticatorVariant2;\n})(AccountAuthenticatorVariant || {});\nvar AnyPublicKeyVariant = /* @__PURE__ */(AnyPublicKeyVariant2 => {\n  AnyPublicKeyVariant2[AnyPublicKeyVariant2[\"Ed25519\"] = 0] = \"Ed25519\";\n  AnyPublicKeyVariant2[AnyPublicKeyVariant2[\"Secp256k1\"] = 1] = \"Secp256k1\";\n  return AnyPublicKeyVariant2;\n})(AnyPublicKeyVariant || {});\nvar AnySignatureVariant = /* @__PURE__ */(AnySignatureVariant2 => {\n  AnySignatureVariant2[AnySignatureVariant2[\"Ed25519\"] = 0] = \"Ed25519\";\n  AnySignatureVariant2[AnySignatureVariant2[\"Secp256k1\"] = 1] = \"Secp256k1\";\n  return AnySignatureVariant2;\n})(AnySignatureVariant || {});\nvar TransactionResponseType = /* @__PURE__ */(TransactionResponseType2 => {\n  TransactionResponseType2[\"Pending\"] = \"pending_transaction\";\n  TransactionResponseType2[\"User\"] = \"user_transaction\";\n  TransactionResponseType2[\"Genesis\"] = \"genesis_transaction\";\n  TransactionResponseType2[\"BlockMetadata\"] = \"block_metadata_transaction\";\n  TransactionResponseType2[\"StateCheckpoint\"] = \"state_checkpoint_transaction\";\n  return TransactionResponseType2;\n})(TransactionResponseType || {});\nvar MoveFunctionVisibility = /* @__PURE__ */(MoveFunctionVisibility2 => {\n  MoveFunctionVisibility2[\"PRIVATE\"] = \"private\";\n  MoveFunctionVisibility2[\"PUBLIC\"] = \"public\";\n  MoveFunctionVisibility2[\"FRIEND\"] = \"friend\";\n  return MoveFunctionVisibility2;\n})(MoveFunctionVisibility || {});\nvar MoveAbility = /* @__PURE__ */(MoveAbility2 => {\n  MoveAbility2[\"STORE\"] = \"store\";\n  MoveAbility2[\"DROP\"] = \"drop\";\n  MoveAbility2[\"KEY\"] = \"key\";\n  MoveAbility2[\"COPY\"] = \"copy\";\n  return MoveAbility2;\n})(MoveAbility || {});\nvar RoleType = /* @__PURE__ */(RoleType2 => {\n  RoleType2[\"VALIDATOR\"] = \"validator\";\n  RoleType2[\"FULL_NODE\"] = \"full_node\";\n  return RoleType2;\n})(RoleType || {});\nvar SigningScheme = /* @__PURE__ */(SigningScheme2 => {\n  SigningScheme2[SigningScheme2[\"Ed25519\"] = 0] = \"Ed25519\";\n  SigningScheme2[SigningScheme2[\"MultiEd25519\"] = 1] = \"MultiEd25519\";\n  SigningScheme2[SigningScheme2[\"SingleKey\"] = 2] = \"SingleKey\";\n  SigningScheme2[SigningScheme2[\"MultiKey\"] = 3] = \"MultiKey\";\n  return SigningScheme2;\n})(SigningScheme || {});\nvar SigningSchemeInput = /* @__PURE__ */(SigningSchemeInput2 => {\n  SigningSchemeInput2[SigningSchemeInput2[\"Ed25519\"] = 0] = \"Ed25519\";\n  SigningSchemeInput2[SigningSchemeInput2[\"Secp256k1Ecdsa\"] = 2] = \"Secp256k1Ecdsa\";\n  return SigningSchemeInput2;\n})(SigningSchemeInput || {});\nvar DeriveScheme = /* @__PURE__ */(DeriveScheme2 => {\n  DeriveScheme2[DeriveScheme2[\"DeriveAuid\"] = 251] = \"DeriveAuid\";\n  DeriveScheme2[DeriveScheme2[\"DeriveObjectAddressFromObject\"] = 252] = \"DeriveObjectAddressFromObject\";\n  DeriveScheme2[DeriveScheme2[\"DeriveObjectAddressFromGuid\"] = 253] = \"DeriveObjectAddressFromGuid\";\n  DeriveScheme2[DeriveScheme2[\"DeriveObjectAddressFromSeed\"] = 254] = \"DeriveObjectAddressFromSeed\";\n  DeriveScheme2[DeriveScheme2[\"DeriveResourceAccountAddress\"] = 255] = \"DeriveResourceAccountAddress\";\n  return DeriveScheme2;\n})(DeriveScheme || {});\n\n// src/client/core.ts\nvar errors = {\n  400: \"Bad Request\",\n  401: \"Unauthorized\",\n  403: \"Forbidden\",\n  404: \"Not Found\",\n  429: \"Too Many Requests\",\n  500: \"Internal Server Error\",\n  502: \"Bad Gateway\",\n  503: \"Service Unavailable\"\n};\nasync function request(options, client) {\n  const {\n    url,\n    method,\n    body,\n    contentType,\n    params,\n    overrides\n  } = options;\n  const headers = {\n    ...(overrides == null ? void 0 : overrides.HEADERS),\n    \"x-aptos-client\": `aptos-ts-sdk/${VERSION}`,\n    \"content-type\": contentType != null ? contentType : \"application/json\" /* JSON */\n  };\n  if (overrides == null ? void 0 : overrides.TOKEN) {\n    headers.Authorization = `Bearer ${overrides == null ? void 0 : overrides.TOKEN}`;\n  }\n  return client.provider({\n    url,\n    method,\n    body,\n    params,\n    headers,\n    overrides\n  });\n}\nasync function aptosRequest(options, aptosConfig) {\n  var _a;\n  const {\n    url,\n    path\n  } = options;\n  const fullUrl = `${url}/${path != null ? path : \"\"}`;\n  const response = await request({\n    ...options,\n    url: fullUrl\n  }, aptosConfig.client);\n  const result = {\n    status: response.status,\n    statusText: response.statusText,\n    data: response.data,\n    headers: response.headers,\n    config: response.config,\n    request: response.request,\n    url: fullUrl\n  };\n  if (aptosConfig.isIndexerRequest(url)) {\n    const indexerResponse = result.data;\n    if (indexerResponse.errors) {\n      throw new AptosApiError(options, result, (_a = indexerResponse.errors[0].message) != null ? _a : `Unhandled Error ${response.status} : ${response.statusText}`);\n    }\n    result.data = indexerResponse.data;\n  }\n  if (result.status >= 200 && result.status < 300) {\n    return result;\n  }\n  const errorMessage = errors[result.status];\n  throw new AptosApiError(options, result, errorMessage != null ? errorMessage : `Unhandled Error ${response.status} : ${response.statusText}`);\n}\n\n// src/utils/apiEndpoints.ts\nvar NetworkToIndexerAPI = {\n  mainnet: \"https://indexer.mainnet.aptoslabs.com/v1/graphql\",\n  testnet: \"https://indexer-testnet.staging.gcp.aptosdev.com/v1/graphql\",\n  devnet: \"https://indexer-devnet.staging.gcp.aptosdev.com/v1/graphql\",\n  local: \"http://127.0.0.1:8090/v1/graphql\"\n};\nvar NetworkToNodeAPI = {\n  mainnet: \"https://fullnode.mainnet.aptoslabs.com/v1\",\n  testnet: \"https://fullnode.testnet.aptoslabs.com/v1\",\n  devnet: \"https://fullnode.devnet.aptoslabs.com/v1\",\n  local: \"http://127.0.0.1:8080/v1\"\n};\nvar NetworkToFaucetAPI = {\n  mainnet: \"https://faucet.mainnet.aptoslabs.com\",\n  testnet: \"https://faucet.testnet.aptoslabs.com\",\n  devnet: \"https://faucet.devnet.aptoslabs.com\",\n  local: \"http://127.0.0.1:8081\"\n};\nvar Network = /* @__PURE__ */(Network2 => {\n  Network2[\"MAINNET\"] = \"mainnet\";\n  Network2[\"TESTNET\"] = \"testnet\";\n  Network2[\"DEVNET\"] = \"devnet\";\n  Network2[\"LOCAL\"] = \"local\";\n  Network2[\"CUSTOM\"] = \"custom\";\n  return Network2;\n})(Network || {});\nvar NetworkToChainId = {\n  mainnet: 1,\n  testnet: 2\n};\n\n// src/utils/const.ts\nvar DEFAULT_NETWORK = \"devnet\" /* DEVNET */;\nvar DEFAULT_MAX_GAS_AMOUNT = 2e5;\nvar DEFAULT_TXN_EXP_SEC_FROM_NOW = 20;\nvar DEFAULT_TXN_TIMEOUT_SEC = 20;\nvar APTOS_COIN = \"0x1::aptos_coin::AptosCoin\";\nvar RAW_TRANSACTION_SALT = \"APTOS::RawTransaction\";\nvar RAW_TRANSACTION_WITH_DATA_SALT = \"APTOS::RawTransactionWithData\";\n\n// src/client/get.ts\nasync function get(options) {\n  const {\n    aptosConfig,\n    overrides,\n    params,\n    contentType,\n    acceptType,\n    path,\n    originMethod,\n    type\n  } = options;\n  const url = aptosConfig.getRequestUrl(type);\n  return aptosRequest({\n    url,\n    method: \"GET\",\n    originMethod,\n    path,\n    contentType: contentType == null ? void 0 : contentType.valueOf(),\n    acceptType: acceptType == null ? void 0 : acceptType.valueOf(),\n    params,\n    overrides: {\n      ...aptosConfig.clientConfig,\n      ...overrides\n    }\n  }, aptosConfig);\n}\nasync function getAptosFullNode(options) {\n  return get({\n    ...options,\n    type: 0 /* FULLNODE */\n  });\n}\nasync function paginateWithCursor(options) {\n  const out = [];\n  let cursor;\n  const requestParams = options.params;\n  while (true) {\n    requestParams.start = cursor;\n    const response = await getAptosFullNode({\n      aptosConfig: options.aptosConfig,\n      originMethod: options.originMethod,\n      path: options.path,\n      params: requestParams,\n      overrides: options.overrides\n    });\n    cursor = response.headers[\"x-aptos-cursor\"];\n    delete response.headers;\n    out.push(...response.data);\n    if (cursor === null || cursor === void 0) {\n      break;\n    }\n  }\n  return out;\n}\n\n// src/client/post.ts\nasync function post(options) {\n  const {\n    type,\n    originMethod,\n    path,\n    body,\n    acceptType,\n    contentType,\n    params,\n    aptosConfig,\n    overrides\n  } = options;\n  const url = aptosConfig.getRequestUrl(type);\n  return aptosRequest({\n    url,\n    method: \"POST\",\n    originMethod,\n    path,\n    body,\n    contentType: contentType == null ? void 0 : contentType.valueOf(),\n    acceptType: acceptType == null ? void 0 : acceptType.valueOf(),\n    params,\n    overrides: {\n      ...aptosConfig.clientConfig,\n      ...overrides\n    }\n  }, aptosConfig);\n}\nasync function postAptosFullNode(options) {\n  return post({\n    ...options,\n    type: 0 /* FULLNODE */\n  });\n}\nasync function postAptosIndexer(options) {\n  return post({\n    ...options,\n    type: 1 /* INDEXER */\n  });\n}\nasync function postAptosFaucet(options) {\n  return post({\n    ...options,\n    type: 2 /* FAUCET */\n  });\n}\n\n// src/core/accountAddress.ts\nimport { bytesToHex as bytesToHex2, hexToBytes as hexToBytes2 } from \"@noble/hashes/utils\";\n\n// src/bcs/consts.ts\nvar MAX_U8_NUMBER = 2 ** 8 - 1;\nvar MAX_U16_NUMBER = 2 ** 16 - 1;\nvar MAX_U32_NUMBER = 2 ** 32 - 1;\nvar MAX_U64_BIG_INT = BigInt(2) ** BigInt(64) - BigInt(1);\nvar MAX_U128_BIG_INT = BigInt(2) ** BigInt(128) - BigInt(1);\nvar MAX_U256_BIG_INT = BigInt(2) ** BigInt(256) - BigInt(1);\n\n// src/core/hex.ts\nimport { bytesToHex, hexToBytes } from \"@noble/hashes/utils\";\n\n// src/core/common.ts\nvar ParsingError = class extends Error {\n  constructor(message, invalidReason) {\n    super(message);\n    this.invalidReason = invalidReason;\n  }\n};\n\n// src/core/hex.ts\nvar HexInvalidReason = /* @__PURE__ */(HexInvalidReason2 => {\n  HexInvalidReason2[\"TOO_SHORT\"] = \"too_short\";\n  HexInvalidReason2[\"INVALID_LENGTH\"] = \"invalid_length\";\n  HexInvalidReason2[\"INVALID_HEX_CHARS\"] = \"invalid_hex_chars\";\n  return HexInvalidReason2;\n})(HexInvalidReason || {});\nvar Hex = class {\n  constructor(data) {\n    this.data = data;\n  }\n  toUint8Array() {\n    return this.data;\n  }\n  toStringWithoutPrefix() {\n    return bytesToHex(this.data);\n  }\n  toString() {\n    return `0x${this.toStringWithoutPrefix()}`;\n  }\n  static fromString(str) {\n    let input = str;\n    if (input.startsWith(\"0x\")) {\n      input = input.slice(2);\n    }\n    if (input.length === 0) {\n      throw new ParsingError(\"Hex string is too short, must be at least 1 char long, excluding the optional leading 0x.\", \"too_short\" /* TOO_SHORT */);\n    }\n    if (input.length % 2 !== 0) {\n      throw new ParsingError(\"Hex string must be an even number of hex characters.\", \"invalid_length\" /* INVALID_LENGTH */);\n    }\n    try {\n      return new Hex(hexToBytes(input));\n    } catch (e) {\n      const error = e;\n      throw new ParsingError(`Hex string contains invalid hex characters: ${error.message}`, \"invalid_hex_chars\" /* INVALID_HEX_CHARS */);\n    }\n  }\n  static fromHexInput(hexInput) {\n    if (hexInput instanceof Uint8Array) return new Hex(hexInput);\n    return Hex.fromString(hexInput);\n  }\n  static isValid(str) {\n    try {\n      Hex.fromString(str);\n      return {\n        valid: true\n      };\n    } catch (e) {\n      const error = e;\n      return {\n        valid: false,\n        invalidReason: error.invalidReason,\n        invalidReasonMessage: error.message\n      };\n    }\n  }\n  equals(other) {\n    if (this.data.length !== other.data.length) return false;\n    return this.data.every((value, index) => value === other.data[index]);\n  }\n};\n\n// src/bcs/serializer.ts\nvar Serializable = class {\n  bcsToBytes() {\n    const serializer = new Serializer();\n    this.serialize(serializer);\n    return serializer.toUint8Array();\n  }\n  bcsToHex() {\n    const bcsBytes = this.bcsToBytes();\n    return Hex.fromHexInput(bcsBytes);\n  }\n};\nvar Serializer = class {\n  constructor(length = 64) {\n    if (length <= 0) {\n      throw new Error(\"Length needs to be greater than 0\");\n    }\n    this.buffer = new ArrayBuffer(length);\n    this.offset = 0;\n  }\n  ensureBufferWillHandleSize(bytes) {\n    while (this.buffer.byteLength < this.offset + bytes) {\n      const newBuffer = new ArrayBuffer(this.buffer.byteLength * 2);\n      new Uint8Array(newBuffer).set(new Uint8Array(this.buffer));\n      this.buffer = newBuffer;\n    }\n  }\n  appendToBuffer(values) {\n    this.ensureBufferWillHandleSize(values.length);\n    new Uint8Array(this.buffer, this.offset).set(values);\n    this.offset += values.length;\n  }\n  serializeWithFunction(fn, bytesLength, value) {\n    this.ensureBufferWillHandleSize(bytesLength);\n    const dv = new DataView(this.buffer, this.offset);\n    fn.apply(dv, [0, value, true]);\n    this.offset += bytesLength;\n  }\n  serializeStr(value) {\n    const textEncoder = new TextEncoder();\n    this.serializeBytes(textEncoder.encode(value));\n  }\n  serializeBytes(value) {\n    this.serializeU32AsUleb128(value.length);\n    this.appendToBuffer(value);\n  }\n  serializeFixedBytes(value) {\n    this.appendToBuffer(value);\n  }\n  serializeBool(value) {\n    ensureBoolean(value);\n    const byteValue = value ? 1 : 0;\n    this.appendToBuffer(new Uint8Array([byteValue]));\n  }\n  serializeU8(value) {\n    this.appendToBuffer(new Uint8Array([value]));\n  }\n  serializeU16(value) {\n    this.serializeWithFunction(DataView.prototype.setUint16, 2, value);\n  }\n  serializeU32(value) {\n    this.serializeWithFunction(DataView.prototype.setUint32, 4, value);\n  }\n  serializeU64(value) {\n    const low = BigInt(value) & BigInt(MAX_U32_NUMBER);\n    const high = BigInt(value) >> BigInt(32);\n    this.serializeU32(Number(low));\n    this.serializeU32(Number(high));\n  }\n  serializeU128(value) {\n    const low = BigInt(value) & MAX_U64_BIG_INT;\n    const high = BigInt(value) >> BigInt(64);\n    this.serializeU64(low);\n    this.serializeU64(high);\n  }\n  serializeU256(value) {\n    const low = BigInt(value) & MAX_U128_BIG_INT;\n    const high = BigInt(value) >> BigInt(128);\n    this.serializeU128(low);\n    this.serializeU128(high);\n  }\n  serializeU32AsUleb128(val) {\n    let value = val;\n    const valueArray = [];\n    while (value >>> 7 !== 0) {\n      valueArray.push(value & 127 | 128);\n      value >>>= 7;\n    }\n    valueArray.push(value);\n    this.appendToBuffer(new Uint8Array(valueArray));\n  }\n  toUint8Array() {\n    return new Uint8Array(this.buffer).slice(0, this.offset);\n  }\n  serialize(value) {\n    value.serialize(this);\n  }\n  serializeVector(values) {\n    this.serializeU32AsUleb128(values.length);\n    values.forEach(item => {\n      item.serialize(this);\n    });\n  }\n};\n__decorateClass([checkNumberRange(0, MAX_U8_NUMBER)], Serializer.prototype, \"serializeU8\", 1);\n__decorateClass([checkNumberRange(0, MAX_U16_NUMBER)], Serializer.prototype, \"serializeU16\", 1);\n__decorateClass([checkNumberRange(0, MAX_U32_NUMBER)], Serializer.prototype, \"serializeU32\", 1);\n__decorateClass([checkNumberRange(BigInt(0), MAX_U64_BIG_INT)], Serializer.prototype, \"serializeU64\", 1);\n__decorateClass([checkNumberRange(BigInt(0), MAX_U128_BIG_INT)], Serializer.prototype, \"serializeU128\", 1);\n__decorateClass([checkNumberRange(BigInt(0), MAX_U256_BIG_INT)], Serializer.prototype, \"serializeU256\", 1);\n__decorateClass([checkNumberRange(0, MAX_U32_NUMBER)], Serializer.prototype, \"serializeU32AsUleb128\", 1);\nfunction ensureBoolean(value) {\n  if (typeof value !== \"boolean\") {\n    throw new Error(`${value} is not a boolean value`);\n  }\n}\nvar outOfRangeErrorMessage = (value, min, max) => `${value} is out of range: [${min}, ${max}]`;\nfunction validateNumberInRange(value, minValue, maxValue) {\n  const valueBigInt = BigInt(value);\n  if (valueBigInt > BigInt(maxValue) || valueBigInt < BigInt(minValue)) {\n    throw new Error(outOfRangeErrorMessage(value, minValue, maxValue));\n  }\n}\nfunction checkNumberRange(minValue, maxValue) {\n  return (target, propertyKey, descriptor) => {\n    const childFunction = descriptor.value;\n    descriptor.value = function deco(value) {\n      validateNumberInRange(value, minValue, maxValue);\n      return childFunction.apply(this, [value]);\n    };\n    return descriptor;\n  };\n}\n\n// src/core/accountAddress.ts\nvar AddressInvalidReason = /* @__PURE__ */(AddressInvalidReason2 => {\n  AddressInvalidReason2[\"INCORRECT_NUMBER_OF_BYTES\"] = \"incorrect_number_of_bytes\";\n  AddressInvalidReason2[\"INVALID_HEX_CHARS\"] = \"invalid_hex_chars\";\n  AddressInvalidReason2[\"TOO_SHORT\"] = \"too_short\";\n  AddressInvalidReason2[\"TOO_LONG\"] = \"too_long\";\n  AddressInvalidReason2[\"LEADING_ZERO_X_REQUIRED\"] = \"leading_zero_x_required\";\n  AddressInvalidReason2[\"LONG_FORM_REQUIRED_UNLESS_SPECIAL\"] = \"long_form_required_unless_special\";\n  AddressInvalidReason2[\"INVALID_PADDING_ZEROES\"] = \"INVALID_PADDING_ZEROES\";\n  return AddressInvalidReason2;\n})(AddressInvalidReason || {});\nvar _AccountAddress = class extends Serializable {\n  constructor(args) {\n    super();\n    if (args.data.length !== _AccountAddress.LENGTH) {\n      throw new ParsingError(\"AccountAddress data should be exactly 32 bytes long\", \"incorrect_number_of_bytes\" /* INCORRECT_NUMBER_OF_BYTES */);\n    }\n    this.data = args.data;\n  }\n  isSpecial() {\n    return this.data.slice(0, this.data.length - 1).every(byte => byte === 0) && this.data[this.data.length - 1] < 16;\n  }\n  toString() {\n    return `0x${this.toStringWithoutPrefix()}`;\n  }\n  toStringWithoutPrefix() {\n    let hex = bytesToHex2(this.data);\n    if (this.isSpecial()) {\n      hex = hex[hex.length - 1];\n    }\n    return hex;\n  }\n  toStringLong() {\n    return `0x${this.toStringLongWithoutPrefix()}`;\n  }\n  toStringLongWithoutPrefix() {\n    return bytesToHex2(this.data);\n  }\n  toUint8Array() {\n    return this.data;\n  }\n  serialize(serializer) {\n    serializer.serializeFixedBytes(this.data);\n  }\n  serializeForEntryFunction(serializer) {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n  serializeForScriptFunction(serializer) {\n    serializer.serializeU32AsUleb128(3 /* Address */);\n    serializer.serialize(this);\n  }\n  static deserialize(deserializer) {\n    const bytes = deserializer.deserializeFixedBytes(_AccountAddress.LENGTH);\n    return new _AccountAddress({\n      data: bytes\n    });\n  }\n  static fromString(input) {\n    if (!input.startsWith(\"0x\")) {\n      throw new ParsingError(\"Hex string must start with a leading 0x.\", \"leading_zero_x_required\" /* LEADING_ZERO_X_REQUIRED */);\n    }\n    const address = _AccountAddress.fromStringRelaxed(input);\n    if (input.length !== _AccountAddress.LONG_STRING_LENGTH + 2) {\n      if (!address.isSpecial()) {\n        throw new ParsingError(`The given hex string ${address} is not a special address, it must be represented as 0x + 64 chars.`, \"long_form_required_unless_special\" /* LONG_FORM_REQUIRED_UNLESS_SPECIAL */);\n      } else if (input.length !== 3) {\n        throw new ParsingError(`The given hex string ${input} is a special address not in LONG form, it must be 0x0 to 0xf without padding zeroes.`, \"INVALID_PADDING_ZEROES\" /* INVALID_PADDING_ZEROES */);\n      }\n    }\n    return address;\n  }\n  static fromStringRelaxed(input) {\n    let parsedInput = input;\n    if (input.startsWith(\"0x\")) {\n      parsedInput = input.slice(2);\n    }\n    if (parsedInput.length === 0) {\n      throw new ParsingError(\"Hex string is too short, must be 1 to 64 chars long, excluding the leading 0x.\", \"too_short\" /* TOO_SHORT */);\n    }\n    if (parsedInput.length > 64) {\n      throw new ParsingError(\"Hex string is too long, must be 1 to 64 chars long, excluding the leading 0x.\", \"too_long\" /* TOO_LONG */);\n    }\n    let addressBytes;\n    try {\n      addressBytes = hexToBytes2(parsedInput.padStart(64, \"0\"));\n    } catch (e) {\n      const error = e;\n      throw new ParsingError(`Hex characters are invalid: ${error.message}`, \"invalid_hex_chars\" /* INVALID_HEX_CHARS */);\n    }\n    return new _AccountAddress({\n      data: addressBytes\n    });\n  }\n  static fromHexInput(input) {\n    if (input instanceof Uint8Array) {\n      return new _AccountAddress({\n        data: input\n      });\n    }\n    return _AccountAddress.fromString(input);\n  }\n  static fromHexInputRelaxed(hexInput) {\n    if (hexInput instanceof Uint8Array) {\n      return new _AccountAddress({\n        data: hexInput\n      });\n    }\n    return _AccountAddress.fromStringRelaxed(hexInput);\n  }\n  static isValid(args) {\n    try {\n      if (args.relaxed) {\n        _AccountAddress.fromStringRelaxed(args.input);\n      } else {\n        _AccountAddress.fromString(args.input);\n      }\n      return {\n        valid: true\n      };\n    } catch (e) {\n      const error = e;\n      return {\n        valid: false,\n        invalidReason: error.invalidReason,\n        invalidReasonMessage: error.message\n      };\n    }\n  }\n  equals(other) {\n    if (this.data.length !== other.data.length) return false;\n    return this.data.every((value, index) => value === other.data[index]);\n  }\n};\nvar AccountAddress = _AccountAddress;\nAccountAddress.LENGTH = 32;\nAccountAddress.LONG_STRING_LENGTH = 64;\nAccountAddress.ZERO = _AccountAddress.fromString(\"0x0\");\nAccountAddress.ONE = _AccountAddress.fromString(\"0x1\");\nAccountAddress.TWO = _AccountAddress.fromString(\"0x2\");\nAccountAddress.THREE = _AccountAddress.fromString(\"0x3\");\nAccountAddress.FOUR = _AccountAddress.fromString(\"0x4\");\n\n// src/core/authenticationKey.ts\nimport { sha3_256 as sha3Hash } from \"@noble/hashes/sha3\";\n\n// src/core/crypto/ed25519.ts\nimport nacl from \"tweetnacl\";\n\n// src/bcs/deserializer.ts\nvar Deserializer = class {\n  constructor(data) {\n    this.buffer = new ArrayBuffer(data.length);\n    new Uint8Array(this.buffer).set(data, 0);\n    this.offset = 0;\n  }\n  read(length) {\n    if (this.offset + length > this.buffer.byteLength) {\n      throw new Error(\"Reached to the end of buffer\");\n    }\n    const bytes = this.buffer.slice(this.offset, this.offset + length);\n    this.offset += length;\n    return bytes;\n  }\n  deserializeStr() {\n    const value = this.deserializeBytes();\n    const textDecoder = new TextDecoder();\n    return textDecoder.decode(value);\n  }\n  deserializeBytes() {\n    const len = this.deserializeUleb128AsU32();\n    return new Uint8Array(this.read(len));\n  }\n  deserializeFixedBytes(len) {\n    return new Uint8Array(this.read(len));\n  }\n  deserializeBool() {\n    const bool = new Uint8Array(this.read(1))[0];\n    if (bool !== 1 && bool !== 0) {\n      throw new Error(\"Invalid boolean value\");\n    }\n    return bool === 1;\n  }\n  deserializeU8() {\n    return new DataView(this.read(1)).getUint8(0);\n  }\n  deserializeU16() {\n    return new DataView(this.read(2)).getUint16(0, true);\n  }\n  deserializeU32() {\n    return new DataView(this.read(4)).getUint32(0, true);\n  }\n  deserializeU64() {\n    const low = this.deserializeU32();\n    const high = this.deserializeU32();\n    return BigInt(BigInt(high) << BigInt(32) | BigInt(low));\n  }\n  deserializeU128() {\n    const low = this.deserializeU64();\n    const high = this.deserializeU64();\n    return BigInt(high << BigInt(64) | low);\n  }\n  deserializeU256() {\n    const low = this.deserializeU128();\n    const high = this.deserializeU128();\n    return BigInt(high << BigInt(128) | low);\n  }\n  deserializeUleb128AsU32() {\n    let value = BigInt(0);\n    let shift = 0;\n    while (value < MAX_U32_NUMBER) {\n      const byte = this.deserializeU8();\n      value |= BigInt(byte & 127) << BigInt(shift);\n      if ((byte & 128) === 0) {\n        break;\n      }\n      shift += 7;\n    }\n    if (value > MAX_U32_NUMBER) {\n      throw new Error(\"Overflow while parsing uleb128-encoded uint32 value\");\n    }\n    return Number(value);\n  }\n  deserialize(cls) {\n    return cls.deserialize(this);\n  }\n  deserializeVector(cls) {\n    const length = this.deserializeUleb128AsU32();\n    const vector = new Array();\n    for (let i = 0; i < length; i += 1) {\n      vector.push(this.deserialize(cls));\n    }\n    return vector;\n  }\n};\n\n// src/bcs/serializable/fixedBytes.ts\nvar FixedBytes = class extends Serializable {\n  constructor(value) {\n    super();\n    this.value = Hex.fromHexInput(value).toUint8Array();\n  }\n  serialize(serializer) {\n    serializer.serializeFixedBytes(this.value);\n  }\n  serializeForEntryFunction(serializer) {\n    serializer.serialize(this);\n  }\n  serializeForScriptFunction(serializer) {\n    serializer.serialize(this);\n  }\n  static deserialize(deserializer, length) {\n    const bytes = deserializer.deserializeFixedBytes(length);\n    return new FixedBytes(bytes);\n  }\n};\n\n// src/bcs/serializable/entryFunctionBytes.ts\nvar EntryFunctionBytes = class extends Serializable {\n  constructor(value) {\n    super();\n    this.value = new FixedBytes(value);\n  }\n  serialize(serializer) {\n    serializer.serialize(this.value);\n  }\n  serializeForEntryFunction(serializer) {\n    serializer.serializeU32AsUleb128(this.value.value.length);\n    serializer.serialize(this);\n  }\n  static deserialize(deserializer, length) {\n    const fixedBytes = FixedBytes.deserialize(deserializer, length);\n    return new EntryFunctionBytes(fixedBytes.value);\n  }\n};\n\n// src/bcs/serializable/movePrimitives.ts\nvar Bool = class extends Serializable {\n  constructor(value) {\n    super();\n    ensureBoolean(value);\n    this.value = value;\n  }\n  serialize(serializer) {\n    serializer.serializeBool(this.value);\n  }\n  serializeForEntryFunction(serializer) {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n  serializeForScriptFunction(serializer) {\n    serializer.serializeU32AsUleb128(5 /* Bool */);\n    serializer.serialize(this);\n  }\n  static deserialize(deserializer) {\n    return new Bool(deserializer.deserializeBool());\n  }\n};\nvar U8 = class extends Serializable {\n  constructor(value) {\n    super();\n    validateNumberInRange(value, 0, MAX_U8_NUMBER);\n    this.value = value;\n  }\n  serialize(serializer) {\n    serializer.serializeU8(this.value);\n  }\n  serializeForEntryFunction(serializer) {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n  serializeForScriptFunction(serializer) {\n    serializer.serializeU32AsUleb128(0 /* U8 */);\n    serializer.serialize(this);\n  }\n  static deserialize(deserializer) {\n    return new U8(deserializer.deserializeU8());\n  }\n};\nvar U16 = class extends Serializable {\n  constructor(value) {\n    super();\n    validateNumberInRange(value, 0, MAX_U16_NUMBER);\n    this.value = value;\n  }\n  serialize(serializer) {\n    serializer.serializeU16(this.value);\n  }\n  serializeForEntryFunction(serializer) {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n  serializeForScriptFunction(serializer) {\n    serializer.serializeU32AsUleb128(6 /* U16 */);\n    serializer.serialize(this);\n  }\n  static deserialize(deserializer) {\n    return new U16(deserializer.deserializeU16());\n  }\n};\nvar U32 = class extends Serializable {\n  constructor(value) {\n    super();\n    validateNumberInRange(value, 0, MAX_U32_NUMBER);\n    this.value = value;\n  }\n  serialize(serializer) {\n    serializer.serializeU32(this.value);\n  }\n  serializeForEntryFunction(serializer) {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n  serializeForScriptFunction(serializer) {\n    serializer.serializeU32AsUleb128(7 /* U32 */);\n    serializer.serialize(this);\n  }\n  static deserialize(deserializer) {\n    return new U32(deserializer.deserializeU32());\n  }\n};\nvar U64 = class extends Serializable {\n  constructor(value) {\n    super();\n    validateNumberInRange(value, BigInt(0), MAX_U64_BIG_INT);\n    this.value = BigInt(value);\n  }\n  serialize(serializer) {\n    serializer.serializeU64(this.value);\n  }\n  serializeForEntryFunction(serializer) {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n  serializeForScriptFunction(serializer) {\n    serializer.serializeU32AsUleb128(1 /* U64 */);\n    serializer.serialize(this);\n  }\n  static deserialize(deserializer) {\n    return new U64(deserializer.deserializeU64());\n  }\n};\nvar U128 = class extends Serializable {\n  constructor(value) {\n    super();\n    validateNumberInRange(value, BigInt(0), MAX_U128_BIG_INT);\n    this.value = BigInt(value);\n  }\n  serialize(serializer) {\n    serializer.serializeU128(this.value);\n  }\n  serializeForEntryFunction(serializer) {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n  serializeForScriptFunction(serializer) {\n    serializer.serializeU32AsUleb128(2 /* U128 */);\n    serializer.serialize(this);\n  }\n  static deserialize(deserializer) {\n    return new U128(deserializer.deserializeU128());\n  }\n};\nvar U256 = class extends Serializable {\n  constructor(value) {\n    super();\n    validateNumberInRange(value, BigInt(0), MAX_U256_BIG_INT);\n    this.value = BigInt(value);\n  }\n  serialize(serializer) {\n    serializer.serializeU256(this.value);\n  }\n  serializeForEntryFunction(serializer) {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n  serializeForScriptFunction(serializer) {\n    serializer.serializeU32AsUleb128(8 /* U256 */);\n    serializer.serialize(this);\n  }\n  static deserialize(deserializer) {\n    return new U256(deserializer.deserializeU256());\n  }\n};\n\n// src/bcs/serializable/moveStructs.ts\nvar MoveVector = class extends Serializable {\n  constructor(values) {\n    super();\n    this.values = values;\n  }\n  serializeForEntryFunction(serializer) {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n  serializeForScriptFunction(serializer) {\n    const isU8 = this.values[0] instanceof U8;\n    if (!isU8) {\n      throw new Error(\"Script function arguments only accept u8 vectors\");\n    }\n    serializer.serializeU32AsUleb128(4 /* U8Vector */);\n    serializer.serialize(this);\n  }\n  static U8(values) {\n    let numbers;\n    if (Array.isArray(values) && typeof values[0] === \"number\") {\n      numbers = values;\n    } else if (typeof values === \"string\") {\n      const hex = Hex.fromHexInput(values);\n      numbers = Array.from(hex.toUint8Array());\n    } else if (values instanceof Uint8Array) {\n      numbers = Array.from(values);\n    } else {\n      throw new Error(\"Invalid input type\");\n    }\n    return new MoveVector(numbers.map(v => new U8(v)));\n  }\n  static U16(values) {\n    return new MoveVector(values.map(v => new U16(v)));\n  }\n  static U32(values) {\n    return new MoveVector(values.map(v => new U32(v)));\n  }\n  static U64(values) {\n    return new MoveVector(values.map(v => new U64(v)));\n  }\n  static U128(values) {\n    return new MoveVector(values.map(v => new U128(v)));\n  }\n  static U256(values) {\n    return new MoveVector(values.map(v => new U256(v)));\n  }\n  static Bool(values) {\n    return new MoveVector(values.map(v => new Bool(v)));\n  }\n  static MoveString(values) {\n    return new MoveVector(values.map(v => new MoveString(v)));\n  }\n  serialize(serializer) {\n    serializer.serializeVector(this.values);\n  }\n  static deserialize(deserializer, cls) {\n    const length = deserializer.deserializeUleb128AsU32();\n    const values = new Array();\n    for (let i = 0; i < length; i += 1) {\n      values.push(cls.deserialize(deserializer));\n    }\n    return new MoveVector(values);\n  }\n};\nvar MoveString = class extends Serializable {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  serialize(serializer) {\n    serializer.serializeStr(this.value);\n  }\n  serializeForEntryFunction(serializer) {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n  serializeForScriptFunction(serializer) {\n    const vectorU8 = MoveVector.U8(this.bcsToBytes());\n    vectorU8.serializeForScriptFunction(serializer);\n  }\n  static deserialize(deserializer) {\n    return new MoveString(deserializer.deserializeStr());\n  }\n};\nvar MoveOption = class extends Serializable {\n  constructor(value) {\n    super();\n    if (typeof value !== \"undefined\" && value !== null) {\n      this.vec = new MoveVector([value]);\n    } else {\n      this.vec = new MoveVector([]);\n    }\n    [this.value] = this.vec.values;\n  }\n  serializeForEntryFunction(serializer) {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n  unwrap() {\n    if (!this.isSome()) {\n      throw new Error(\"Called unwrap on a MoveOption with no value\");\n    } else {\n      return this.vec.values[0];\n    }\n  }\n  isSome() {\n    return this.vec.values.length === 1;\n  }\n  serialize(serializer) {\n    this.vec.serialize(serializer);\n  }\n  static U8(value) {\n    return new MoveOption(value !== null && value !== void 0 ? new U8(value) : void 0);\n  }\n  static U16(value) {\n    return new MoveOption(value !== null && value !== void 0 ? new U16(value) : void 0);\n  }\n  static U32(value) {\n    return new MoveOption(value !== null && value !== void 0 ? new U32(value) : void 0);\n  }\n  static U64(value) {\n    return new MoveOption(value !== null && value !== void 0 ? new U64(value) : void 0);\n  }\n  static U128(value) {\n    return new MoveOption(value !== null && value !== void 0 ? new U128(value) : void 0);\n  }\n  static U256(value) {\n    return new MoveOption(value !== null && value !== void 0 ? new U256(value) : void 0);\n  }\n  static Bool(value) {\n    return new MoveOption(value !== null && value !== void 0 ? new Bool(value) : void 0);\n  }\n  static MoveString(value) {\n    return new MoveOption(value !== null && value !== void 0 ? new MoveString(value) : void 0);\n  }\n  static deserialize(deserializer, cls) {\n    const vector = MoveVector.deserialize(deserializer, cls);\n    return new MoveOption(vector.values[0]);\n  }\n};\n\n// src/core/crypto/asymmetricCrypto.ts\nvar PublicKey = class extends Serializable {};\nvar PrivateKey = class extends Serializable {};\nvar Signature = class extends Serializable {};\n\n// src/core/crypto/ed25519.ts\nvar _Ed25519PublicKey = class extends PublicKey {\n  constructor(hexInput) {\n    super();\n    const hex = Hex.fromHexInput(hexInput);\n    if (hex.toUint8Array().length !== _Ed25519PublicKey.LENGTH) {\n      throw new Error(`PublicKey length should be ${_Ed25519PublicKey.LENGTH}`);\n    }\n    this.key = hex;\n  }\n  toUint8Array() {\n    return this.key.toUint8Array();\n  }\n  toString() {\n    return this.key.toString();\n  }\n  verifySignature(args) {\n    const {\n      message,\n      signature\n    } = args;\n    const rawMessage = Hex.fromHexInput(message).toUint8Array();\n    const rawSignature = Hex.fromHexInput(signature.toUint8Array()).toUint8Array();\n    return nacl.sign.detached.verify(rawMessage, rawSignature, this.key.toUint8Array());\n  }\n  serialize(serializer) {\n    serializer.serializeBytes(this.key.toUint8Array());\n  }\n  static deserialize(deserializer) {\n    const bytes = deserializer.deserializeBytes();\n    return new _Ed25519PublicKey(bytes);\n  }\n  static load(deserializer) {\n    const bytes = deserializer.deserializeBytes();\n    return new _Ed25519PublicKey(bytes);\n  }\n};\nvar Ed25519PublicKey = _Ed25519PublicKey;\nEd25519PublicKey.LENGTH = 32;\nvar _Ed25519PrivateKey = class extends PrivateKey {\n  constructor(hexInput) {\n    super();\n    const privateKeyHex = Hex.fromHexInput(hexInput);\n    if (privateKeyHex.toUint8Array().length !== _Ed25519PrivateKey.LENGTH) {\n      throw new Error(`PrivateKey length should be ${_Ed25519PrivateKey.LENGTH}`);\n    }\n    this.signingKeyPair = nacl.sign.keyPair.fromSeed(privateKeyHex.toUint8Array().slice(0, _Ed25519PrivateKey.LENGTH));\n  }\n  toUint8Array() {\n    return this.signingKeyPair.secretKey.slice(0, _Ed25519PrivateKey.LENGTH);\n  }\n  toString() {\n    return Hex.fromHexInput(this.toUint8Array()).toString();\n  }\n  sign(message) {\n    const hex = Hex.fromHexInput(message);\n    const signature = nacl.sign.detached(hex.toUint8Array(), this.signingKeyPair.secretKey);\n    return new Ed25519Signature(signature);\n  }\n  serialize(serializer) {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n  static deserialize(deserializer) {\n    const bytes = deserializer.deserializeBytes();\n    return new _Ed25519PrivateKey(bytes);\n  }\n  static generate() {\n    const keyPair = nacl.sign.keyPair();\n    return new _Ed25519PrivateKey(keyPair.secretKey.slice(0, _Ed25519PrivateKey.LENGTH));\n  }\n  publicKey() {\n    const bytes = this.signingKeyPair.publicKey;\n    return new Ed25519PublicKey(bytes);\n  }\n};\nvar Ed25519PrivateKey = _Ed25519PrivateKey;\nEd25519PrivateKey.LENGTH = 32;\nvar _Ed25519Signature = class extends Signature {\n  constructor(hexInput) {\n    super();\n    const hex = Hex.fromHexInput(hexInput);\n    if (hex.toUint8Array().length !== _Ed25519Signature.LENGTH) {\n      throw new Error(`Signature length should be ${_Ed25519Signature.LENGTH}`);\n    }\n    this.data = hex;\n  }\n  toUint8Array() {\n    return this.data.toUint8Array();\n  }\n  toString() {\n    return this.data.toString();\n  }\n  serialize(serializer) {\n    serializer.serializeBytes(this.data.toUint8Array());\n  }\n  static deserialize(deserializer) {\n    const bytes = deserializer.deserializeBytes();\n    return new _Ed25519Signature(bytes);\n  }\n  static load(deserializer) {\n    const bytes = deserializer.deserializeBytes();\n    return new _Ed25519Signature(bytes);\n  }\n};\nvar Ed25519Signature = _Ed25519Signature;\nEd25519Signature.LENGTH = 64;\n\n// src/core/crypto/multiEd25519.ts\nvar _MultiEd25519PublicKey = class extends PublicKey {\n  constructor(args) {\n    super();\n    const {\n      publicKeys,\n      threshold\n    } = args;\n    if (publicKeys.length > _MultiEd25519PublicKey.MAX_KEYS || publicKeys.length < _MultiEd25519PublicKey.MIN_KEYS) {\n      throw new Error(`Must have between ${_MultiEd25519PublicKey.MIN_KEYS} and ${_MultiEd25519PublicKey.MAX_KEYS} public keys, inclusive`);\n    }\n    if (threshold < _MultiEd25519PublicKey.MIN_THRESHOLD || threshold > publicKeys.length) {\n      throw new Error(`Threshold must be between ${_MultiEd25519PublicKey.MIN_THRESHOLD} and ${publicKeys.length}, inclusive`);\n    }\n    this.publicKeys = publicKeys;\n    this.threshold = threshold;\n  }\n  toUint8Array() {\n    const bytes = new Uint8Array(this.publicKeys.length * Ed25519PublicKey.LENGTH + 1);\n    this.publicKeys.forEach((k, i) => {\n      bytes.set(k.toUint8Array(), i * Ed25519PublicKey.LENGTH);\n    });\n    bytes[this.publicKeys.length * Ed25519PublicKey.LENGTH] = this.threshold;\n    return bytes;\n  }\n  toString() {\n    return Hex.fromHexInput(this.toUint8Array()).toString();\n  }\n  verifySignature(args) {\n    throw new Error(\"TODO - Method not implemented.\");\n  }\n  serialize(serializer) {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n  static deserialize(deserializer) {\n    const bytes = deserializer.deserializeBytes();\n    const threshold = bytes[bytes.length - 1];\n    const keys = [];\n    for (let i = 0; i < bytes.length - 1; i += Ed25519PublicKey.LENGTH) {\n      const begin = i;\n      keys.push(new Ed25519PublicKey(bytes.subarray(begin, begin + Ed25519PublicKey.LENGTH)));\n    }\n    return new _MultiEd25519PublicKey({\n      publicKeys: keys,\n      threshold\n    });\n  }\n};\nvar MultiEd25519PublicKey = _MultiEd25519PublicKey;\nMultiEd25519PublicKey.MAX_KEYS = 32;\nMultiEd25519PublicKey.MIN_KEYS = 2;\nMultiEd25519PublicKey.MIN_THRESHOLD = 1;\nvar _MultiEd25519Signature = class extends Signature {\n  constructor(args) {\n    super();\n    const {\n      signatures,\n      bitmap\n    } = args;\n    if (bitmap.length !== _MultiEd25519Signature.BITMAP_LEN) {\n      throw new Error(`\"bitmap\" length should be ${_MultiEd25519Signature.BITMAP_LEN}`);\n    }\n    if (signatures.length > _MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED) {\n      throw new Error(`The number of signatures cannot be greater than ${_MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED}`);\n    }\n    this.signatures = signatures;\n    this.bitmap = bitmap;\n  }\n  toUint8Array() {\n    const bytes = new Uint8Array(this.signatures.length * Ed25519Signature.LENGTH + _MultiEd25519Signature.BITMAP_LEN);\n    this.signatures.forEach((k, i) => {\n      bytes.set(k.toUint8Array(), i * Ed25519Signature.LENGTH);\n    });\n    bytes.set(this.bitmap, this.signatures.length * Ed25519Signature.LENGTH);\n    return bytes;\n  }\n  toString() {\n    return Hex.fromHexInput(this.toUint8Array()).toString();\n  }\n  static createBitmap(args) {\n    const {\n      bits\n    } = args;\n    const firstBitInByte = 128;\n    const bitmap = new Uint8Array([0, 0, 0, 0]);\n    const dupCheckSet = /* @__PURE__ */new Set();\n    bits.forEach(bit => {\n      if (bit >= _MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED) {\n        throw new Error(`Cannot have a signature larger than ${_MultiEd25519Signature.MAX_SIGNATURES_SUPPORTED - 1}.`);\n      }\n      if (dupCheckSet.has(bit)) {\n        throw new Error(\"Duplicate bits detected.\");\n      }\n      dupCheckSet.add(bit);\n      const byteOffset = Math.floor(bit / 8);\n      let byte = bitmap[byteOffset];\n      byte |= firstBitInByte >> bit % 8;\n      bitmap[byteOffset] = byte;\n    });\n    return bitmap;\n  }\n  serialize(serializer) {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n  static deserialize(deserializer) {\n    const bytes = deserializer.deserializeBytes();\n    const bitmap = bytes.subarray(bytes.length - 4);\n    const signatures = [];\n    for (let i = 0; i < bytes.length - bitmap.length; i += Ed25519Signature.LENGTH) {\n      const begin = i;\n      signatures.push(new Ed25519Signature(bytes.subarray(begin, begin + Ed25519Signature.LENGTH)));\n    }\n    return new _MultiEd25519Signature({\n      signatures,\n      bitmap\n    });\n  }\n};\nvar MultiEd25519Signature = _MultiEd25519Signature;\nMultiEd25519Signature.MAX_SIGNATURES_SUPPORTED = 32;\nMultiEd25519Signature.BITMAP_LEN = 4;\n\n// src/core/crypto/secp256k1.ts\nimport { sha3_256 } from \"@noble/hashes/sha3\";\nimport { secp256k1 } from \"@noble/curves/secp256k1\";\nvar _Secp256k1PublicKey = class extends PublicKey {\n  constructor(hexInput) {\n    super();\n    const hex = Hex.fromHexInput(hexInput);\n    if (hex.toUint8Array().length !== _Secp256k1PublicKey.LENGTH) {\n      throw new Error(`PublicKey length should be ${_Secp256k1PublicKey.LENGTH}`);\n    }\n    this.key = hex;\n  }\n  toUint8Array() {\n    return this.key.toUint8Array();\n  }\n  toString() {\n    return this.key.toString();\n  }\n  verifySignature(args) {\n    const {\n      message,\n      signature\n    } = args;\n    const msgHex = Hex.fromHexInput(message).toUint8Array();\n    const sha3Message = sha3_256(msgHex);\n    const rawSignature = signature.toUint8Array();\n    return secp256k1.verify(rawSignature, sha3Message, this.toUint8Array());\n  }\n  serialize(serializer) {\n    serializer.serializeBytes(this.key.toUint8Array());\n  }\n  static deserialize(deserializer) {\n    const bytes = deserializer.deserializeBytes();\n    return new _Secp256k1PublicKey(bytes);\n  }\n  static load(deserializer) {\n    const bytes = deserializer.deserializeBytes();\n    return new _Secp256k1PublicKey(bytes);\n  }\n};\nvar Secp256k1PublicKey = _Secp256k1PublicKey;\nSecp256k1PublicKey.LENGTH = 65;\nvar _Secp256k1PrivateKey = class extends PrivateKey {\n  constructor(hexInput) {\n    super();\n    const privateKeyHex = Hex.fromHexInput(hexInput);\n    if (privateKeyHex.toUint8Array().length !== _Secp256k1PrivateKey.LENGTH) {\n      throw new Error(`PrivateKey length should be ${_Secp256k1PrivateKey.LENGTH}`);\n    }\n    this.key = privateKeyHex;\n  }\n  toUint8Array() {\n    return this.key.toUint8Array();\n  }\n  toString() {\n    return this.key.toString();\n  }\n  sign(message) {\n    const msgHex = Hex.fromHexInput(message);\n    const sha3Message = sha3_256(msgHex.toUint8Array());\n    const signature = secp256k1.sign(sha3Message, this.key.toUint8Array());\n    return new Secp256k1Signature(signature.toCompactRawBytes());\n  }\n  serialize(serializer) {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n  static deserialize(deserializer) {\n    const bytes = deserializer.deserializeBytes();\n    return new _Secp256k1PrivateKey(bytes);\n  }\n  static generate() {\n    const hexInput = secp256k1.utils.randomPrivateKey();\n    return new _Secp256k1PrivateKey(hexInput);\n  }\n  publicKey() {\n    const bytes = secp256k1.getPublicKey(this.key.toUint8Array(), false);\n    return new Secp256k1PublicKey(bytes);\n  }\n};\nvar Secp256k1PrivateKey = _Secp256k1PrivateKey;\nSecp256k1PrivateKey.LENGTH = 32;\nvar _Secp256k1Signature = class extends Signature {\n  constructor(hexInput) {\n    super();\n    const hex = Hex.fromHexInput(hexInput);\n    if (hex.toUint8Array().length !== _Secp256k1Signature.LENGTH) {\n      throw new Error(`Signature length should be ${_Secp256k1Signature.LENGTH}, recieved ${hex.toUint8Array().length}`);\n    }\n    this.data = hex;\n  }\n  toUint8Array() {\n    return this.data.toUint8Array();\n  }\n  toString() {\n    return this.data.toString();\n  }\n  serialize(serializer) {\n    serializer.serializeBytes(this.data.toUint8Array());\n  }\n  static deserialize(deserializer) {\n    const hex = deserializer.deserializeBytes();\n    return new _Secp256k1Signature(hex);\n  }\n  static load(deserializer) {\n    const bytes = deserializer.deserializeBytes();\n    return new _Secp256k1Signature(bytes);\n  }\n};\nvar Secp256k1Signature = _Secp256k1Signature;\nSecp256k1Signature.LENGTH = 64;\n\n// src/core/crypto/anyPublicKey.ts\nvar AnyPublicKey = class extends PublicKey {\n  constructor(publicKey) {\n    super();\n    this.publicKey = publicKey;\n  }\n  toUint8Array() {\n    return this.publicKey.toUint8Array();\n  }\n  toString() {\n    return this.publicKey.toString();\n  }\n  verifySignature(args) {\n    const {\n      message,\n      signature\n    } = args;\n    return this.publicKey.verifySignature({\n      message,\n      signature\n    });\n  }\n  serialize(serializer) {\n    if (this.publicKey instanceof Ed25519PublicKey) {\n      serializer.serializeU32AsUleb128(0 /* Ed25519 */);\n      this.publicKey.serialize(serializer);\n    } else if (this.publicKey instanceof Secp256k1PublicKey) {\n      serializer.serializeU32AsUleb128(1 /* Secp256k1 */);\n      this.publicKey.serialize(serializer);\n    } else {\n      throw new Error(\"Unknown public key type\");\n    }\n  }\n  static deserialize(deserializer) {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case 0 /* Ed25519 */:\n        return new AnyPublicKey(Ed25519PublicKey.load(deserializer));\n      case 1 /* Secp256k1 */:\n        return new AnyPublicKey(Secp256k1PublicKey.load(deserializer));\n      default:\n        throw new Error(`Unknown variant index for AnyPublicKey: ${index}`);\n    }\n  }\n};\n\n// src/core/crypto/multiKey.ts\nvar MultiKey = class extends PublicKey {\n  constructor(args) {\n    super();\n    const {\n      publicKeys,\n      signaturesRequired\n    } = args;\n    if (signaturesRequired < 1) {\n      throw new Error(\"The number of required signatures needs to be greater then 0\");\n    }\n    if (publicKeys.length < signaturesRequired) {\n      throw new Error(`Provided ${publicKeys.length} public keys is smaller than the ${signaturesRequired} required signatures`);\n    }\n    const keys = [];\n    publicKeys.forEach(publicKey => {\n      if (publicKey instanceof AnyPublicKey) {\n        keys.push(publicKey);\n      } else {\n        keys.push(new AnyPublicKey(publicKey));\n      }\n    });\n    this.publicKeys = keys;\n    this.signaturesRequired = signaturesRequired;\n  }\n  toUint8Array() {\n    return this.bcsToBytes();\n  }\n  createBitmap(args) {\n    const {\n      bits\n    } = args;\n    const firstBitInByte = 128;\n    const bitmap = new Uint8Array([0, 0, 0, 0]);\n    const dupCheckSet = /* @__PURE__ */new Set();\n    bits.forEach((bit, idx) => {\n      if (idx + 1 > this.publicKeys.length) {\n        throw new Error(`Signature index ${idx + 1} is out of public keys range, ${this.publicKeys.length}.`);\n      }\n      if (dupCheckSet.has(bit)) {\n        throw new Error(`Duplicate bit ${bit} detected.`);\n      }\n      dupCheckSet.add(bit);\n      const byteOffset = Math.floor(bit / 8);\n      let byte = bitmap[byteOffset];\n      byte |= firstBitInByte >> bit % 8;\n      bitmap[byteOffset] = byte;\n    });\n    return bitmap;\n  }\n  toString() {\n    return Hex.fromHexInput(this.toUint8Array()).toString();\n  }\n  verifySignature(args) {\n    throw new Error(\"not implemented\");\n  }\n  serialize(serializer) {\n    serializer.serializeVector(this.publicKeys);\n    serializer.serializeU8(this.signaturesRequired);\n  }\n  static deserialize(deserializer) {\n    const keys = deserializer.deserializeVector(AnyPublicKey);\n    const signaturesRequired = deserializer.deserializeU8();\n    return new MultiKey({\n      publicKeys: keys,\n      signaturesRequired\n    });\n  }\n};\n\n// src/core/authenticationKey.ts\nvar _AuthenticationKey = class extends Serializable {\n  constructor(args) {\n    super();\n    const {\n      data\n    } = args;\n    const hex = Hex.fromHexInput(data);\n    if (hex.toUint8Array().length !== _AuthenticationKey.LENGTH) {\n      throw new Error(`Authentication Key length should be ${_AuthenticationKey.LENGTH}`);\n    }\n    this.data = hex;\n  }\n  serialize(serializer) {\n    serializer.serializeFixedBytes(this.data.toUint8Array());\n  }\n  static deserialize(deserializer) {\n    const bytes = deserializer.deserializeFixedBytes(_AuthenticationKey.LENGTH);\n    return new _AuthenticationKey({\n      data: bytes\n    });\n  }\n  toString() {\n    return this.data.toString();\n  }\n  toUint8Array() {\n    return this.data.toUint8Array();\n  }\n  static fromPublicKeyAndScheme(args) {\n    const {\n      publicKey,\n      scheme\n    } = args;\n    let authKeyBytes;\n    switch (scheme) {\n      case 3 /* MultiKey */:\n      case 2 /* SingleKey */:\n        {\n          const singleKeyBytes = publicKey.bcsToBytes();\n          authKeyBytes = new Uint8Array([...singleKeyBytes, scheme]);\n          break;\n        }\n      case 0 /* Ed25519 */:\n      case 1 /* MultiEd25519 */:\n        {\n          const ed25519PublicKeyBytes = publicKey.toUint8Array();\n          const inputBytes = Hex.fromHexInput(ed25519PublicKeyBytes).toUint8Array();\n          authKeyBytes = new Uint8Array([...inputBytes, scheme]);\n          break;\n        }\n      default:\n        throw new Error(`Scheme ${scheme} is not supported`);\n    }\n    const hash = sha3Hash.create();\n    hash.update(authKeyBytes);\n    const hashDigest = hash.digest();\n    return new _AuthenticationKey({\n      data: hashDigest\n    });\n  }\n  static fromPublicKey(args) {\n    const {\n      publicKey\n    } = args;\n    let scheme;\n    if (publicKey instanceof Ed25519PublicKey) {\n      scheme = 0 /* Ed25519 */.valueOf();\n    } else if (publicKey instanceof MultiEd25519PublicKey) {\n      scheme = 1 /* MultiEd25519 */.valueOf();\n    } else if (publicKey instanceof AnyPublicKey) {\n      scheme = 2 /* SingleKey */.valueOf();\n    } else if (publicKey instanceof MultiKey) {\n      scheme = 3 /* MultiKey */.valueOf();\n    } else {\n      throw new Error(\"No supported authentication scheme for public key\");\n    }\n    return _AuthenticationKey.fromPublicKeyAndScheme({\n      publicKey,\n      scheme\n    });\n  }\n  derivedAddress() {\n    return new AccountAddress({\n      data: this.data.toUint8Array()\n    });\n  }\n};\nvar AuthenticationKey = _AuthenticationKey;\nAuthenticationKey.LENGTH = 32;\n\n// src/utils/hdKey.ts\nimport { hmac } from \"@noble/hashes/hmac\";\nimport { sha512 } from \"@noble/hashes/sha512\";\nimport * as bip39 from \"@scure/bip39\";\nvar APTOS_PATH_REGEX = /^m\\/44'\\/637'\\/[0-9]+'\\/[0-9]+'\\/[0-9]+'?$/;\nvar KeyType = /* @__PURE__ */(KeyType2 => {\n  KeyType2[\"ED25519\"] = \"ed25519 seed\";\n  return KeyType2;\n})(KeyType || {});\nvar HARDENED_OFFSET = 2147483648;\nvar deriveKey = (hashSeed, data) => {\n  const digest = hmac.create(sha512, hashSeed).update(data).digest();\n  return {\n    key: digest.slice(0, 32),\n    chainCode: digest.slice(32)\n  };\n};\nvar CKDPriv = ({\n  key,\n  chainCode\n}, index) => {\n  const buffer = new ArrayBuffer(4);\n  new DataView(buffer).setUint32(0, index);\n  const indexBytes = new Uint8Array(buffer);\n  const zero = new Uint8Array([0]);\n  const data = new Uint8Array([...zero, ...key, ...indexBytes]);\n  return deriveKey(chainCode, data);\n};\nvar removeApostrophes = val => val.replace(\"'\", \"\");\nvar splitPath = path => path.split(\"/\").slice(1).map(removeApostrophes);\nvar isValidPath = path => {\n  if (!APTOS_PATH_REGEX.test(path)) {\n    return false;\n  }\n  return !splitPath(path).some(Number.isNaN);\n};\nvar mnemonicToSeed = mnemonic => {\n  const normalizedMnemonic = mnemonic.trim().split(/\\s+/).map(part => part.toLowerCase()).join(\" \");\n  return bip39.mnemonicToSeedSync(normalizedMnemonic);\n};\nvar derivePrivateKeyFromMnemonic = (keyType, path, seedPhrase, offset = HARDENED_OFFSET) => {\n  if (!isValidPath(path)) {\n    throw new Error(\"Invalid derivation path\");\n  }\n  const {\n    key,\n    chainCode\n  } = deriveKey(keyType, mnemonicToSeed(seedPhrase));\n  const segments = splitPath(path).map(el => parseInt(el, 10));\n  return segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset), {\n    key,\n    chainCode\n  });\n};\n\n// src/core/account.ts\nvar Account = class {\n  constructor(args) {\n    const {\n      privateKey,\n      address,\n      legacy\n    } = args;\n    this.publicKey = privateKey.publicKey();\n    if (this.publicKey instanceof Ed25519PublicKey) {\n      if (legacy) {\n        this.signingScheme = 0 /* Ed25519 */;\n      } else {\n        this.publicKey = new AnyPublicKey(this.publicKey);\n        this.signingScheme = 2 /* SingleKey */;\n      }\n    } else if (this.publicKey instanceof MultiEd25519PublicKey) {\n      this.signingScheme = 1 /* MultiEd25519 */;\n    } else if (this.publicKey instanceof Secp256k1PublicKey) {\n      this.publicKey = new AnyPublicKey(this.publicKey);\n      this.signingScheme = 2 /* SingleKey */;\n    } else {\n      throw new Error(\"Can not create new Account, unsupported public key type\");\n    }\n    this.privateKey = privateKey;\n    this.accountAddress = address;\n  }\n  static generate(args) {\n    let privateKey;\n    switch (args == null ? void 0 : args.scheme) {\n      case 2 /* Secp256k1Ecdsa */:\n        privateKey = Secp256k1PrivateKey.generate();\n        break;\n      default:\n        privateKey = Ed25519PrivateKey.generate();\n    }\n    let publicKey = privateKey.publicKey();\n    if (!(args == null ? void 0 : args.legacy)) {\n      publicKey = new AnyPublicKey(privateKey.publicKey());\n    }\n    const address = new AccountAddress({\n      data: Account.authKey({\n        publicKey\n      }).toUint8Array()\n    });\n    return new Account({\n      privateKey,\n      address,\n      legacy: args == null ? void 0 : args.legacy\n    });\n  }\n  static fromPrivateKeyAndAddress(args) {\n    const {\n      privateKey,\n      address,\n      legacy\n    } = args;\n    return new Account({\n      privateKey,\n      address,\n      legacy\n    });\n  }\n  static fromDerivationPath(args) {\n    const {\n      path,\n      mnemonic\n    } = args;\n    const {\n      key\n    } = derivePrivateKeyFromMnemonic(\"ed25519 seed\" /* ED25519 */, path, mnemonic);\n    const privateKey = new Ed25519PrivateKey(key);\n    const publicKey = privateKey.publicKey();\n    const authKey = Account.authKey({\n      publicKey\n    });\n    const address = new AccountAddress({\n      data: authKey.toUint8Array()\n    });\n    return new Account({\n      privateKey,\n      address,\n      legacy: true\n    });\n  }\n  static authKey(args) {\n    const {\n      publicKey\n    } = args;\n    const authKey = AuthenticationKey.fromPublicKey({\n      publicKey\n    });\n    return authKey.data;\n  }\n  sign(data) {\n    return this.privateKey.sign(data);\n  }\n  verifySignature(args) {\n    const {\n      message,\n      signature\n    } = args;\n    const rawMessage = Hex.fromHexInput(message).toUint8Array();\n    return this.publicKey.verifySignature({\n      message: rawMessage,\n      signature\n    });\n  }\n};\n\n// src/types/generated/queries.ts\nvar CurrentTokenOwnershipFieldsFragmentDoc = `\n    fragment CurrentTokenOwnershipFields on current_token_ownerships_v2 {\n  token_standard\n  token_properties_mutated_v1\n  token_data_id\n  table_type_v1\n  storage_id\n  property_version_v1\n  owner_address\n  last_transaction_version\n  last_transaction_timestamp\n  is_soulbound_v2\n  is_fungible_v2\n  amount\n  current_token_data {\n    collection_id\n    description\n    is_fungible_v2\n    largest_property_version_v1\n    last_transaction_timestamp\n    last_transaction_version\n    maximum\n    supply\n    token_data_id\n    token_name\n    token_properties\n    token_standard\n    token_uri\n    current_collection {\n      collection_id\n      collection_name\n      creator_address\n      current_supply\n      description\n      last_transaction_timestamp\n      last_transaction_version\n      max_supply\n      mutable_description\n      mutable_uri\n      table_handle_v1\n      token_standard\n      total_minted_v2\n      uri\n    }\n  }\n}\n    `;\nvar TokenActivitiesFieldsFragmentDoc = `\n    fragment TokenActivitiesFields on token_activities_v2 {\n  after_value\n  before_value\n  entry_function_id_str\n  event_account_address\n  event_index\n  from_address\n  is_fungible_v2\n  property_version_v1\n  to_address\n  token_amount\n  token_data_id\n  token_standard\n  transaction_timestamp\n  transaction_version\n  type\n}\n    `;\nvar GetAccountCoinsCount = `\n    query getAccountCoinsCount($address: String) {\n  current_fungible_asset_balances_aggregate(\n    where: {owner_address: {_eq: $address}}\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n    `;\nvar GetAccountCoinsData = `\n    query getAccountCoinsData($where_condition: current_fungible_asset_balances_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_fungible_asset_balances_order_by!]) {\n  current_fungible_asset_balances(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    amount\n    asset_type\n    is_frozen\n    is_primary\n    last_transaction_timestamp\n    last_transaction_version\n    owner_address\n    storage_id\n    token_standard\n    metadata {\n      token_standard\n      symbol\n      supply_aggregator_table_key_v1\n      supply_aggregator_table_handle_v1\n      project_uri\n      name\n      last_transaction_version\n      last_transaction_timestamp\n      icon_uri\n      decimals\n      creator_address\n      asset_type\n    }\n  }\n}\n    `;\nvar GetAccountCollectionsWithOwnedTokens = `\n    query getAccountCollectionsWithOwnedTokens($where_condition: current_collection_ownership_v2_view_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_collection_ownership_v2_view_order_by!]) {\n  current_collection_ownership_v2_view(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    current_collection {\n      collection_id\n      collection_name\n      creator_address\n      current_supply\n      description\n      last_transaction_timestamp\n      last_transaction_version\n      mutable_description\n      max_supply\n      mutable_uri\n      table_handle_v1\n      token_standard\n      total_minted_v2\n      uri\n    }\n    collection_id\n    collection_name\n    collection_uri\n    creator_address\n    distinct_tokens\n    last_transaction_version\n    owner_address\n    single_token_uri\n  }\n}\n    `;\nvar GetAccountOwnedObjects = `\n    query getAccountOwnedObjects($where_condition: current_objects_bool_exp, $offset: Int, $limit: Int, $order_by: [current_objects_order_by!]) {\n  current_objects(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    allow_ungated_transfer\n    state_key_hash\n    owner_address\n    object_address\n    last_transaction_version\n    last_guid_creation_num\n    is_deleted\n  }\n}\n    `;\nvar GetAccountOwnedTokens = `\n    query getAccountOwnedTokens($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {\n  current_token_ownerships_v2(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    ...CurrentTokenOwnershipFields\n  }\n}\n    ${CurrentTokenOwnershipFieldsFragmentDoc}`;\nvar GetAccountOwnedTokensByTokenData = `\n    query getAccountOwnedTokensByTokenData($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {\n  current_token_ownerships_v2(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    ...CurrentTokenOwnershipFields\n  }\n}\n    ${CurrentTokenOwnershipFieldsFragmentDoc}`;\nvar GetAccountOwnedTokensFromCollection = `\n    query getAccountOwnedTokensFromCollection($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {\n  current_token_ownerships_v2(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    ...CurrentTokenOwnershipFields\n  }\n}\n    ${CurrentTokenOwnershipFieldsFragmentDoc}`;\nvar GetAccountTokensCount = `\n    query getAccountTokensCount($where_condition: current_token_ownerships_v2_bool_exp, $offset: Int, $limit: Int) {\n  current_token_ownerships_v2_aggregate(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n  ) {\n    aggregate {\n      count\n    }\n  }\n}\n    `;\nvar GetAccountTransactionsCount = `\n    query getAccountTransactionsCount($address: String) {\n  account_transactions_aggregate(where: {account_address: {_eq: $address}}) {\n    aggregate {\n      count\n    }\n  }\n}\n    `;\nvar GetChainTopUserTransactions = `\n    query getChainTopUserTransactions($limit: Int) {\n  user_transactions(limit: $limit, order_by: {version: desc}) {\n    version\n  }\n}\n    `;\nvar GetCollectionData = `\n    query getCollectionData($where_condition: current_collections_v2_bool_exp!) {\n  current_collections_v2(where: $where_condition) {\n    collection_id\n    collection_name\n    creator_address\n    current_supply\n    description\n    last_transaction_timestamp\n    last_transaction_version\n    max_supply\n    mutable_description\n    mutable_uri\n    table_handle_v1\n    token_standard\n    total_minted_v2\n    uri\n  }\n}\n    `;\nvar GetCurrentFungibleAssetBalances = `\n    query getCurrentFungibleAssetBalances($where_condition: current_fungible_asset_balances_bool_exp, $offset: Int, $limit: Int) {\n  current_fungible_asset_balances(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n  ) {\n    amount\n    asset_type\n    is_frozen\n    is_primary\n    last_transaction_timestamp\n    last_transaction_version\n    owner_address\n    storage_id\n    token_standard\n  }\n}\n    `;\nvar GetDelegatedStakingActivities = `\n    query getDelegatedStakingActivities($delegatorAddress: String, $poolAddress: String) {\n  delegated_staking_activities(\n    where: {delegator_address: {_eq: $delegatorAddress}, pool_address: {_eq: $poolAddress}}\n  ) {\n    amount\n    delegator_address\n    event_index\n    event_type\n    pool_address\n    transaction_version\n  }\n}\n    `;\nvar GetEvents = `\n    query getEvents($where_condition: events_bool_exp, $offset: Int, $limit: Int, $order_by: [events_order_by!]) {\n  events(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    account_address\n    creation_number\n    data\n    event_index\n    sequence_number\n    transaction_block_height\n    transaction_version\n    type\n  }\n}\n    `;\nvar GetFungibleAssetActivities = `\n    query getFungibleAssetActivities($where_condition: fungible_asset_activities_bool_exp, $offset: Int, $limit: Int) {\n  fungible_asset_activities(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n  ) {\n    amount\n    asset_type\n    block_height\n    entry_function_id_str\n    event_index\n    gas_fee_payer_address\n    is_frozen\n    is_gas_fee\n    is_transaction_success\n    owner_address\n    storage_id\n    storage_refund_amount\n    token_standard\n    transaction_timestamp\n    transaction_version\n    type\n  }\n}\n    `;\nvar GetFungibleAssetMetadata = `\n    query getFungibleAssetMetadata($where_condition: fungible_asset_metadata_bool_exp, $offset: Int, $limit: Int) {\n  fungible_asset_metadata(where: $where_condition, offset: $offset, limit: $limit) {\n    icon_uri\n    project_uri\n    supply_aggregator_table_handle_v1\n    supply_aggregator_table_key_v1\n    creator_address\n    asset_type\n    decimals\n    last_transaction_timestamp\n    last_transaction_version\n    name\n    symbol\n    token_standard\n  }\n}\n    `;\nvar GetNumberOfDelegators = `\n    query getNumberOfDelegators($where_condition: num_active_delegator_per_pool_bool_exp!, $order_by: [num_active_delegator_per_pool_order_by!]) {\n  num_active_delegator_per_pool(where: $where_condition, order_by: $order_by) {\n    num_active_delegator\n    pool_address\n  }\n}\n    `;\nvar GetProcessorStatus = `\n    query getProcessorStatus {\n  processor_status {\n    last_success_version\n    processor\n    last_updated\n  }\n}\n    `;\nvar GetTokenActivity = `\n    query getTokenActivity($where_condition: token_activities_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [token_activities_v2_order_by!]) {\n  token_activities_v2(\n    where: $where_condition\n    order_by: $order_by\n    offset: $offset\n    limit: $limit\n  ) {\n    ...TokenActivitiesFields\n  }\n}\n    ${TokenActivitiesFieldsFragmentDoc}`;\nvar GetCurrentTokenOwnership = `\n    query getCurrentTokenOwnership($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {\n  current_token_ownerships_v2(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    ...CurrentTokenOwnershipFields\n  }\n}\n    ${CurrentTokenOwnershipFieldsFragmentDoc}`;\nvar GetTokenData = `\n    query getTokenData($where_condition: current_token_datas_v2_bool_exp, $offset: Int, $limit: Int, $order_by: [current_token_datas_v2_order_by!]) {\n  current_token_datas_v2(\n    where: $where_condition\n    offset: $offset\n    limit: $limit\n    order_by: $order_by\n  ) {\n    collection_id\n    description\n    is_fungible_v2\n    largest_property_version_v1\n    last_transaction_timestamp\n    last_transaction_version\n    maximum\n    supply\n    token_data_id\n    token_name\n    token_properties\n    token_standard\n    token_uri\n    current_collection {\n      collection_id\n      collection_name\n      creator_address\n      current_supply\n      description\n      last_transaction_timestamp\n      last_transaction_version\n      max_supply\n      mutable_description\n      mutable_uri\n      table_handle_v1\n      token_standard\n      total_minted_v2\n      uri\n    }\n  }\n}\n    `;\n\n// src/internal/general.ts\nasync function getLedgerInfo(args) {\n  const {\n    aptosConfig\n  } = args;\n  const {\n    data\n  } = await getAptosFullNode({\n    aptosConfig,\n    originMethod: \"getLedgerInfo\",\n    path: \"\"\n  });\n  return data;\n}\nasync function getBlockByVersion(args) {\n  const {\n    aptosConfig,\n    ledgerVersion,\n    options\n  } = args;\n  const {\n    data\n  } = await getAptosFullNode({\n    aptosConfig,\n    originMethod: \"getBlockByVersion\",\n    path: `blocks/by_version/${ledgerVersion}`,\n    params: {\n      with_transactions: options == null ? void 0 : options.withTransactions\n    }\n  });\n  return data;\n}\nasync function getBlockByHeight(args) {\n  const {\n    aptosConfig,\n    blockHeight,\n    options\n  } = args;\n  const {\n    data\n  } = await getAptosFullNode({\n    aptosConfig,\n    originMethod: \"getBlockByHeight\",\n    path: `blocks/by_height/${blockHeight}`,\n    params: {\n      with_transactions: options == null ? void 0 : options.withTransactions\n    }\n  });\n  return data;\n}\nasync function getTableItem(args) {\n  const {\n    aptosConfig,\n    handle,\n    data,\n    options\n  } = args;\n  const response = await postAptosFullNode({\n    aptosConfig,\n    originMethod: \"getTableItem\",\n    path: `tables/${handle}/item`,\n    params: {\n      ledger_version: options == null ? void 0 : options.ledgerVersion\n    },\n    body: data\n  });\n  return response.data;\n}\nasync function view(args) {\n  var _a, _b;\n  const {\n    aptosConfig,\n    payload,\n    options\n  } = args;\n  const {\n    data\n  } = await postAptosFullNode({\n    aptosConfig,\n    originMethod: \"view\",\n    path: \"view\",\n    params: {\n      ledger_version: options == null ? void 0 : options.ledgerVersion\n    },\n    body: {\n      function: payload.function,\n      type_arguments: (_a = payload.typeArguments) != null ? _a : [],\n      arguments: (_b = payload.functionArguments) != null ? _b : []\n    }\n  });\n  return data;\n}\nasync function getChainTopUserTransactions(args) {\n  const {\n    aptosConfig,\n    limit\n  } = args;\n  const graphqlQuery = {\n    query: GetChainTopUserTransactions,\n    variables: {\n      limit\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getChainTopUserTransactions\"\n  });\n  return data.user_transactions;\n}\nasync function queryIndexer(args) {\n  const {\n    aptosConfig,\n    query,\n    originMethod\n  } = args;\n  const {\n    data\n  } = await postAptosIndexer({\n    aptosConfig,\n    originMethod: originMethod != null ? originMethod : \"queryIndexer\",\n    path: \"\",\n    body: query,\n    overrides: {\n      WITH_CREDENTIALS: false\n    }\n  });\n  return data;\n}\nasync function getProcessorStatuses(args) {\n  const {\n    aptosConfig\n  } = args;\n  const graphqlQuery = {\n    query: GetProcessorStatus\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getProcessorStatuses\"\n  });\n  return data.processor_status;\n}\nasync function getIndexerLastSuccessVersion(args) {\n  const response = await getProcessorStatuses({\n    aptosConfig: args.aptosConfig\n  });\n  return response[0].last_success_version;\n}\n\n// src/utils/memoize.ts\nvar cache = /* @__PURE__ */new Map();\nfunction memoizeAsync(func, key, ttlMs) {\n  return async (...args) => {\n    if (cache.has(key)) {\n      const {\n        value,\n        timestamp\n      } = cache.get(key);\n      if (ttlMs === void 0 || Date.now() - timestamp <= ttlMs) {\n        return value;\n      }\n    }\n    const result = await func(...args);\n    cache.set(key, {\n      value: result,\n      timestamp: Date.now()\n    });\n    return result;\n  };\n}\n\n// src/internal/account.ts\nasync function getInfo(args) {\n  const {\n    aptosConfig,\n    accountAddress\n  } = args;\n  const {\n    data\n  } = await getAptosFullNode({\n    aptosConfig,\n    originMethod: \"getInfo\",\n    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}`\n  });\n  return data;\n}\nasync function getModules(args) {\n  var _a;\n  const {\n    aptosConfig,\n    accountAddress,\n    options\n  } = args;\n  return paginateWithCursor({\n    aptosConfig,\n    originMethod: \"getModules\",\n    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}/modules`,\n    params: {\n      ledger_version: options == null ? void 0 : options.ledgerVersion,\n      start: options == null ? void 0 : options.offset,\n      limit: (_a = options == null ? void 0 : options.limit) != null ? _a : 1e3\n    }\n  });\n}\nasync function getModule(args) {\n  var _a;\n  if (((_a = args.options) == null ? void 0 : _a.ledgerVersion) !== void 0) {\n    return getModuleInner(args);\n  }\n  return memoizeAsync(async () => getModuleInner(args), `module-${args.accountAddress}-${args.moduleName}`, 1e3 * 60 * 5)();\n}\nasync function getModuleInner(args) {\n  const {\n    aptosConfig,\n    accountAddress,\n    moduleName,\n    options\n  } = args;\n  const {\n    data\n  } = await getAptosFullNode({\n    aptosConfig,\n    originMethod: \"getModule\",\n    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}/module/${moduleName}`,\n    params: {\n      ledger_version: options == null ? void 0 : options.ledgerVersion\n    }\n  });\n  return data;\n}\nasync function getTransactions(args) {\n  const {\n    aptosConfig,\n    accountAddress,\n    options\n  } = args;\n  return paginateWithCursor({\n    aptosConfig,\n    originMethod: \"getTransactions\",\n    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}/transactions`,\n    params: {\n      start: options == null ? void 0 : options.offset,\n      limit: options == null ? void 0 : options.limit\n    }\n  });\n}\nasync function getResources(args) {\n  var _a;\n  const {\n    aptosConfig,\n    accountAddress,\n    options\n  } = args;\n  return paginateWithCursor({\n    aptosConfig,\n    originMethod: \"getResources\",\n    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}/resources`,\n    params: {\n      ledger_version: options == null ? void 0 : options.ledgerVersion,\n      start: options == null ? void 0 : options.offset,\n      limit: (_a = options == null ? void 0 : options.limit) != null ? _a : 999\n    }\n  });\n}\nasync function getResource(args) {\n  const {\n    aptosConfig,\n    accountAddress,\n    resourceType,\n    options\n  } = args;\n  const {\n    data\n  } = await getAptosFullNode({\n    aptosConfig,\n    originMethod: \"getResource\",\n    path: `accounts/${AccountAddress.fromHexInput(accountAddress).toString()}/resource/${resourceType}`,\n    params: {\n      ledger_version: options == null ? void 0 : options.ledgerVersion\n    }\n  });\n  return data.data;\n}\nasync function lookupOriginalAccountAddress(args) {\n  const {\n    aptosConfig,\n    authenticationKey,\n    options\n  } = args;\n  const resource = await getResource({\n    aptosConfig,\n    accountAddress: \"0x1\",\n    resourceType: \"0x1::account::OriginatingAddress\",\n    options\n  });\n  const {\n    address_map: {\n      handle\n    }\n  } = resource;\n  try {\n    const originalAddress = await getTableItem({\n      aptosConfig,\n      handle,\n      data: {\n        key: Hex.fromHexInput(authenticationKey).toString(),\n        key_type: \"address\",\n        value_type: \"address\"\n      },\n      options\n    });\n    return AccountAddress.fromHexInput(originalAddress);\n  } catch (err) {\n    if (err instanceof AptosApiError && err.data.error_code === \"table_item_not_found\") {\n      return AccountAddress.fromHexInput(authenticationKey);\n    }\n    throw err;\n  }\n}\nasync function getAccountTokensCount(args) {\n  const {\n    aptosConfig,\n    accountAddress\n  } = args;\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n  const whereCondition = {\n    owner_address: {\n      _eq: address\n    },\n    amount: {\n      _gt: \"0\"\n    }\n  };\n  const graphqlQuery = {\n    query: GetAccountTokensCount,\n    variables: {\n      where_condition: whereCondition\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountTokensCount\"\n  });\n  if (!data.current_token_ownerships_v2_aggregate.aggregate) {\n    throw Error(\"Failed to get the count of account tokens\");\n  }\n  return data.current_token_ownerships_v2_aggregate.aggregate.count;\n}\nasync function getAccountOwnedTokens(args) {\n  var _a, _b;\n  const {\n    aptosConfig,\n    accountAddress,\n    options\n  } = args;\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n  const whereCondition = {\n    owner_address: {\n      _eq: address\n    },\n    amount: {\n      _gt: 0\n    }\n  };\n  if (options == null ? void 0 : options.tokenStandard) {\n    whereCondition.token_standard = {\n      _eq: options == null ? void 0 : options.tokenStandard\n    };\n  }\n  const graphqlQuery = {\n    query: GetAccountOwnedTokens,\n    variables: {\n      where_condition: whereCondition,\n      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,\n      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,\n      order_by: options == null ? void 0 : options.orderBy\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedTokens\"\n  });\n  return data.current_token_ownerships_v2;\n}\nasync function getAccountOwnedTokensFromCollectionAddress(args) {\n  var _a, _b;\n  const {\n    aptosConfig,\n    accountAddress,\n    collectionAddress,\n    options\n  } = args;\n  const ownerAddress = AccountAddress.fromHexInput(accountAddress).toString();\n  const collAddress = Hex.fromHexInput(collectionAddress).toString();\n  const whereCondition = {\n    owner_address: {\n      _eq: ownerAddress\n    },\n    current_token_data: {\n      collection_id: {\n        _eq: collAddress\n      }\n    },\n    amount: {\n      _gt: 0\n    }\n  };\n  if (options == null ? void 0 : options.tokenStandard) {\n    whereCondition.token_standard = {\n      _eq: options == null ? void 0 : options.tokenStandard\n    };\n  }\n  const graphqlQuery = {\n    query: GetAccountOwnedTokensFromCollection,\n    variables: {\n      where_condition: whereCondition,\n      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,\n      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,\n      order_by: options == null ? void 0 : options.orderBy\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedTokensFromCollectionAddress\"\n  });\n  return data.current_token_ownerships_v2;\n}\nasync function getAccountCollectionsWithOwnedTokens(args) {\n  var _a, _b;\n  const {\n    aptosConfig,\n    accountAddress,\n    options\n  } = args;\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n  const whereCondition = {\n    owner_address: {\n      _eq: address\n    },\n    amount: {\n      _gt: 0\n    }\n  };\n  if (options == null ? void 0 : options.tokenStandard) {\n    whereCondition.current_collection = {\n      token_standard: {\n        _eq: options == null ? void 0 : options.tokenStandard\n      }\n    };\n  }\n  const graphqlQuery = {\n    query: GetAccountCollectionsWithOwnedTokens,\n    variables: {\n      where_condition: whereCondition,\n      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,\n      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,\n      order_by: options == null ? void 0 : options.orderBy\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCollectionsWithOwnedTokens\"\n  });\n  return data.current_collection_ownership_v2_view;\n}\nasync function getAccountTransactionsCount(args) {\n  const {\n    aptosConfig,\n    accountAddress\n  } = args;\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n  const graphqlQuery = {\n    query: GetAccountTransactionsCount,\n    variables: {\n      address\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountTransactionsCount\"\n  });\n  if (!data.account_transactions_aggregate.aggregate) {\n    throw Error(\"Failed to get the count of account transactions\");\n  }\n  return data.account_transactions_aggregate.aggregate.count;\n}\nasync function getAccountCoinsData(args) {\n  var _a, _b;\n  const {\n    aptosConfig,\n    accountAddress,\n    options\n  } = args;\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n  const whereCondition = {\n    owner_address: {\n      _eq: address\n    }\n  };\n  const graphqlQuery = {\n    query: GetAccountCoinsData,\n    variables: {\n      where_condition: whereCondition,\n      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,\n      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,\n      order_by: options == null ? void 0 : options.orderBy\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCoinsData\"\n  });\n  return data.current_fungible_asset_balances;\n}\nasync function getAccountCoinsCount(args) {\n  const {\n    aptosConfig,\n    accountAddress\n  } = args;\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n  const graphqlQuery = {\n    query: GetAccountCoinsCount,\n    variables: {\n      address\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountCoinsCount\"\n  });\n  if (!data.current_fungible_asset_balances_aggregate.aggregate) {\n    throw Error(\"Failed to get the count of account coins\");\n  }\n  return data.current_fungible_asset_balances_aggregate.aggregate.count;\n}\nasync function getAccountOwnedObjects(args) {\n  var _a, _b;\n  const {\n    aptosConfig,\n    accountAddress,\n    options\n  } = args;\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n  const whereCondition = {\n    owner_address: {\n      _eq: address\n    }\n  };\n  const graphqlQuery = {\n    query: GetAccountOwnedObjects,\n    variables: {\n      where_condition: whereCondition,\n      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,\n      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,\n      order_by: options == null ? void 0 : options.orderBy\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getAccountOwnedObjects\"\n  });\n  return data.current_objects;\n}\nasync function deriveAccountFromPrivateKey(args) {\n  const {\n    aptosConfig,\n    privateKey\n  } = args;\n  const publicKey = new AnyPublicKey(privateKey.publicKey());\n  if (privateKey instanceof Secp256k1PrivateKey) {\n    const authKey = AuthenticationKey.fromPublicKeyAndScheme({\n      publicKey,\n      scheme: 2 /* SingleKey */\n    });\n    const address = new AccountAddress({\n      data: authKey.toUint8Array()\n    });\n    return Account.fromPrivateKeyAndAddress({\n      privateKey,\n      address\n    });\n  }\n  if (privateKey instanceof Ed25519PrivateKey) {\n    const SingleSenderTransactionAuthenticatorAuthKey = AuthenticationKey.fromPublicKeyAndScheme({\n      publicKey,\n      scheme: 2 /* SingleKey */\n    });\n    const isSingleSenderTransactionAuthenticator = await isAccountExist({\n      authKey: SingleSenderTransactionAuthenticatorAuthKey,\n      aptosConfig\n    });\n    if (isSingleSenderTransactionAuthenticator) {\n      const address = new AccountAddress({\n        data: SingleSenderTransactionAuthenticatorAuthKey.toUint8Array()\n      });\n      return Account.fromPrivateKeyAndAddress({\n        privateKey,\n        address\n      });\n    }\n    const legacyAuthKey = AuthenticationKey.fromPublicKeyAndScheme({\n      publicKey,\n      scheme: 0 /* Ed25519 */\n    });\n    const isLegacyEd25519 = await isAccountExist({\n      authKey: legacyAuthKey,\n      aptosConfig\n    });\n    if (isLegacyEd25519) {\n      const address = new AccountAddress({\n        data: legacyAuthKey.toUint8Array()\n      });\n      return Account.fromPrivateKeyAndAddress({\n        privateKey,\n        address,\n        legacy: true\n      });\n    }\n  }\n  throw new Error(`Can't derive account from private key ${privateKey}`);\n}\nasync function isAccountExist(args) {\n  const {\n    aptosConfig,\n    authKey\n  } = args;\n  const accountAddress = await lookupOriginalAccountAddress({\n    aptosConfig,\n    authenticationKey: authKey.toString()\n  });\n  try {\n    await getInfo({\n      aptosConfig,\n      accountAddress: accountAddress.toString()\n    });\n    return true;\n  } catch (error) {\n    if (error.status === 404) {\n      return false;\n    }\n    throw new Error(`Error while looking for an account info ${accountAddress.toString()}`);\n  }\n}\n\n// src/api/account.ts\nvar Account2 = class {\n  constructor(config) {\n    this.config = config;\n  }\n  async getAccountInfo(args) {\n    return getInfo({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountModules(args) {\n    return getModules({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountModule(args) {\n    return getModule({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountTransactions(args) {\n    return getTransactions({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountResources(args) {\n    return getResources({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountResource(args) {\n    return getResource({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async lookupOriginalAccountAddress(args) {\n    return lookupOriginalAccountAddress({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountTokensCount(args) {\n    return getAccountTokensCount({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountOwnedTokens(args) {\n    return getAccountOwnedTokens({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountOwnedTokensFromCollectionAddress(args) {\n    return getAccountOwnedTokensFromCollectionAddress({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountCollectionsWithOwnedTokens(args) {\n    return getAccountCollectionsWithOwnedTokens({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountTransactionsCount(args) {\n    return getAccountTransactionsCount({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountCoinsData(args) {\n    return getAccountCoinsData({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountCoinsCount(args) {\n    return getAccountCoinsCount({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountOwnedObjects(args) {\n    return getAccountOwnedObjects({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async deriveAccountFromPrivateKey(args) {\n    return deriveAccountFromPrivateKey({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n};\n\n// src/api/aptosConfig.ts\nimport aptosClient from \"@aptos-labs/aptos-client\";\nvar AptosConfig = class {\n  constructor(settings) {\n    var _a, _b, _c;\n    this.network = (_a = settings == null ? void 0 : settings.network) != null ? _a : DEFAULT_NETWORK;\n    this.fullnode = settings == null ? void 0 : settings.fullnode;\n    this.faucet = settings == null ? void 0 : settings.faucet;\n    this.indexer = settings == null ? void 0 : settings.indexer;\n    this.client = (_b = settings == null ? void 0 : settings.client) != null ? _b : {\n      provider: aptosClient\n    };\n    this.clientConfig = (_c = settings == null ? void 0 : settings.clientConfig) != null ? _c : {};\n  }\n  getRequestUrl(apiType) {\n    switch (apiType) {\n      case 0 /* FULLNODE */:\n        if (this.fullnode !== void 0) return this.fullnode;\n        if (this.network === \"custom\" /* CUSTOM */) throw new Error(\"Please provide a custom full node url\");\n        return NetworkToNodeAPI[this.network];\n      case 2 /* FAUCET */:\n        if (this.faucet !== void 0) return this.faucet;\n        if (this.network === \"custom\" /* CUSTOM */) throw new Error(\"Please provide a custom faucet url\");\n        return NetworkToFaucetAPI[this.network];\n      case 1 /* INDEXER */:\n        if (this.indexer !== void 0) return this.indexer;\n        if (this.network === \"custom\" /* CUSTOM */) throw new Error(\"Please provide a custom indexer url\");\n        return NetworkToIndexerAPI[this.network];\n      default:\n        throw Error(`apiType ${apiType} is not supported`);\n    }\n  }\n  isIndexerRequest(url) {\n    return NetworkToIndexerAPI[this.network] === url;\n  }\n};\n\n// src/transactions/transactionBuilder/transactionBuilder.ts\nimport { sha3_256 as sha3Hash2 } from \"@noble/hashes/sha3\";\n\n// src/core/crypto/anySignature.ts\nvar AnySignature = class extends Signature {\n  constructor(signature) {\n    super();\n    this.signature = signature;\n  }\n  toUint8Array() {\n    return this.signature.toUint8Array();\n  }\n  toString() {\n    return this.signature.toString();\n  }\n  serialize(serializer) {\n    if (this.signature instanceof Ed25519Signature) {\n      serializer.serializeU32AsUleb128(0 /* Ed25519 */);\n      this.signature.serialize(serializer);\n    } else if (this.signature instanceof Secp256k1Signature) {\n      serializer.serializeU32AsUleb128(1 /* Secp256k1 */);\n      this.signature.serialize(serializer);\n    } else {\n      throw new Error(\"Unknown signature type\");\n    }\n  }\n  static deserialize(deserializer) {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case 0 /* Ed25519 */:\n        return new AnySignature(Ed25519Signature.load(deserializer));\n      case 1 /* Secp256k1 */:\n        return new AnySignature(Secp256k1Signature.load(deserializer));\n      default:\n        throw new Error(`Unknown variant index for AnySignature: ${index}`);\n    }\n  }\n};\n\n// src/utils/helpers.ts\nasync function sleep(timeMs) {\n  return new Promise(resolve => {\n    setTimeout(resolve, timeMs);\n  });\n}\n\n// src/internal/transaction.ts\nasync function getTransactions2(args) {\n  const {\n    aptosConfig,\n    options\n  } = args;\n  return paginateWithCursor({\n    aptosConfig,\n    originMethod: \"getTransactions\",\n    path: \"transactions\",\n    params: {\n      start: options == null ? void 0 : options.offset,\n      limit: options == null ? void 0 : options.limit\n    }\n  });\n}\nasync function getGasPriceEstimation(args) {\n  const {\n    aptosConfig\n  } = args;\n  return memoizeAsync(async () => {\n    const {\n      data\n    } = await getAptosFullNode({\n      aptosConfig,\n      originMethod: \"getGasPriceEstimation\",\n      path: \"estimate_gas_price\"\n    });\n    return data;\n  }, `gas-price-${aptosConfig.network}`, 1e3 * 60 * 5)();\n}\nasync function getTransactionByVersion(args) {\n  const {\n    aptosConfig,\n    ledgerVersion\n  } = args;\n  const {\n    data\n  } = await getAptosFullNode({\n    aptosConfig,\n    originMethod: \"getTransactionByVersion\",\n    path: `transactions/by_version/${ledgerVersion}`\n  });\n  return data;\n}\nasync function getTransactionByHash(args) {\n  const {\n    aptosConfig,\n    transactionHash\n  } = args;\n  const {\n    data\n  } = await getAptosFullNode({\n    aptosConfig,\n    path: `transactions/by_hash/${transactionHash}`,\n    originMethod: \"getTransactionByHash\"\n  });\n  return data;\n}\nasync function isTransactionPending(args) {\n  const {\n    aptosConfig,\n    transactionHash\n  } = args;\n  try {\n    const transaction = await getTransactionByHash({\n      aptosConfig,\n      transactionHash\n    });\n    return transaction.type === \"pending_transaction\" /* Pending */;\n  } catch (e) {\n    if ((e == null ? void 0 : e.status) === 404) {\n      return true;\n    }\n    throw e;\n  }\n}\nasync function waitForTransaction(args) {\n  var _a, _b, _c;\n  const {\n    aptosConfig,\n    transactionHash,\n    options\n  } = args;\n  const timeoutSecs = (_a = options == null ? void 0 : options.timeoutSecs) != null ? _a : DEFAULT_TXN_TIMEOUT_SEC;\n  const checkSuccess = (_b = options == null ? void 0 : options.checkSuccess) != null ? _b : true;\n  const indexerVersionCheck = (_c = options == null ? void 0 : options.indexerVersionCheck) != null ? _c : true;\n  let isPending = true;\n  let timeElapsed = 0;\n  let lastTxn;\n  let lastError;\n  let backoffIntervalMs = 200;\n  const backoffMultiplier = 1.5;\n  while (isPending) {\n    if (timeElapsed >= timeoutSecs) {\n      break;\n    }\n    try {\n      lastTxn = await getTransactionByHash({\n        aptosConfig,\n        transactionHash\n      });\n      isPending = lastTxn.type === \"pending_transaction\" /* Pending */;\n      if (!isPending) {\n        break;\n      }\n    } catch (e) {\n      const isAptosApiError = e instanceof AptosApiError;\n      if (!isAptosApiError) {\n        throw e;\n      }\n      lastError = e;\n      const isRequestError = e.status !== 404 && e.status >= 400 && e.status < 500;\n      if (isRequestError) {\n        throw e;\n      }\n    }\n    await sleep(backoffIntervalMs);\n    timeElapsed += backoffIntervalMs / 1e3;\n    backoffIntervalMs *= backoffMultiplier;\n  }\n  if (lastTxn === void 0) {\n    if (lastError) {\n      throw lastError;\n    } else {\n      throw new WaitForTransactionError(`Fetching transaction ${transactionHash} failed and timed out after ${timeoutSecs} seconds`, lastTxn);\n    }\n  }\n  if (lastTxn.type === \"pending_transaction\" /* Pending */) {\n    throw new WaitForTransactionError(`Transaction ${transactionHash} timed out in pending state after ${timeoutSecs} seconds`, lastTxn);\n  }\n  if (!checkSuccess) {\n    return lastTxn;\n  }\n  if (!lastTxn.success) {\n    throw new FailedTransactionError(`Transaction ${transactionHash} failed with an error: ${lastTxn.vm_status}`, lastTxn);\n  }\n  if (indexerVersionCheck) {\n    try {\n      await waitForLastSuccessIndexerVersionSync({\n        aptosConfig,\n        ledgerVersion: Number(lastTxn.version)\n      });\n    } catch (_e) {\n      throw new WaitForTransactionError(`Transaction ${transactionHash} committed, but timed out waiting for indexer to sync with ledger version ${lastTxn.version}.You can disable this check by setting \\`indexerVersionCheck\\` to false in the \\`extraArgs\\` parameter.`, lastTxn);\n    }\n  }\n  return lastTxn;\n}\nasync function waitForLastSuccessIndexerVersionSync(args) {\n  const {\n    aptosConfig,\n    ledgerVersion\n  } = args;\n  const timeoutMilliseconds = 3e3;\n  const startTime = new Date().getTime();\n  let indexerVersion = -1;\n  while (indexerVersion < ledgerVersion) {\n    if (new Date().getTime() - startTime > timeoutMilliseconds) {\n      throw new Error(\"waitForLastSuccessIndexerVersionSync timeout\");\n    }\n    indexerVersion = await getIndexerLastSuccessVersion({\n      aptosConfig\n    });\n    if (indexerVersion >= ledgerVersion) {\n      break;\n    }\n    await sleep(200);\n  }\n}\nvar WaitForTransactionError = class extends Error {\n  constructor(message, lastSubmittedTransaction) {\n    super(message);\n    this.lastSubmittedTransaction = lastSubmittedTransaction;\n  }\n};\nvar FailedTransactionError = class extends Error {\n  constructor(message, transaction) {\n    super(message);\n    this.transaction = transaction;\n  }\n};\n\n// src/transactions/authenticator/account.ts\nvar AccountAuthenticator = class extends Serializable {\n  static deserialize(deserializer) {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case 0 /* Ed25519 */:\n        return AccountAuthenticatorEd25519.load(deserializer);\n      case 1 /* MultiEd25519 */:\n        return AccountAuthenticatorMultiEd25519.load(deserializer);\n      case 2 /* SingleKey */:\n        return AccountAuthenticatorSingleKey.load(deserializer);\n      case 3 /* MultiKey */:\n        return AccountAuthenticatorMultiKey.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for AccountAuthenticator: ${index}`);\n    }\n  }\n};\nvar AccountAuthenticatorEd25519 = class extends AccountAuthenticator {\n  constructor(public_key, signature) {\n    super();\n    this.public_key = public_key;\n    this.signature = signature;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(0 /* Ed25519 */);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n  static load(deserializer) {\n    const public_key = Ed25519PublicKey.deserialize(deserializer);\n    const signature = Ed25519Signature.deserialize(deserializer);\n    return new AccountAuthenticatorEd25519(public_key, signature);\n  }\n};\nvar AccountAuthenticatorMultiEd25519 = class extends AccountAuthenticator {\n  constructor(public_key, signature) {\n    super();\n    this.public_key = public_key;\n    this.signature = signature;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(1 /* MultiEd25519 */);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n  static load(deserializer) {\n    const public_key = MultiEd25519PublicKey.deserialize(deserializer);\n    const signature = MultiEd25519Signature.deserialize(deserializer);\n    return new AccountAuthenticatorMultiEd25519(public_key, signature);\n  }\n};\nvar AccountAuthenticatorSingleKey = class extends AccountAuthenticator {\n  constructor(public_key, signature) {\n    super();\n    this.public_key = public_key;\n    this.signature = signature;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(2 /* SingleKey */);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n  static load(deserializer) {\n    const public_key = AnyPublicKey.deserialize(deserializer);\n    const signature = AnySignature.deserialize(deserializer);\n    return new AccountAuthenticatorSingleKey(public_key, signature);\n  }\n};\nvar AccountAuthenticatorMultiKey = class extends AccountAuthenticator {\n  constructor(public_keys, signatures, signatures_bitmap) {\n    super();\n    this.public_keys = public_keys;\n    this.signatures = signatures;\n    this.signatures_bitmap = signatures_bitmap;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(3 /* MultiKey */);\n    this.public_keys.serialize(serializer);\n    serializer.serializeVector(this.signatures);\n    serializer.serializeBytes(this.signatures_bitmap);\n  }\n  static load(deserializer) {\n    const public_keys = MultiKey.deserialize(deserializer);\n    const signatures = deserializer.deserializeVector(AnySignature);\n    const signatures_bitmap = deserializer.deserializeBytes();\n    return new AccountAuthenticatorMultiKey(public_keys, signatures, signatures_bitmap);\n  }\n};\n\n// src/transactions/authenticator/transaction.ts\nvar TransactionAuthenticator = class extends Serializable {\n  static deserialize(deserializer) {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case 0 /* Ed25519 */:\n        return TransactionAuthenticatorEd25519.load(deserializer);\n      case 1 /* MultiEd25519 */:\n        return TransactionAuthenticatorMultiEd25519.load(deserializer);\n      case 2 /* MultiAgent */:\n        return TransactionAuthenticatorMultiAgent.load(deserializer);\n      case 3 /* FeePayer */:\n        return TransactionAuthenticatorFeePayer.load(deserializer);\n      case 4 /* SingleSender */:\n        return TransactionAuthenticatorSingleSender.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for TransactionAuthenticator: ${index}`);\n    }\n  }\n};\nvar TransactionAuthenticatorEd25519 = class extends TransactionAuthenticator {\n  constructor(public_key, signature) {\n    super();\n    this.public_key = public_key;\n    this.signature = signature;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(0 /* Ed25519 */);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n  static load(deserializer) {\n    const public_key = Ed25519PublicKey.deserialize(deserializer);\n    const signature = Ed25519Signature.deserialize(deserializer);\n    return new TransactionAuthenticatorEd25519(public_key, signature);\n  }\n};\nvar TransactionAuthenticatorMultiEd25519 = class extends TransactionAuthenticator {\n  constructor(public_key, signature) {\n    super();\n    this.public_key = public_key;\n    this.signature = signature;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(1 /* MultiEd25519 */);\n    this.public_key.serialize(serializer);\n    this.signature.serialize(serializer);\n  }\n  static load(deserializer) {\n    const public_key = MultiEd25519PublicKey.deserialize(deserializer);\n    const signature = MultiEd25519Signature.deserialize(deserializer);\n    return new TransactionAuthenticatorMultiEd25519(public_key, signature);\n  }\n};\nvar TransactionAuthenticatorMultiAgent = class extends TransactionAuthenticator {\n  constructor(sender, secondary_signer_addresses, secondary_signers) {\n    super();\n    this.sender = sender;\n    this.secondary_signer_addresses = secondary_signer_addresses;\n    this.secondary_signers = secondary_signers;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(2 /* MultiAgent */);\n    this.sender.serialize(serializer);\n    serializer.serializeVector(this.secondary_signer_addresses);\n    serializer.serializeVector(this.secondary_signers);\n  }\n  static load(deserializer) {\n    const sender = AccountAuthenticator.deserialize(deserializer);\n    const secondary_signer_addresses = deserializer.deserializeVector(AccountAddress);\n    const secondary_signers = deserializer.deserializeVector(AccountAuthenticator);\n    return new TransactionAuthenticatorMultiAgent(sender, secondary_signer_addresses, secondary_signers);\n  }\n};\nvar TransactionAuthenticatorFeePayer = class extends TransactionAuthenticator {\n  constructor(sender, secondary_signer_addresses, secondary_signers, fee_payer) {\n    super();\n    this.sender = sender;\n    this.secondary_signer_addresses = secondary_signer_addresses;\n    this.secondary_signers = secondary_signers;\n    this.fee_payer = fee_payer;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(3 /* FeePayer */);\n    this.sender.serialize(serializer);\n    serializer.serializeVector(this.secondary_signer_addresses);\n    serializer.serializeVector(this.secondary_signers);\n    this.fee_payer.address.serialize(serializer);\n    this.fee_payer.authenticator.serialize(serializer);\n  }\n  static load(deserializer) {\n    const sender = AccountAuthenticator.deserialize(deserializer);\n    const secondary_signer_addresses = deserializer.deserializeVector(AccountAddress);\n    const secondary_signers = deserializer.deserializeVector(AccountAuthenticator);\n    const address = AccountAddress.deserialize(deserializer);\n    const authenticator = AccountAuthenticator.deserialize(deserializer);\n    const fee_payer = {\n      address,\n      authenticator\n    };\n    return new TransactionAuthenticatorFeePayer(sender, secondary_signer_addresses, secondary_signers, fee_payer);\n  }\n};\nvar TransactionAuthenticatorSingleSender = class extends TransactionAuthenticator {\n  constructor(sender) {\n    super();\n    this.sender = sender;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(4 /* SingleSender */);\n    this.sender.serialize(serializer);\n  }\n  static load(deserializer) {\n    const sender = AccountAuthenticator.deserialize(deserializer);\n    return new TransactionAuthenticatorSingleSender(sender);\n  }\n};\n\n// src/transactions/instances/chainId.ts\nvar ChainId = class extends Serializable {\n  constructor(chainId) {\n    super();\n    this.chainId = chainId;\n  }\n  serialize(serializer) {\n    serializer.serializeU8(this.chainId);\n  }\n  static deserialize(deserializer) {\n    const chainId = deserializer.deserializeU8();\n    return new ChainId(chainId);\n  }\n};\n\n// src/transactions/instances/identifier.ts\nvar Identifier = class extends Serializable {\n  constructor(identifier) {\n    super();\n    this.identifier = identifier;\n  }\n  serialize(serializer) {\n    serializer.serializeStr(this.identifier);\n  }\n  static deserialize(deserializer) {\n    const identifier = deserializer.deserializeStr();\n    return new Identifier(identifier);\n  }\n};\n\n// src/transactions/instances/moduleId.ts\nvar ModuleId = class extends Serializable {\n  constructor(address, name) {\n    super();\n    this.address = address;\n    this.name = name;\n  }\n  static fromStr(moduleId) {\n    const parts = moduleId.split(\"::\");\n    if (parts.length !== 2) {\n      throw new Error(\"Invalid module id.\");\n    }\n    return new ModuleId(AccountAddress.fromString(parts[0]), new Identifier(parts[1]));\n  }\n  serialize(serializer) {\n    this.address.serialize(serializer);\n    this.name.serialize(serializer);\n  }\n  static deserialize(deserializer) {\n    const address = AccountAddress.deserialize(deserializer);\n    const name = Identifier.deserialize(deserializer);\n    return new ModuleId(address, name);\n  }\n};\n\n// src/transactions/typeTag/index.ts\nvar TypeTag = class extends Serializable {\n  static deserialize(deserializer) {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case 0 /* Bool */:\n        return TypeTagBool.load(deserializer);\n      case 1 /* U8 */:\n        return TypeTagU8.load(deserializer);\n      case 2 /* U64 */:\n        return TypeTagU64.load(deserializer);\n      case 3 /* U128 */:\n        return TypeTagU128.load(deserializer);\n      case 4 /* Address */:\n        return TypeTagAddress.load(deserializer);\n      case 5 /* Signer */:\n        return TypeTagSigner.load(deserializer);\n      case 6 /* Vector */:\n        return TypeTagVector.load(deserializer);\n      case 7 /* Struct */:\n        return TypeTagStruct.load(deserializer);\n      case 8 /* U16 */:\n        return TypeTagU16.load(deserializer);\n      case 9 /* U32 */:\n        return TypeTagU32.load(deserializer);\n      case 10 /* U256 */:\n        return TypeTagU256.load(deserializer);\n      case 255 /* Generic */:\n        return TypeTagGeneric.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for TypeTag: ${index}`);\n    }\n  }\n  isBool() {\n    return this instanceof TypeTagBool;\n  }\n  isAddress() {\n    return this instanceof TypeTagAddress;\n  }\n  isGeneric() {\n    return this instanceof TypeTagGeneric;\n  }\n  isSigner() {\n    return this instanceof TypeTagSigner;\n  }\n  isVector() {\n    return this instanceof TypeTagVector;\n  }\n  isStruct() {\n    return this instanceof TypeTagStruct;\n  }\n  isU8() {\n    return this instanceof TypeTagU8;\n  }\n  isU16() {\n    return this instanceof TypeTagU16;\n  }\n  isU32() {\n    return this instanceof TypeTagU32;\n  }\n  isU64() {\n    return this instanceof TypeTagU64;\n  }\n  isU128() {\n    return this instanceof TypeTagU128;\n  }\n  isU256() {\n    return this instanceof TypeTagU256;\n  }\n};\nvar TypeTagBool = class extends TypeTag {\n  toString() {\n    return \"bool\";\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(0 /* Bool */);\n  }\n  static load(_deserializer) {\n    return new TypeTagBool();\n  }\n};\nvar TypeTagU8 = class extends TypeTag {\n  toString() {\n    return \"u8\";\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(1 /* U8 */);\n  }\n  static load(_deserializer) {\n    return new TypeTagU8();\n  }\n};\nvar TypeTagU16 = class extends TypeTag {\n  toString() {\n    return \"u16\";\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(8 /* U16 */);\n  }\n  static load(_deserializer) {\n    return new TypeTagU16();\n  }\n};\nvar TypeTagU32 = class extends TypeTag {\n  toString() {\n    return \"u32\";\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(9 /* U32 */);\n  }\n  static load(_deserializer) {\n    return new TypeTagU32();\n  }\n};\nvar TypeTagU64 = class extends TypeTag {\n  toString() {\n    return \"u64\";\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(2 /* U64 */);\n  }\n  static load(_deserializer) {\n    return new TypeTagU64();\n  }\n};\nvar TypeTagU128 = class extends TypeTag {\n  toString() {\n    return \"u128\";\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(3 /* U128 */);\n  }\n  static load(_deserializer) {\n    return new TypeTagU128();\n  }\n};\nvar TypeTagU256 = class extends TypeTag {\n  toString() {\n    return \"u256\";\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(10 /* U256 */);\n  }\n  static load(_deserializer) {\n    return new TypeTagU256();\n  }\n};\nvar TypeTagAddress = class extends TypeTag {\n  toString() {\n    return \"address\";\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(4 /* Address */);\n  }\n  static load(_deserializer) {\n    return new TypeTagAddress();\n  }\n};\nvar TypeTagSigner = class extends TypeTag {\n  toString() {\n    return \"signer\";\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(5 /* Signer */);\n  }\n  static load(_deserializer) {\n    return new TypeTagSigner();\n  }\n};\nvar TypeTagReference = class extends TypeTag {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  toString() {\n    return `&${this.value.toString()}`;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(254 /* Reference */);\n  }\n  static load(deserializer) {\n    const value = TypeTag.deserialize(deserializer);\n    return new TypeTagReference(value);\n  }\n};\nvar TypeTagGeneric = class extends TypeTag {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  toString() {\n    return `T${this.value}`;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(255 /* Generic */);\n    serializer.serializeU32(this.value);\n  }\n  static load(deserializer) {\n    const value = deserializer.deserializeU32();\n    return new TypeTagGeneric(value);\n  }\n};\nvar TypeTagVector = class extends TypeTag {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  toString() {\n    return `vector<${this.value.toString()}>`;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(6 /* Vector */);\n    this.value.serialize(serializer);\n  }\n  static load(deserializer) {\n    const value = TypeTag.deserialize(deserializer);\n    return new TypeTagVector(value);\n  }\n};\nvar TypeTagStruct = class extends TypeTag {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  toString() {\n    let typePredicate = \"\";\n    if (this.value.type_args.length > 0) {\n      typePredicate = `<${this.value.type_args.map(typeArg => typeArg.toString()).join(\", \")}>`;\n    }\n    return `${this.value.address.toString()}::${this.value.module_name.identifier}::${this.value.name.identifier}${typePredicate}`;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(7 /* Struct */);\n    this.value.serialize(serializer);\n  }\n  static load(deserializer) {\n    const value = StructTag.deserialize(deserializer);\n    return new TypeTagStruct(value);\n  }\n  isTypeTag(address, moduleName, structName) {\n    return this.value.module_name.identifier === moduleName && this.value.name.identifier === structName && this.value.address.equals(address);\n  }\n  isString() {\n    return this.isTypeTag(AccountAddress.ONE, \"string\", \"String\");\n  }\n  isOption() {\n    return this.isTypeTag(AccountAddress.ONE, \"option\", \"Option\");\n  }\n  isObject() {\n    return this.isTypeTag(AccountAddress.ONE, \"object\", \"Object\");\n  }\n};\nvar StructTag = class extends Serializable {\n  constructor(address, module_name, name, type_args) {\n    super();\n    this.address = address;\n    this.module_name = module_name;\n    this.name = name;\n    this.type_args = type_args;\n  }\n  serialize(serializer) {\n    serializer.serialize(this.address);\n    serializer.serialize(this.module_name);\n    serializer.serialize(this.name);\n    serializer.serializeVector(this.type_args);\n  }\n  static deserialize(deserializer) {\n    const address = AccountAddress.deserialize(deserializer);\n    const moduleName = Identifier.deserialize(deserializer);\n    const name = Identifier.deserialize(deserializer);\n    const typeArgs = deserializer.deserializeVector(TypeTag);\n    return new StructTag(address, moduleName, name, typeArgs);\n  }\n};\nfunction aptosCoinStructTag() {\n  return new StructTag(AccountAddress.ONE, new Identifier(\"aptos_coin\"), new Identifier(\"AptosCoin\"), []);\n}\nfunction stringStructTag() {\n  return new StructTag(AccountAddress.ONE, new Identifier(\"string\"), new Identifier(\"String\"), []);\n}\nfunction optionStructTag(typeArg) {\n  return new StructTag(AccountAddress.ONE, new Identifier(\"option\"), new Identifier(\"Option\"), [typeArg]);\n}\nfunction objectStructTag(typeArg) {\n  return new StructTag(AccountAddress.ONE, new Identifier(\"object\"), new Identifier(\"Object\"), [typeArg]);\n}\n\n// src/transactions/instances/transactionPayload.ts\nfunction deserializeFromScriptArgument(deserializer) {\n  const index = deserializer.deserializeUleb128AsU32();\n  switch (index) {\n    case 0 /* U8 */:\n      return U8.deserialize(deserializer);\n    case 1 /* U64 */:\n      return U64.deserialize(deserializer);\n    case 2 /* U128 */:\n      return U128.deserialize(deserializer);\n    case 3 /* Address */:\n      return AccountAddress.deserialize(deserializer);\n    case 4 /* U8Vector */:\n      return MoveVector.deserialize(deserializer, U8);\n    case 5 /* Bool */:\n      return Bool.deserialize(deserializer);\n    case 6 /* U16 */:\n      return U16.deserialize(deserializer);\n    case 7 /* U32 */:\n      return U32.deserialize(deserializer);\n    case 8 /* U256 */:\n      return U256.deserialize(deserializer);\n    default:\n      throw new Error(`Unknown variant index for ScriptTransactionArgument: ${index}`);\n  }\n}\nvar TransactionPayload = class extends Serializable {\n  static deserialize(deserializer) {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case 0 /* Script */:\n        return TransactionPayloadScript.load(deserializer);\n      case 2 /* EntryFunction */:\n        return TransactionPayloadEntryFunction.load(deserializer);\n      case 3 /* Multisig */:\n        return TransactionPayloadMultisig.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for TransactionPayload: ${index}`);\n    }\n  }\n};\nvar TransactionPayloadScript = class extends TransactionPayload {\n  constructor(script) {\n    super();\n    this.script = script;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(0 /* Script */);\n    this.script.serialize(serializer);\n  }\n  static load(deserializer) {\n    const script = Script.deserialize(deserializer);\n    return new TransactionPayloadScript(script);\n  }\n};\nvar TransactionPayloadEntryFunction = class extends TransactionPayload {\n  constructor(entryFunction) {\n    super();\n    this.entryFunction = entryFunction;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(2 /* EntryFunction */);\n    this.entryFunction.serialize(serializer);\n  }\n  static load(deserializer) {\n    const entryFunction = EntryFunction.deserialize(deserializer);\n    return new TransactionPayloadEntryFunction(entryFunction);\n  }\n};\nvar TransactionPayloadMultisig = class extends TransactionPayload {\n  constructor(multiSig) {\n    super();\n    this.multiSig = multiSig;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(3 /* Multisig */);\n    this.multiSig.serialize(serializer);\n  }\n  static load(deserializer) {\n    const multiSig = MultiSig.deserialize(deserializer);\n    return new TransactionPayloadMultisig(multiSig);\n  }\n};\nvar EntryFunction = class {\n  constructor(module_name, function_name, type_args, args) {\n    this.module_name = module_name;\n    this.function_name = function_name;\n    this.type_args = type_args;\n    this.args = args;\n  }\n  static build(module_id, function_name, type_args, args) {\n    return new EntryFunction(ModuleId.fromStr(module_id), new Identifier(function_name), type_args, args);\n  }\n  serialize(serializer) {\n    this.module_name.serialize(serializer);\n    this.function_name.serialize(serializer);\n    serializer.serializeVector(this.type_args);\n    serializer.serializeU32AsUleb128(this.args.length);\n    this.args.forEach(item => {\n      item.serializeForEntryFunction(serializer);\n    });\n  }\n  static deserialize(deserializer) {\n    const module_name = ModuleId.deserialize(deserializer);\n    const function_name = Identifier.deserialize(deserializer);\n    const type_args = deserializer.deserializeVector(TypeTag);\n    const length = deserializer.deserializeUleb128AsU32();\n    const args = new Array();\n    for (let i = 0; i < length; i += 1) {\n      const fixedBytesLength = deserializer.deserializeUleb128AsU32();\n      const fixedBytes = EntryFunctionBytes.deserialize(deserializer, fixedBytesLength);\n      args.push(fixedBytes);\n    }\n    return new EntryFunction(module_name, function_name, type_args, args);\n  }\n};\nvar Script = class {\n  constructor(bytecode, type_args, args) {\n    this.bytecode = bytecode;\n    this.type_args = type_args;\n    this.args = args;\n  }\n  serialize(serializer) {\n    serializer.serializeBytes(this.bytecode);\n    serializer.serializeVector(this.type_args);\n    serializer.serializeU32AsUleb128(this.args.length);\n    this.args.forEach(item => {\n      item.serializeForScriptFunction(serializer);\n    });\n  }\n  static deserialize(deserializer) {\n    const bytecode = deserializer.deserializeBytes();\n    const type_args = deserializer.deserializeVector(TypeTag);\n    const length = deserializer.deserializeUleb128AsU32();\n    const args = new Array();\n    for (let i = 0; i < length; i += 1) {\n      const scriptArgument = deserializeFromScriptArgument(deserializer);\n      args.push(scriptArgument);\n    }\n    return new Script(bytecode, type_args, args);\n  }\n};\nvar MultiSig = class {\n  constructor(multisig_address, transaction_payload) {\n    this.multisig_address = multisig_address;\n    this.transaction_payload = transaction_payload;\n  }\n  serialize(serializer) {\n    this.multisig_address.serialize(serializer);\n    if (this.transaction_payload === void 0) {\n      serializer.serializeBool(false);\n    } else {\n      serializer.serializeBool(true);\n      this.transaction_payload.serialize(serializer);\n    }\n  }\n  static deserialize(deserializer) {\n    const multisig_address = AccountAddress.deserialize(deserializer);\n    const payloadPresent = deserializer.deserializeBool();\n    let transaction_payload;\n    if (payloadPresent) {\n      transaction_payload = MultisigTransactionPayload.deserialize(deserializer);\n    }\n    return new MultiSig(multisig_address, transaction_payload);\n  }\n};\nvar MultisigTransactionPayload = class {\n  constructor(transaction_payload) {\n    this.transaction_payload = transaction_payload;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(0);\n    this.transaction_payload.serialize(serializer);\n  }\n  static deserialize(deserializer) {\n    deserializer.deserializeUleb128AsU32();\n    return new MultisigTransactionPayload(EntryFunction.deserialize(deserializer));\n  }\n};\n\n// src/transactions/instances/rawTransaction.ts\nvar RawTransaction = class extends Serializable {\n  constructor(sender, sequence_number, payload, max_gas_amount, gas_unit_price, expiration_timestamp_secs, chain_id) {\n    super();\n    this.sender = sender;\n    this.sequence_number = sequence_number;\n    this.payload = payload;\n    this.max_gas_amount = max_gas_amount;\n    this.gas_unit_price = gas_unit_price;\n    this.expiration_timestamp_secs = expiration_timestamp_secs;\n    this.chain_id = chain_id;\n  }\n  serialize(serializer) {\n    this.sender.serialize(serializer);\n    serializer.serializeU64(this.sequence_number);\n    this.payload.serialize(serializer);\n    serializer.serializeU64(this.max_gas_amount);\n    serializer.serializeU64(this.gas_unit_price);\n    serializer.serializeU64(this.expiration_timestamp_secs);\n    this.chain_id.serialize(serializer);\n  }\n  static deserialize(deserializer) {\n    const sender = AccountAddress.deserialize(deserializer);\n    const sequence_number = deserializer.deserializeU64();\n    const payload = TransactionPayload.deserialize(deserializer);\n    const max_gas_amount = deserializer.deserializeU64();\n    const gas_unit_price = deserializer.deserializeU64();\n    const expiration_timestamp_secs = deserializer.deserializeU64();\n    const chain_id = ChainId.deserialize(deserializer);\n    return new RawTransaction(sender, sequence_number, payload, max_gas_amount, gas_unit_price, expiration_timestamp_secs, chain_id);\n  }\n};\nvar RawTransactionWithData = class extends Serializable {\n  static deserialize(deserializer) {\n    const index = deserializer.deserializeUleb128AsU32();\n    switch (index) {\n      case 0 /* MultiAgentTransaction */:\n        return MultiAgentRawTransaction.load(deserializer);\n      case 1 /* FeePayerTransaction */:\n        return FeePayerRawTransaction.load(deserializer);\n      default:\n        throw new Error(`Unknown variant index for RawTransactionWithData: ${index}`);\n    }\n  }\n};\nvar MultiAgentRawTransaction = class extends RawTransactionWithData {\n  constructor(raw_txn, secondary_signer_addresses) {\n    super();\n    this.raw_txn = raw_txn;\n    this.secondary_signer_addresses = secondary_signer_addresses;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(0 /* MultiAgentTransaction */);\n    this.raw_txn.serialize(serializer);\n    serializer.serializeVector(this.secondary_signer_addresses);\n  }\n  static load(deserializer) {\n    const rawTxn = RawTransaction.deserialize(deserializer);\n    const secondarySignerAddresses = deserializer.deserializeVector(AccountAddress);\n    return new MultiAgentRawTransaction(rawTxn, secondarySignerAddresses);\n  }\n};\nvar FeePayerRawTransaction = class extends RawTransactionWithData {\n  constructor(raw_txn, secondary_signer_addresses, fee_payer_address) {\n    super();\n    this.raw_txn = raw_txn;\n    this.secondary_signer_addresses = secondary_signer_addresses;\n    this.fee_payer_address = fee_payer_address;\n  }\n  serialize(serializer) {\n    serializer.serializeU32AsUleb128(1 /* FeePayerTransaction */);\n    this.raw_txn.serialize(serializer);\n    serializer.serializeVector(this.secondary_signer_addresses);\n    this.fee_payer_address.serialize(serializer);\n  }\n  static load(deserializer) {\n    const rawTxn = RawTransaction.deserialize(deserializer);\n    const secondarySignerAddresses = deserializer.deserializeVector(AccountAddress);\n    const feePayerAddress = AccountAddress.deserialize(deserializer);\n    return new FeePayerRawTransaction(rawTxn, secondarySignerAddresses, feePayerAddress);\n  }\n};\n\n// src/transactions/instances/signedTransaction.ts\nvar SignedTransaction = class extends Serializable {\n  constructor(raw_txn, authenticator) {\n    super();\n    this.raw_txn = raw_txn;\n    this.authenticator = authenticator;\n  }\n  serialize(serializer) {\n    this.raw_txn.serialize(serializer);\n    this.authenticator.serialize(serializer);\n  }\n  static deserialize(deserializer) {\n    const raw_txn = RawTransaction.deserialize(deserializer);\n    const authenticator = TransactionAuthenticator.deserialize(deserializer);\n    return new SignedTransaction(raw_txn, authenticator);\n  }\n};\n\n// src/transactions/typeTag/parser.ts\nfunction isValidIdentifier(str) {\n  return !!str.match(/^[_a-zA-Z0-9]+$/);\n}\nfunction isValidWhitespaceCharacter(char) {\n  return !!char.match(/\\s/);\n}\nfunction consumeWhitespace(tagStr, pos) {\n  let i = pos;\n  for (; i < tagStr.length; i += 1) {\n    const innerChar = tagStr[i];\n    if (!isValidWhitespaceCharacter(innerChar)) {\n      break;\n    }\n  }\n  return i;\n}\nvar TypeTagParserErrorType = /* @__PURE__ */(TypeTagParserErrorType2 => {\n  TypeTagParserErrorType2[\"InvalidTypeTag\"] = \"unknown type\";\n  TypeTagParserErrorType2[\"UnexpectedTypeArgumentClose\"] = \"unexpected '>'\";\n  TypeTagParserErrorType2[\"UnexpectedWhitespaceCharacter\"] = \"unexpected whitespace character\";\n  TypeTagParserErrorType2[\"UnexpectedComma\"] = \"unexpected ','\";\n  TypeTagParserErrorType2[\"TypeArgumentCountMismatch\"] = \"type argument count doesn't match expected amount\";\n  TypeTagParserErrorType2[\"MissingTypeArgumentClose\"] = \"no matching '>' for '<'\";\n  TypeTagParserErrorType2[\"UnexpectedPrimitiveTypeArguments\"] = \"primitive types not expected to have type arguments\";\n  TypeTagParserErrorType2[\"UnexpectedVectorTypeArgumentCount\"] = \"vector type expected to have exactly one type argument\";\n  TypeTagParserErrorType2[\"UnexpectedStructFormat\"] = \"unexpected struct format, must be of the form 0xaddress::module_name::struct_name\";\n  TypeTagParserErrorType2[\"InvalidModuleNameCharacter\"] = \"module name must only contain alphanumeric or '_' characters\";\n  TypeTagParserErrorType2[\"InvalidStructNameCharacter\"] = \"struct name must only contain alphanumeric or '_' characters\";\n  return TypeTagParserErrorType2;\n})(TypeTagParserErrorType || {});\nvar TypeTagParserError = class extends Error {\n  constructor(typeTagStr, invalidReason) {\n    super(`Failed to parse typeTag '${typeTagStr}', ${invalidReason}`);\n  }\n};\nfunction parseTypeTag(typeStr, options) {\n  var _a;\n  const allowGenerics = (_a = options == null ? void 0 : options.allowGenerics) != null ? _a : false;\n  const saved = [];\n  let innerTypes = [];\n  let curTypes = [];\n  let cur = 0;\n  let currentStr = \"\";\n  let expectedTypes = 1;\n  while (cur < typeStr.length) {\n    const char = typeStr[cur];\n    if (char === \"<\") {\n      saved.push({\n        savedExpectedTypes: expectedTypes,\n        savedStr: currentStr,\n        savedTypes: curTypes\n      });\n      currentStr = \"\";\n      curTypes = [];\n      expectedTypes = 1;\n    } else if (char === \">\") {\n      if (currentStr !== \"\") {\n        const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);\n        curTypes.push(newType);\n      }\n      const savedPop = saved.pop();\n      if (savedPop === void 0) {\n        throw new TypeTagParserError(typeStr, \"unexpected '>'\" /* UnexpectedTypeArgumentClose */);\n      }\n      if (expectedTypes !== curTypes.length) {\n        throw new TypeTagParserError(typeStr, \"type argument count doesn't match expected amount\" /* TypeArgumentCountMismatch */);\n      }\n      const {\n        savedStr,\n        savedTypes,\n        savedExpectedTypes\n      } = savedPop;\n      innerTypes = curTypes;\n      curTypes = savedTypes;\n      currentStr = savedStr;\n      expectedTypes = savedExpectedTypes;\n    } else if (char === \",\") {\n      if (currentStr.length !== 0) {\n        const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);\n        innerTypes = [];\n        curTypes.push(newType);\n        currentStr = \"\";\n        expectedTypes += 1;\n      }\n    } else if (isValidWhitespaceCharacter(char)) {\n      let parsedTypeTag = false;\n      if (currentStr.length !== 0) {\n        const newType = parseTypeTagInner(currentStr, innerTypes, allowGenerics);\n        innerTypes = [];\n        curTypes.push(newType);\n        currentStr = \"\";\n        parsedTypeTag = true;\n      }\n      cur = consumeWhitespace(typeStr, cur);\n      const nextChar = typeStr[cur];\n      if (cur < typeStr.length && parsedTypeTag && nextChar !== \",\" && nextChar !== \">\") {\n        throw new TypeTagParserError(typeStr, \"unexpected whitespace character\" /* UnexpectedWhitespaceCharacter */);\n      }\n      continue;\n    } else {\n      currentStr += char;\n    }\n    cur += 1;\n  }\n  if (saved.length > 0) {\n    throw new TypeTagParserError(typeStr, \"no matching '>' for '<'\" /* MissingTypeArgumentClose */);\n  }\n  switch (curTypes.length) {\n    case 0:\n      return parseTypeTagInner(currentStr, innerTypes, allowGenerics);\n    case 1:\n      if (currentStr === \"\") {\n        return curTypes[0];\n      }\n      throw new TypeTagParserError(typeStr, \"unexpected ','\" /* UnexpectedComma */);\n    default:\n      throw new TypeTagParserError(typeStr, \"unexpected whitespace character\" /* UnexpectedWhitespaceCharacter */);\n  }\n}\nfunction parseTypeTagInner(str, types, allowGenerics) {\n  switch (str) {\n    case \"&signer\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, \"primitive types not expected to have type arguments\" /* UnexpectedPrimitiveTypeArguments */);\n      }\n      return new TypeTagReference(new TypeTagSigner());\n    case \"signer\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, \"primitive types not expected to have type arguments\" /* UnexpectedPrimitiveTypeArguments */);\n      }\n      return new TypeTagSigner();\n    case \"bool\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, \"primitive types not expected to have type arguments\" /* UnexpectedPrimitiveTypeArguments */);\n      }\n      return new TypeTagBool();\n    case \"address\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, \"primitive types not expected to have type arguments\" /* UnexpectedPrimitiveTypeArguments */);\n      }\n      return new TypeTagAddress();\n    case \"u8\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, \"primitive types not expected to have type arguments\" /* UnexpectedPrimitiveTypeArguments */);\n      }\n      return new TypeTagU8();\n    case \"u16\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, \"primitive types not expected to have type arguments\" /* UnexpectedPrimitiveTypeArguments */);\n      }\n      return new TypeTagU16();\n    case \"u32\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, \"primitive types not expected to have type arguments\" /* UnexpectedPrimitiveTypeArguments */);\n      }\n      return new TypeTagU32();\n    case \"u64\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, \"primitive types not expected to have type arguments\" /* UnexpectedPrimitiveTypeArguments */);\n      }\n      return new TypeTagU64();\n    case \"u128\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, \"primitive types not expected to have type arguments\" /* UnexpectedPrimitiveTypeArguments */);\n      }\n      return new TypeTagU128();\n    case \"u256\":\n      if (types.length > 0) {\n        throw new TypeTagParserError(str, \"primitive types not expected to have type arguments\" /* UnexpectedPrimitiveTypeArguments */);\n      }\n      return new TypeTagU256();\n    case \"vector\":\n      if (types.length !== 1) {\n        throw new TypeTagParserError(str, \"vector type expected to have exactly one type argument\" /* UnexpectedVectorTypeArgumentCount */);\n      }\n      return new TypeTagVector(types[0]);\n    default:\n      if (allowGenerics && str.match(/^T[0-9]+$/)) {\n        return new TypeTagGeneric(Number(str.split(\"T\")[1]));\n      }\n      if (!str.match(/.*:.*/)) {\n        throw new TypeTagParserError(str, \"unknown type\" /* InvalidTypeTag */);\n      }\n      const structParts = str.split(\"::\");\n      if (structParts.length !== 3) {\n        throw new TypeTagParserError(str, \"unexpected struct format, must be of the form 0xaddress::module_name::struct_name\" /* UnexpectedStructFormat */);\n      }\n      if (!isValidIdentifier(structParts[1])) {\n        throw new TypeTagParserError(str, \"module name must only contain alphanumeric or '_' characters\" /* InvalidModuleNameCharacter */);\n      }\n      if (!isValidIdentifier(structParts[2])) {\n        throw new TypeTagParserError(str, \"struct name must only contain alphanumeric or '_' characters\" /* InvalidStructNameCharacter */);\n      }\n      return new TypeTagStruct(new StructTag(AccountAddress.fromString(structParts[0]), new Identifier(structParts[1]), new Identifier(structParts[2]), types));\n  }\n}\n\n// src/transactions/transactionBuilder/helpers.ts\nfunction isBool(arg) {\n  return typeof arg === \"boolean\";\n}\nfunction isString(arg) {\n  return typeof arg === \"string\";\n}\nfunction isNumber(arg) {\n  return typeof arg === \"number\";\n}\nfunction isLargeNumber(arg) {\n  return typeof arg === \"number\" || typeof arg === \"bigint\" || typeof arg === \"string\";\n}\nfunction isNull(arg) {\n  return arg === null || arg === void 0;\n}\nfunction isBcsBool(arg) {\n  return arg instanceof Bool;\n}\nfunction isBcsAddress(arg) {\n  return arg instanceof AccountAddress;\n}\nfunction isBcsString(arg) {\n  return arg instanceof MoveString;\n}\nfunction isBcsFixedBytes(arg) {\n  return arg instanceof FixedBytes;\n}\nfunction isBcsU8(arg) {\n  return arg instanceof U8;\n}\nfunction isBcsU16(arg) {\n  return arg instanceof U16;\n}\nfunction isBcsU32(arg) {\n  return arg instanceof U32;\n}\nfunction isBcsU64(arg) {\n  return arg instanceof U64;\n}\nfunction isBcsU128(arg) {\n  return arg instanceof U128;\n}\nfunction isBcsU256(arg) {\n  return arg instanceof U256;\n}\nfunction isScriptDataInput(arg) {\n  return \"bytecode\" in arg;\n}\nfunction throwTypeMismatch(expectedType, position) {\n  throw new Error(`Type mismatch for argument ${position}, expected '${expectedType}'`);\n}\nfunction findFirstNonSignerArg(functionAbi) {\n  return functionAbi.params.findIndex(param => param !== \"signer\" && param !== \"&signer\");\n}\nfunction getFunctionParts(functionArg) {\n  const funcNameParts = functionArg.split(\"::\");\n  if (funcNameParts.length !== 3) {\n    throw new Error(`Invalid function ${functionArg}`);\n  }\n  const moduleAddress = funcNameParts[0];\n  const moduleName = funcNameParts[1];\n  const functionName = funcNameParts[2];\n  return {\n    moduleAddress,\n    moduleName,\n    functionName\n  };\n}\n\n// src/transactions/transactionBuilder/remoteAbi.ts\nfunction standardizeTypeTags(typeArguments) {\n  var _a;\n  return (_a = typeArguments == null ? void 0 : typeArguments.map(typeArg => {\n    if (isString(typeArg)) {\n      return parseTypeTag(typeArg);\n    }\n    return typeArg;\n  })) != null ? _a : [];\n}\nasync function fetchEntryFunctionAbi(moduleAddress, moduleName, functionName, aptosConfig) {\n  var _a;\n  const module = await getModule({\n    aptosConfig,\n    accountAddress: moduleAddress,\n    moduleName\n  });\n  const functionAbi = (_a = module.abi) == null ? void 0 : _a.exposed_functions.find(func => func.name === functionName);\n  if (!functionAbi) {\n    throw new Error(`Could not find entry function ABI for '${moduleAddress}::${moduleName}::${functionName}'`);\n  }\n  if (!functionAbi.is_entry) {\n    throw new Error(`'${moduleAddress}::${moduleName}::${functionName}' is not an entry function`);\n  }\n  const first = findFirstNonSignerArg(functionAbi);\n  const params = [];\n  for (let i = first; i < functionAbi.params.length; i += 1) {\n    params.push(parseTypeTag(functionAbi.params[i], {\n      allowGenerics: true\n    }));\n  }\n  return {\n    typeParameters: functionAbi.generic_type_params,\n    parameters: params\n  };\n}\nfunction convertArgument(functionName, functionAbi, arg, position, genericTypeParams) {\n  if (position >= functionAbi.parameters.length) {\n    throw new Error(`Too many arguments for '${functionName}', expected ${functionAbi.parameters.length}`);\n  }\n  if (isBcsBool(arg) || isBcsU8(arg) || isBcsU16(arg) || isBcsU32(arg) || isBcsU64(arg) || isBcsU128(arg) || isBcsU256(arg) || isBcsAddress(arg) || isBcsString(arg) || isBcsFixedBytes(arg) || arg instanceof MoveVector || arg instanceof MoveOption) {\n    checkType(functionAbi, arg, position);\n    return arg;\n  }\n  return parseArg(arg, functionAbi.parameters[position], position, genericTypeParams);\n}\nfunction parseArg(arg, param, position, genericTypeParams) {\n  if (param.isBool()) {\n    if (isBool(arg)) {\n      return new Bool(arg);\n    }\n    throwTypeMismatch(\"boolean\", position);\n  }\n  if (param.isAddress()) {\n    if (isString(arg)) {\n      return AccountAddress.fromString(arg);\n    }\n    throwTypeMismatch(\"string\", position);\n  }\n  if (param.isU8()) {\n    if (isNumber(arg)) {\n      return new U8(arg);\n    }\n    throwTypeMismatch(\"number\", position);\n  }\n  if (param.isU16()) {\n    if (isNumber(arg)) {\n      return new U16(arg);\n    }\n    throwTypeMismatch(\"number\", position);\n  }\n  if (param.isU32()) {\n    if (isNumber(arg)) {\n      return new U32(arg);\n    }\n    throwTypeMismatch(\"number\", position);\n  }\n  if (param.isU64()) {\n    if (isLargeNumber(arg)) {\n      return new U64(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n  if (param.isU128()) {\n    if (isLargeNumber(arg)) {\n      return new U128(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n  if (param.isU256()) {\n    if (isLargeNumber(arg)) {\n      return new U256(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n  if (param.isGeneric()) {\n    const genericIndex = param.value;\n    if (genericIndex < 0 || genericIndex >= genericTypeParams.length) {\n      throw new Error(`Generic argument ${param.toString()} is invalid for argument ${position}`);\n    }\n    parseArg(arg, genericTypeParams[genericIndex], position, genericTypeParams);\n  }\n  if (param.isVector()) {\n    if (param.value.isU8() && isString(arg)) {\n      return MoveVector.U8(Hex.fromHexInput(arg).toUint8Array());\n    }\n    if (Array.isArray(arg)) {\n      return new MoveVector(arg.map(item => parseArg(item, param.value, position, genericTypeParams)));\n    }\n    throw new Error(`Type mismatch for argument ${position}, type '${param.toString()}'`);\n  }\n  if (param.isStruct()) {\n    if (param.isString()) {\n      if (isString(arg)) {\n        return new MoveString(arg);\n      }\n      throwTypeMismatch(\"string\", position);\n    }\n    if (param.isObject()) {\n      if (isString(arg)) {\n        return AccountAddress.fromString(arg);\n      }\n      throwTypeMismatch(\"string\", position);\n    }\n    if (param.isOption()) {\n      if (isNull(arg)) {\n        return new MoveOption(null);\n      }\n      return new MoveOption(parseArg(arg, param.value.type_args[0], position, genericTypeParams));\n    }\n    throw new Error(`Unsupported struct input type for argument ${position}, type '${param.toString()}'`);\n  }\n  throw new Error(`Type mismatch for argument ${position}, type '${param.toString()}'`);\n}\nfunction checkType(functionAbi, arg, position) {\n  const param = functionAbi.parameters[position];\n  if (param.isBool()) {\n    if (isBcsBool(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"Bool\", position);\n  }\n  if (param.isAddress()) {\n    if (isBcsAddress(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"AccountAddress\", position);\n  }\n  if (param.isU8()) {\n    if (isBcsU8(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U8\", position);\n  }\n  if (param.isU16()) {\n    if (isBcsU16(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U16\", position);\n  }\n  if (param.isU32()) {\n    if (isBcsU32(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U32\", position);\n  }\n  if (param.isU64()) {\n    if (isBcsU64(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U64\", position);\n  }\n  if (param.isU128()) {\n    if (isBcsU128(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U128\", position);\n  }\n  if (param.isU256()) {\n    if (isBcsU256(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U256\", position);\n  }\n  if (param.isVector()) {\n    if (arg instanceof MoveVector) {\n      return;\n    }\n    throwTypeMismatch(\"MoveVector\", position);\n  }\n  if (param instanceof TypeTagStruct) {\n    if (param.isString()) {\n      if (isBcsString(arg)) {\n        return;\n      }\n      throwTypeMismatch(\"MoveString\", position);\n    }\n    if (param.isObject()) {\n      if (isBcsAddress(arg)) {\n        return;\n      }\n      throwTypeMismatch(\"AccountAddress\", position);\n    }\n    if (param.isOption()) {\n      if (arg instanceof MoveOption) {\n        return;\n      }\n      throwTypeMismatch(\"MoveOption\", position);\n    }\n  }\n  throw new Error(`Type mismatch for argument ${position}, expected '${param.toString()}'`);\n}\n\n// src/transactions/transactionBuilder/transactionBuilder.ts\nasync function generateTransactionPayload(args) {\n  if (isScriptDataInput(args)) {\n    return generateTransactionPayloadScript(args);\n  }\n  const {\n    moduleAddress,\n    moduleName,\n    functionName\n  } = getFunctionParts(args.function);\n  const functionAbi = await memoizeAsync(async () => fetchEntryFunctionAbi(moduleAddress, moduleName, functionName, args.aptosConfig), `entry-function-${args.aptosConfig.network}-${moduleAddress}-${moduleName}-${functionName}`, 1e3 * 60 * 5)();\n  return generateTransactionPayloadWithABI(args, functionAbi);\n}\nfunction generateTransactionPayloadWithABI(args, functionAbi) {\n  if (isScriptDataInput(args)) {\n    return generateTransactionPayloadScript(args);\n  }\n  const {\n    moduleAddress,\n    moduleName,\n    functionName\n  } = getFunctionParts(args.function);\n  const typeArguments = standardizeTypeTags(args.typeArguments);\n  if (typeArguments.length !== functionAbi.typeParameters.length) {\n    throw new Error(`Type argument count mismatch, expected ${functionAbi.typeParameters.length}, received ${typeArguments.length}`);\n  }\n  const functionArguments = args.functionArguments.map((arg, i) => convertArgument(args.function, functionAbi, arg, i, typeArguments));\n  if (functionArguments.length !== functionAbi.parameters.length) {\n    throw new Error(`Too few arguments for '${moduleAddress}::${moduleName}::${functionName}', expected ${functionAbi.parameters.length} but got ${functionArguments.length}`);\n  }\n  const entryFunctionPayload = EntryFunction.build(`${moduleAddress}::${moduleName}`, functionName, typeArguments, functionArguments);\n  if (\"multisigAddress\" in args) {\n    let multisigAddress;\n    if (typeof args.multisigAddress === \"string\") {\n      multisigAddress = AccountAddress.fromString(args.multisigAddress);\n    } else {\n      multisigAddress = args.multisigAddress;\n    }\n    return new TransactionPayloadMultisig(new MultiSig(multisigAddress, new MultisigTransactionPayload(entryFunctionPayload)));\n  }\n  return new TransactionPayloadEntryFunction(entryFunctionPayload);\n}\nfunction generateTransactionPayloadScript(args) {\n  var _a;\n  return new TransactionPayloadScript(new Script(Hex.fromHexInput(args.bytecode).toUint8Array(), (_a = args.typeArguments) != null ? _a : [], args.functionArguments));\n}\nasync function generateRawTransaction(args) {\n  const {\n    aptosConfig,\n    sender,\n    payload,\n    options\n  } = args;\n  const getSequenceNumber = (options == null ? void 0 : options.accountSequenceNumber) ? Promise.resolve({\n    sequence_number: options.accountSequenceNumber\n  }) : getInfo({\n    aptosConfig,\n    accountAddress: sender\n  });\n  const getChainId = NetworkToChainId[aptosConfig.network] ? Promise.resolve({\n    chain_id: NetworkToChainId[aptosConfig.network]\n  }) : getLedgerInfo({\n    aptosConfig\n  });\n  const getGasUnitPrice = (options == null ? void 0 : options.gasUnitPrice) ? Promise.resolve({\n    gas_estimate: options.gasUnitPrice\n  }) : getGasPriceEstimation({\n    aptosConfig\n  });\n  const [{\n    sequence_number: sequenceNumber\n  }, {\n    chain_id: chainId\n  }, {\n    gas_estimate: gasEstimate\n  }] = await Promise.all([getSequenceNumber, getChainId, getGasUnitPrice]);\n  const {\n    maxGasAmount,\n    gasUnitPrice,\n    expireTimestamp\n  } = {\n    maxGasAmount: BigInt(DEFAULT_MAX_GAS_AMOUNT),\n    gasUnitPrice: BigInt(gasEstimate),\n    expireTimestamp: BigInt(Math.floor(Date.now() / 1e3) + DEFAULT_TXN_EXP_SEC_FROM_NOW),\n    ...options\n  };\n  return new RawTransaction(AccountAddress.fromHexInput(sender), BigInt(sequenceNumber), payload, BigInt(maxGasAmount), BigInt(gasUnitPrice), BigInt(expireTimestamp), new ChainId(chainId));\n}\nasync function buildTransaction(args) {\n  const {\n    aptosConfig,\n    sender,\n    payload,\n    options,\n    secondarySignerAddresses,\n    feePayerAddress\n  } = args;\n  const rawTxn = await generateRawTransaction({\n    aptosConfig,\n    sender,\n    payload,\n    options\n  });\n  if (feePayerAddress) {\n    const signers = secondarySignerAddresses ? secondarySignerAddresses.map(signer => AccountAddress.fromHexInput(signer)) : [];\n    return {\n      rawTransaction: rawTxn.bcsToBytes(),\n      secondarySignerAddresses: signers,\n      feePayerAddress: AccountAddress.fromHexInput(feePayerAddress)\n    };\n  }\n  if (secondarySignerAddresses) {\n    const signers = secondarySignerAddresses.map(signer => AccountAddress.fromHexInput(signer));\n    return {\n      rawTransaction: rawTxn.bcsToBytes(),\n      secondarySignerAddresses: signers\n    };\n  }\n  return {\n    rawTransaction: rawTxn.bcsToBytes()\n  };\n}\nfunction generateSignedTransactionForSimulation(args) {\n  var _a, _b;\n  const {\n    signerPublicKey,\n    transaction,\n    secondarySignersPublicKeys,\n    feePayerPublicKey\n  } = args;\n  const deserializer = new Deserializer(transaction.rawTransaction);\n  const deserializedTransaction = RawTransaction.deserialize(deserializer);\n  const accountAuthenticator = getAuthenticatorForSimulation(signerPublicKey);\n  if (transaction.feePayerAddress) {\n    const transactionToSign = new FeePayerRawTransaction(deserializedTransaction, (_a = transaction.secondarySignerAddresses) != null ? _a : [], transaction.feePayerAddress);\n    let secondaryAccountAuthenticators = [];\n    if (secondarySignersPublicKeys) {\n      secondaryAccountAuthenticators = secondarySignersPublicKeys.map(publicKey => getAuthenticatorForSimulation(publicKey));\n    }\n    const feePayerAuthenticator = getAuthenticatorForSimulation(feePayerPublicKey);\n    const transactionAuthenticator2 = new TransactionAuthenticatorFeePayer(accountAuthenticator, (_b = transaction.secondarySignerAddresses) != null ? _b : [], secondaryAccountAuthenticators, {\n      address: transaction.feePayerAddress,\n      authenticator: feePayerAuthenticator\n    });\n    return new SignedTransaction(transactionToSign.raw_txn, transactionAuthenticator2).bcsToBytes();\n  }\n  if (transaction.secondarySignerAddresses) {\n    const transactionToSign = new MultiAgentRawTransaction(deserializedTransaction, transaction.secondarySignerAddresses);\n    let secondaryAccountAuthenticators = [];\n    secondaryAccountAuthenticators = secondarySignersPublicKeys.map(publicKey => getAuthenticatorForSimulation(publicKey));\n    const transactionAuthenticator2 = new TransactionAuthenticatorMultiAgent(accountAuthenticator, transaction.secondarySignerAddresses, secondaryAccountAuthenticators);\n    return new SignedTransaction(transactionToSign.raw_txn, transactionAuthenticator2).bcsToBytes();\n  }\n  let transactionAuthenticator;\n  if (accountAuthenticator instanceof AccountAuthenticatorEd25519) {\n    transactionAuthenticator = new TransactionAuthenticatorEd25519(accountAuthenticator.public_key, accountAuthenticator.signature);\n  } else if (accountAuthenticator instanceof AccountAuthenticatorSingleKey) {\n    transactionAuthenticator = new TransactionAuthenticatorSingleSender(accountAuthenticator);\n  } else {\n    throw new Error(\"Invalid public key\");\n  }\n  return new SignedTransaction(deserializedTransaction, transactionAuthenticator).bcsToBytes();\n}\nfunction getAuthenticatorForSimulation(publicKey) {\n  if (publicKey instanceof AnyPublicKey) {\n    if (publicKey.publicKey instanceof Ed25519PublicKey) {\n      return new AccountAuthenticatorSingleKey(publicKey, new AnySignature(new Ed25519Signature(new Uint8Array(64))));\n    }\n    if (publicKey.publicKey instanceof Secp256k1PublicKey) {\n      return new AccountAuthenticatorSingleKey(publicKey, new AnySignature(new Secp256k1Signature(new Uint8Array(64))));\n    }\n  }\n  return new AccountAuthenticatorEd25519(new Ed25519PublicKey(publicKey.toUint8Array()), new Ed25519Signature(new Uint8Array(64)));\n}\nfunction sign(args) {\n  const {\n    signer,\n    transaction\n  } = args;\n  const transactionToSign = deriveTransactionType(transaction);\n  const message = getSigningMessage(transactionToSign);\n  const signerSignature = signer.sign(message);\n  switch (signer.signingScheme) {\n    case 0 /* Ed25519 */:\n      return new AccountAuthenticatorEd25519(new Ed25519PublicKey(signer.publicKey.toUint8Array()), new Ed25519Signature(signerSignature.toUint8Array()));\n    case 2 /* SingleKey */:\n      return new AccountAuthenticatorSingleKey(signer.publicKey, new AnySignature(signerSignature));\n    default:\n      throw new Error(`Cannot sign transaction, signing scheme ${signer.signingScheme} not supported`);\n  }\n}\nfunction generateSignedTransaction(args) {\n  const {\n    transaction,\n    senderAuthenticator,\n    secondarySignerAuthenticators\n  } = args;\n  const transactionToSubmit = deriveTransactionType(transaction);\n  if (secondarySignerAuthenticators) {\n    return generateMultiSignersSignedTransaction(transactionToSubmit, senderAuthenticator, secondarySignerAuthenticators);\n  }\n  if (senderAuthenticator instanceof AccountAuthenticatorEd25519) {\n    const transactionAuthenticator = new TransactionAuthenticatorEd25519(senderAuthenticator.public_key, senderAuthenticator.signature);\n    return new SignedTransaction(transactionToSubmit, transactionAuthenticator).bcsToBytes();\n  }\n  if (senderAuthenticator instanceof AccountAuthenticatorSingleKey || senderAuthenticator instanceof AccountAuthenticatorMultiKey) {\n    const transactionAuthenticator = new TransactionAuthenticatorSingleSender(senderAuthenticator);\n    return new SignedTransaction(transactionToSubmit, transactionAuthenticator).bcsToBytes();\n  }\n  throw new Error(`Cannot generate a signed transaction, ${senderAuthenticator} is not a supported account authentication scheme`);\n}\nfunction deriveTransactionType(transaction) {\n  var _a;\n  const deserializer = new Deserializer(transaction.rawTransaction);\n  const deserializedTransaction = RawTransaction.deserialize(deserializer);\n  if (transaction.feePayerAddress) {\n    return new FeePayerRawTransaction(deserializedTransaction, (_a = transaction.secondarySignerAddresses) != null ? _a : [], transaction.feePayerAddress);\n  }\n  if (transaction.secondarySignerAddresses) {\n    return new MultiAgentRawTransaction(deserializedTransaction, transaction.secondarySignerAddresses);\n  }\n  return deserializedTransaction;\n}\nfunction generateMultiSignersSignedTransaction(transaction, senderAuthenticator, secondarySignerAuthenticators) {\n  if (transaction instanceof FeePayerRawTransaction) {\n    if (!secondarySignerAuthenticators.feePayerAuthenticator) {\n      throw new Error(\"Must provide a feePayerAuthenticator argument to generate a signed fee payer transaction\");\n    }\n    const {\n      feePayerAuthenticator,\n      additionalSignersAuthenticators\n    } = secondarySignerAuthenticators;\n    const txAuthenticatorFeePayer = new TransactionAuthenticatorFeePayer(senderAuthenticator, transaction.secondary_signer_addresses, additionalSignersAuthenticators != null ? additionalSignersAuthenticators : [], {\n      address: transaction.fee_payer_address,\n      authenticator: feePayerAuthenticator\n    });\n    return new SignedTransaction(transaction.raw_txn, txAuthenticatorFeePayer).bcsToBytes();\n  }\n  if (transaction instanceof MultiAgentRawTransaction) {\n    if (!secondarySignerAuthenticators.additionalSignersAuthenticators) {\n      throw new Error(\"Must provide a additionalSignersAuthenticators argument to generate a signed multi agent transaction\");\n    }\n    const {\n      additionalSignersAuthenticators\n    } = secondarySignerAuthenticators;\n    const multiAgentAuthenticator = new TransactionAuthenticatorMultiAgent(senderAuthenticator, transaction.secondary_signer_addresses, additionalSignersAuthenticators != null ? additionalSignersAuthenticators : []);\n    return new SignedTransaction(transaction.raw_txn, multiAgentAuthenticator).bcsToBytes();\n  }\n  throw new Error(`Cannot prepare multi signers transaction to submission, ${typeof transaction} transaction is not supported`);\n}\nfunction getSigningMessage(rawTxn) {\n  const hash = sha3Hash2.create();\n  if (rawTxn instanceof RawTransaction) {\n    hash.update(RAW_TRANSACTION_SALT);\n  } else if (rawTxn instanceof MultiAgentRawTransaction) {\n    hash.update(RAW_TRANSACTION_WITH_DATA_SALT);\n  } else if (rawTxn instanceof FeePayerRawTransaction) {\n    hash.update(RAW_TRANSACTION_WITH_DATA_SALT);\n  } else {\n    throw new Error(`Unknown transaction type to sign on: ${rawTxn}`);\n  }\n  const prefix = hash.digest();\n  const body = rawTxn.bcsToBytes();\n  const mergedArray = new Uint8Array(prefix.length + body.length);\n  mergedArray.set(prefix);\n  mergedArray.set(body, prefix.length);\n  return mergedArray;\n}\n\n// src/internal/transactionSubmission.ts\nasync function generateTransaction(args) {\n  const {\n    aptosConfig,\n    sender,\n    data,\n    options,\n    secondarySignerAddresses,\n    feePayerAddress\n  } = args;\n  let generateTransactionPayloadData;\n  if (\"bytecode\" in data) {\n    generateTransactionPayloadData = data;\n  } else if (\"multisigAddress\" in data) {\n    generateTransactionPayloadData = {\n      aptosConfig,\n      multisigAddress: data.multisigAddress,\n      function: data.function,\n      functionArguments: data.functionArguments,\n      typeArguments: data.typeArguments\n    };\n  } else {\n    generateTransactionPayloadData = {\n      aptosConfig,\n      function: data.function,\n      functionArguments: data.functionArguments,\n      typeArguments: data.typeArguments\n    };\n  }\n  const payload = await generateTransactionPayload(generateTransactionPayloadData);\n  return buildTransaction({\n    aptosConfig,\n    sender,\n    payload,\n    options,\n    secondarySignerAddresses,\n    feePayerAddress\n  });\n}\nfunction signTransaction(args) {\n  const accountAuthenticator = sign({\n    ...args\n  });\n  return accountAuthenticator;\n}\nasync function simulateTransaction(args) {\n  var _a, _b, _c, _d, _e, _f;\n  const {\n    aptosConfig,\n    transaction,\n    signerPublicKey,\n    secondarySignersPublicKeys,\n    feePayerPublicKey,\n    options\n  } = args;\n  const signedTransaction = generateSignedTransactionForSimulation({\n    transaction,\n    signerPublicKey,\n    secondarySignersPublicKeys,\n    feePayerPublicKey,\n    options\n  });\n  const {\n    data\n  } = await postAptosFullNode({\n    aptosConfig,\n    body: signedTransaction,\n    path: \"transactions/simulate\",\n    params: {\n      estimate_gas_unit_price: (_b = (_a = args.options) == null ? void 0 : _a.estimateGasUnitPrice) != null ? _b : false,\n      estimate_max_gas_amount: (_d = (_c = args.options) == null ? void 0 : _c.estimateMaxGasAmount) != null ? _d : false,\n      estimate_prioritized_gas_unit_price: (_f = (_e = args.options) == null ? void 0 : _e.estimatePrioritizedGasUnitPrice) != null ? _f : false\n    },\n    originMethod: \"simulateTransaction\",\n    contentType: \"application/x.aptos.signed_transaction+bcs\" /* BCS_SIGNED_TRANSACTION */\n  });\n  return data;\n}\nasync function submitTransaction(args) {\n  const {\n    aptosConfig\n  } = args;\n  const signedTransaction = generateSignedTransaction({\n    ...args\n  });\n  const {\n    data\n  } = await postAptosFullNode({\n    aptosConfig,\n    body: signedTransaction,\n    path: \"transactions\",\n    originMethod: \"submitTransaction\",\n    contentType: \"application/x.aptos.signed_transaction+bcs\" /* BCS_SIGNED_TRANSACTION */\n  });\n  return data;\n}\nasync function signAndSubmitTransaction(args) {\n  const {\n    aptosConfig,\n    signer,\n    transaction\n  } = args;\n  const authenticator = signTransaction({\n    signer,\n    transaction\n  });\n  return submitTransaction({\n    aptosConfig,\n    transaction,\n    senderAuthenticator: authenticator\n  });\n}\nasync function publicPackageTransaction(args) {\n  const {\n    aptosConfig,\n    account,\n    metadataBytes,\n    moduleBytecode,\n    options\n  } = args;\n  const totalByteCode = moduleBytecode.map(bytecode => MoveVector.U8(bytecode));\n  const transaction = await generateTransaction({\n    aptosConfig,\n    sender: account,\n    data: {\n      function: \"0x1::code::publish_package_txn\",\n      functionArguments: [MoveVector.U8(metadataBytes), new MoveVector(totalByteCode)]\n    },\n    options\n  });\n  return transaction;\n}\n\n// src/internal/coin.ts\nasync function transferCoinTransaction(args) {\n  const {\n    aptosConfig,\n    sender,\n    recipient,\n    amount,\n    coinType,\n    options\n  } = args;\n  const coinStructType = coinType != null ? coinType : APTOS_COIN;\n  const transaction = await generateTransaction({\n    aptosConfig,\n    sender: sender.accountAddress.toString(),\n    data: {\n      function: \"0x1::aptos_account::transfer_coins\",\n      typeArguments: [parseTypeTag(coinStructType)],\n      functionArguments: [AccountAddress.fromHexInput(recipient), new U64(amount)]\n    },\n    options\n  });\n  return transaction;\n}\n\n// src/api/coin.ts\nvar Coin = class {\n  constructor(config) {\n    this.config = config;\n  }\n  async transferCoinTransaction(args) {\n    return transferCoinTransaction({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n};\n\n// src/internal/digitalAsset.ts\nasync function mintTokenTransaction(args) {\n  const {\n    aptosConfig,\n    options,\n    creator\n  } = args;\n  const transaction = await generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress.toString(),\n    data: {\n      function: \"0x4::aptos_token::mint\",\n      functionArguments: [new MoveString(args.collection), new MoveString(args.description), new MoveString(args.name), new MoveString(args.uri), MoveVector.MoveString([]), MoveVector.MoveString([]), new MoveVector([])]\n    },\n    options\n  });\n  return transaction;\n}\nasync function getTokenData(args) {\n  const {\n    aptosConfig,\n    tokenAddress\n  } = args;\n  const whereCondition = {\n    token_data_id: {\n      _eq: Hex.fromHexInput(tokenAddress).toString()\n    }\n  };\n  const graphqlQuery = {\n    query: GetTokenData,\n    variables: {\n      where_condition: whereCondition\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getTokenData\"\n  });\n  return data.current_token_datas_v2[0];\n}\nasync function getCurrentTokenOwnership(args) {\n  const {\n    aptosConfig,\n    tokenAddress\n  } = args;\n  const whereCondition = {\n    token_data_id: {\n      _eq: Hex.fromHexInput(tokenAddress).toString()\n    }\n  };\n  const graphqlQuery = {\n    query: GetCurrentTokenOwnership,\n    variables: {\n      where_condition: whereCondition\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getCurrentTokenOwnership\"\n  });\n  return data.current_token_ownerships_v2[0];\n}\nasync function getOwnedTokens(args) {\n  var _a, _b;\n  const {\n    aptosConfig,\n    ownerAddress,\n    options\n  } = args;\n  const whereCondition = {\n    owner_address: {\n      _eq: Hex.fromHexInput(ownerAddress).toString()\n    }\n  };\n  const graphqlQuery = {\n    query: GetCurrentTokenOwnership,\n    variables: {\n      where_condition: whereCondition,\n      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,\n      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,\n      order_by: options == null ? void 0 : options.orderBy\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getOwnedTokens\"\n  });\n  return data.current_token_ownerships_v2;\n}\nasync function getTokenActivity(args) {\n  var _a, _b;\n  const {\n    aptosConfig,\n    tokenAddress,\n    options\n  } = args;\n  const whereCondition = {\n    token_data_id: {\n      _eq: Hex.fromHexInput(tokenAddress).toString()\n    }\n  };\n  const graphqlQuery = {\n    query: GetTokenActivity,\n    variables: {\n      where_condition: whereCondition,\n      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,\n      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,\n      order_by: options == null ? void 0 : options.orderBy\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getTokenActivity\"\n  });\n  return data.token_activities_v2;\n}\nasync function createCollectionTransaction(args) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;\n  const {\n    aptosConfig,\n    options,\n    creator\n  } = args;\n  const transaction = await generateTransaction({\n    aptosConfig,\n    sender: creator.accountAddress.toString(),\n    data: {\n      function: \"0x4::aptos_token::create_collection\",\n      functionArguments: [new MoveString(args.description), new U64((_a = args.maxSupply) != null ? _a : MAX_U64_BIG_INT), new MoveString(args.name), new MoveString(args.uri), new Bool((_b = args.mutableDescription) != null ? _b : true), new Bool((_c = args.mutableRoyalty) != null ? _c : true), new Bool((_d = args.mutableURI) != null ? _d : true), new Bool((_e = args.mutableTokenDescription) != null ? _e : true), new Bool((_f = args.mutableTokenName) != null ? _f : true), new Bool((_g = args.mutableTokenProperties) != null ? _g : true), new Bool((_h = args.mutableTokenURI) != null ? _h : true), new Bool((_i = args.tokensBurnableByCreator) != null ? _i : true), new Bool((_j = args.tokensFreezableByCreator) != null ? _j : true), new U64((_k = args.royaltyNumerator) != null ? _k : 0), new U64((_l = args.royaltyDenominator) != null ? _l : 1)]\n    },\n    options\n  });\n  return transaction;\n}\nasync function getCollectionData(args) {\n  var _a;\n  const {\n    aptosConfig,\n    creatorAddress,\n    collectionName,\n    options\n  } = args;\n  const address = Hex.fromHexInput(creatorAddress).toString();\n  const whereCondition = {\n    collection_name: {\n      _eq: collectionName\n    },\n    creator_address: {\n      _eq: address\n    }\n  };\n  if (options == null ? void 0 : options.tokenStandard) {\n    whereCondition.token_standard = {\n      _eq: (_a = options == null ? void 0 : options.tokenStandard) != null ? _a : \"v2\"\n    };\n  }\n  const graphqlQuery = {\n    query: GetCollectionData,\n    variables: {\n      where_condition: whereCondition\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getCollectionData\"\n  });\n  return data.current_collections_v2[0];\n}\nasync function getCollectionId(args) {\n  return (await getCollectionData(args)).collection_id;\n}\n\n// src/api/digitalAsset.ts\nvar DigitalAsset = class {\n  constructor(config) {\n    this.config = config;\n  }\n  async createCollectionTransaction(args) {\n    return createCollectionTransaction({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getCollectionData(args) {\n    return getCollectionData({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getCollectionId(args) {\n    return getCollectionId({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async mintTokenTransaction(args) {\n    return mintTokenTransaction({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getTokenData(args) {\n    return getTokenData({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getCurrentTokenOwnership(args) {\n    return getCurrentTokenOwnership({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getOwnedTokens(args) {\n    return getOwnedTokens({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getTokenActivity(args) {\n    return getTokenActivity({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n};\n\n// src/internal/event.ts\nasync function getAccountEventsByCreationNumber(args) {\n  const {\n    accountAddress,\n    aptosConfig,\n    creationNumber\n  } = args;\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n  const whereCondition = {\n    account_address: {\n      _eq: address\n    },\n    creation_number: {\n      _eq: creationNumber\n    }\n  };\n  return getEvents({\n    aptosConfig,\n    options: {\n      where: whereCondition\n    }\n  });\n}\nasync function getAccountEventsByEventType(args) {\n  const {\n    accountAddress,\n    aptosConfig,\n    eventType,\n    options\n  } = args;\n  const address = AccountAddress.fromHexInput(accountAddress).toString();\n  const whereCondition = {\n    account_address: {\n      _eq: address\n    },\n    type: {\n      _eq: eventType\n    }\n  };\n  const customOptions = {\n    where: whereCondition,\n    pagination: options == null ? void 0 : options.pagination,\n    orderBy: options == null ? void 0 : options.orderBy\n  };\n  return getEvents({\n    aptosConfig,\n    options: customOptions\n  });\n}\nasync function getEvents(args) {\n  var _a, _b;\n  const {\n    aptosConfig,\n    options\n  } = args;\n  const graphqlQuery = {\n    query: GetEvents,\n    variables: {\n      where_condition: options == null ? void 0 : options.where,\n      offset: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.offset,\n      limit: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.limit,\n      order_by: options == null ? void 0 : options.orderBy\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getEvents\"\n  });\n  return data.events;\n}\n\n// src/api/event.ts\nvar Event = class {\n  constructor(config) {\n    this.config = config;\n  }\n  async getAccountEventsByCreationNumber(args) {\n    return getAccountEventsByCreationNumber({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getAccountEventsByEventType(args) {\n    return getAccountEventsByEventType({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getEvents(args) {\n    return getEvents({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n};\n\n// src/internal/faucet.ts\nasync function fundAccount(args) {\n  const {\n    aptosConfig,\n    accountAddress,\n    amount,\n    options\n  } = args;\n  const timeout = (options == null ? void 0 : options.timeoutSecs) || DEFAULT_TXN_TIMEOUT_SEC;\n  const {\n    data\n  } = await postAptosFaucet({\n    aptosConfig,\n    path: \"fund\",\n    body: {\n      address: AccountAddress.fromHexInput(accountAddress).toString(),\n      amount\n    },\n    originMethod: \"fundAccount\"\n  });\n  const txnHash = data.txn_hashes[0];\n  await waitForTransaction({\n    aptosConfig,\n    transactionHash: txnHash,\n    options: {\n      timeoutSecs: timeout,\n      checkSuccess: options == null ? void 0 : options.checkSuccess,\n      indexerVersionCheck: options == null ? void 0 : options.indexerVersionCheck\n    }\n  });\n  return txnHash;\n}\n\n// src/api/faucet.ts\nvar Faucet = class {\n  constructor(config) {\n    this.config = config;\n  }\n  async fundAccount(args) {\n    return fundAccount({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n};\n\n// src/internal/fungibleAsset.ts\nasync function getFungibleAssetMetadata(args) {\n  var _a, _b;\n  const {\n    aptosConfig,\n    options\n  } = args;\n  const graphqlQuery = {\n    query: GetFungibleAssetMetadata,\n    variables: {\n      where_condition: options == null ? void 0 : options.where,\n      limit: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.limit,\n      offset: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.offset\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getFungibleAssetMetadata\"\n  });\n  return data.fungible_asset_metadata;\n}\nasync function getFungibleAssetActivities(args) {\n  var _a, _b;\n  const {\n    aptosConfig,\n    options\n  } = args;\n  const graphqlQuery = {\n    query: GetFungibleAssetActivities,\n    variables: {\n      where_condition: options == null ? void 0 : options.where,\n      limit: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.limit,\n      offset: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.offset\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getFungibleAssetActivities\"\n  });\n  return data.fungible_asset_activities;\n}\nasync function getCurrentFungibleAssetBalances(args) {\n  var _a, _b;\n  const {\n    aptosConfig,\n    options\n  } = args;\n  const graphqlQuery = {\n    query: GetCurrentFungibleAssetBalances,\n    variables: {\n      where_condition: options == null ? void 0 : options.where,\n      limit: (_a = options == null ? void 0 : options.pagination) == null ? void 0 : _a.limit,\n      offset: (_b = options == null ? void 0 : options.pagination) == null ? void 0 : _b.offset\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query: graphqlQuery,\n    originMethod: \"getCurrentFungibleAssetBalances\"\n  });\n  return data.current_fungible_asset_balances;\n}\n\n// src/api/fungibleAsset.ts\nvar FungibleAsset = class {\n  constructor(config) {\n    this.config = config;\n  }\n  async getFungibleAssetMetadata(args) {\n    return getFungibleAssetMetadata({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getFungibleAssetMetadataByAssetType(assetType) {\n    const data = await getFungibleAssetMetadata({\n      aptosConfig: this.config,\n      options: {\n        where: {\n          asset_type: {\n            _eq: assetType\n          }\n        }\n      }\n    });\n    return data[0];\n  }\n  async getFungibleAssetActivities(args) {\n    return getFungibleAssetActivities({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getCurrentFungibleAssetBalances(args) {\n    return getCurrentFungibleAssetBalances({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n};\n\n// src/api/general.ts\nvar General = class {\n  constructor(config) {\n    this.config = config;\n  }\n  async getLedgerInfo() {\n    return getLedgerInfo({\n      aptosConfig: this.config\n    });\n  }\n  async getChainId() {\n    const result = await this.getLedgerInfo();\n    return result.chain_id;\n  }\n  async getBlockByVersion(args) {\n    return getBlockByVersion({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getBlockByHeight(args) {\n    return getBlockByHeight({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getTableItem(args) {\n    return getTableItem({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async view(args) {\n    return view({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getChainTopUserTransactions(args) {\n    return getChainTopUserTransactions({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async queryIndexer(args) {\n    return queryIndexer({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getIndexerLastSuccessVersion() {\n    return getIndexerLastSuccessVersion({\n      aptosConfig: this.config\n    });\n  }\n};\n\n// src/internal/staking.ts\nasync function getNumberOfDelegators(args) {\n  const {\n    aptosConfig,\n    poolAddress\n  } = args;\n  const address = Hex.fromHexInput(poolAddress).toString();\n  const query = {\n    query: GetNumberOfDelegators,\n    variables: {\n      where_condition: {\n        pool_address: {\n          _eq: address\n        }\n      }\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query\n  });\n  if (data.num_active_delegator_per_pool.length === 0) {\n    throw Error(\"Delegator pool not found\");\n  }\n  return data.num_active_delegator_per_pool[0].num_active_delegator;\n}\nasync function getNumberOfDelegatorsForAllPools(args) {\n  const {\n    aptosConfig,\n    options\n  } = args;\n  const query = {\n    query: GetNumberOfDelegators,\n    variables: {\n      where_condition: {},\n      order_by: options == null ? void 0 : options.orderBy\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query\n  });\n  return data.num_active_delegator_per_pool;\n}\nasync function getDelegatedStakingActivities(args) {\n  const {\n    aptosConfig,\n    delegatorAddress,\n    poolAddress\n  } = args;\n  const query = {\n    query: GetDelegatedStakingActivities,\n    variables: {\n      delegatorAddress: Hex.fromHexInput(delegatorAddress).toString(),\n      poolAddress: Hex.fromHexInput(poolAddress).toString()\n    }\n  };\n  const data = await queryIndexer({\n    aptosConfig,\n    query\n  });\n  return data.delegated_staking_activities;\n}\n\n// src/api/staking.ts\nvar Staking = class {\n  constructor(config) {\n    this.config = config;\n  }\n  async getNumberOfDelegators(args) {\n    return getNumberOfDelegators({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getNumberOfDelegatorsForAllPools(args) {\n    return getNumberOfDelegatorsForAllPools({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getDelegatedStakingActivities(args) {\n    return getDelegatedStakingActivities({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n};\n\n// src/api/transaction.ts\nvar Transaction = class {\n  constructor(config) {\n    this.config = config;\n  }\n  async getTransactions(args) {\n    return getTransactions2({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getTransactionByVersion(args) {\n    return getTransactionByVersion({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getTransactionByHash(args) {\n    return getTransactionByHash({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async isPendingTransaction(args) {\n    return isTransactionPending({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async waitForTransaction(args) {\n    return waitForTransaction({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async getGasPriceEstimation() {\n    return getGasPriceEstimation({\n      aptosConfig: this.config\n    });\n  }\n};\n\n// src/api/transactionSubmission.ts\nvar TransactionSubmission = class {\n  constructor(config) {\n    this.config = config;\n  }\n  async generateTransaction(args) {\n    return generateTransaction({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  signTransaction(args) {\n    return signTransaction({\n      ...args\n    });\n  }\n  async simulateTransaction(args) {\n    return simulateTransaction({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async submitTransaction(args) {\n    return submitTransaction({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n  async signAndSubmitTransaction(args) {\n    const {\n      signer,\n      transaction\n    } = args;\n    return signAndSubmitTransaction({\n      aptosConfig: this.config,\n      signer,\n      transaction\n    });\n  }\n  async publishPackageTransaction(args) {\n    return publicPackageTransaction({\n      aptosConfig: this.config,\n      ...args\n    });\n  }\n};\n\n// src/api/aptos.ts\nvar Aptos = class {\n  constructor(settings) {\n    this.config = new AptosConfig(settings);\n    this.account = new Account2(this.config);\n    this.coin = new Coin(this.config);\n    this.digitalAsset = new DigitalAsset(this.config);\n    this.event = new Event(this.config);\n    this.faucet = new Faucet(this.config);\n    this.fungibleAsset = new FungibleAsset(this.config);\n    this.general = new General(this.config);\n    this.staking = new Staking(this.config);\n    this.transaction = new Transaction(this.config);\n    this.transactionSubmission = new TransactionSubmission(this.config);\n  }\n};\nfunction applyMixin(targetClass, baseClass, baseClassProp) {\n  Object.getOwnPropertyNames(baseClass.prototype).forEach(propertyName => {\n    const propertyDescriptor = Object.getOwnPropertyDescriptor(baseClass.prototype, propertyName);\n    if (!propertyDescriptor) return;\n    propertyDescriptor.value = function (...args) {\n      return this[baseClassProp][propertyName](...args);\n    };\n    Object.defineProperty(targetClass.prototype, propertyName, propertyDescriptor);\n  });\n}\napplyMixin(Aptos, Account2, \"account\");\napplyMixin(Aptos, Coin, \"coin\");\napplyMixin(Aptos, DigitalAsset, \"digitalAsset\");\napplyMixin(Aptos, Event, \"event\");\napplyMixin(Aptos, Faucet, \"faucet\");\napplyMixin(Aptos, FungibleAsset, \"fungibleAsset\");\napplyMixin(Aptos, General, \"general\");\napplyMixin(Aptos, Staking, \"staking\");\napplyMixin(Aptos, Transaction, \"transaction\");\napplyMixin(Aptos, TransactionSubmission, \"transactionSubmission\");\nexport { APTOS_PATH_REGEX, Account, AccountAddress, AccountAuthenticator, AccountAuthenticatorEd25519, AccountAuthenticatorMultiEd25519, AccountAuthenticatorMultiKey, AccountAuthenticatorSingleKey, AccountAuthenticatorVariant, AddressInvalidReason, AnyPublicKeyVariant, AnySignatureVariant, Aptos, AptosApiError, AptosConfig, AuthenticationKey, Bool, ChainId, DeriveScheme, Deserializer, Ed25519PrivateKey, Ed25519PublicKey, Ed25519Signature, EntryFunction, EntryFunctionBytes, FeePayerRawTransaction, FixedBytes, Hex, HexInvalidReason, Identifier, KeyType, MimeType, ModuleId, MoveAbility, MoveFunctionVisibility, MoveOption, MoveString, MoveVector, MultiAgentRawTransaction, MultiEd25519PublicKey, MultiEd25519Signature, MultiKey, MultiSig, MultisigTransactionPayload, Network, NetworkToChainId, NetworkToFaucetAPI, NetworkToIndexerAPI, NetworkToNodeAPI, ParsingError, PrivateKey, PublicKey, RawTransaction, RawTransactionWithData, RoleType, Script, ScriptTransactionArgumentVariants, Secp256k1PrivateKey, Secp256k1PublicKey, Secp256k1Signature, Serializable, Serializer, Signature, SignedTransaction, SigningScheme, SigningSchemeInput, StructTag, TransactionAuthenticator, TransactionAuthenticatorEd25519, TransactionAuthenticatorFeePayer, TransactionAuthenticatorMultiAgent, TransactionAuthenticatorMultiEd25519, TransactionAuthenticatorSingleSender, TransactionAuthenticatorVariant, TransactionPayload, TransactionPayloadEntryFunction, TransactionPayloadMultisig, TransactionPayloadScript, TransactionPayloadVariants, TransactionResponseType, TransactionVariants, TypeTag, TypeTagAddress, TypeTagBool, TypeTagGeneric, TypeTagParserError, TypeTagParserErrorType, TypeTagReference, TypeTagSigner, TypeTagStruct, TypeTagU128, TypeTagU16, TypeTagU256, TypeTagU32, TypeTagU64, TypeTagU8, TypeTagVariants, TypeTagVector, U128, U16, U256, U32, U64, U8, aptosCoinStructTag, aptosRequest, buildTransaction, convertArgument, derivePrivateKeyFromMnemonic, deriveTransactionType, deserializeFromScriptArgument, ensureBoolean, fetchEntryFunctionAbi, findFirstNonSignerArg, generateMultiSignersSignedTransaction, generateRawTransaction, generateSignedTransaction, generateSignedTransactionForSimulation, generateTransactionPayload, generateTransactionPayloadWithABI, get, getAptosFullNode, getAuthenticatorForSimulation, getFunctionParts, getSigningMessage, isBcsAddress, isBcsBool, isBcsFixedBytes, isBcsString, isBcsU128, isBcsU16, isBcsU256, isBcsU32, isBcsU64, isBcsU8, isBool, isLargeNumber, isNull, isNumber, isScriptDataInput, isString, isValidPath, objectStructTag, optionStructTag, outOfRangeErrorMessage, paginateWithCursor, parseTypeTag, post, postAptosFaucet, postAptosFullNode, postAptosIndexer, request, sign, standardizeTypeTags, stringStructTag, throwTypeMismatch, validateNumberInRange };\n//# sourceMappingURL=index.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}