{"ast":null,"code":"var _s = $RefreshSig$();\n// useRecommendations.js - Hook for AI-powered investment recommendations\nimport { useState, useEffect, useCallback, useContext } from 'react';\nimport { useWalletContext } from './useWallet';\nimport { usePortfolio } from './usePortfolio';\nimport { NotificationContext } from '../context/NotificationContext';\nimport { TransactionContext } from '../context/TransactionContext';\nimport api from '../services/api';\nimport { showToast } from '../utils/animations';\nimport { trackRecommendation } from '../utils/analyticsUtils';\n\n/**\r\n * Hook for working with AI-powered investment recommendations\r\n */\nconst useRecommendations = () => {\n  _s();\n  const {\n    address\n  } = useWalletContext();\n  const {\n    totalValue,\n    portfolioData\n  } = usePortfolio();\n  const {\n    showNotification\n  } = useContext(NotificationContext);\n  const {\n    executeStrategy: executeStrategyTx\n  } = useContext(TransactionContext);\n\n  // Recommendation states\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [recommendation, setRecommendation] = useState(null);\n  const [recommendationHistory, setRecommendationHistory] = useState([]);\n  const [generatingRecommendation, setGeneratingRecommendation] = useState(false);\n  const [executingRecommendation, setExecutingRecommendation] = useState(false);\n  const [executionResult, setExecutionResult] = useState(null);\n\n  // Form states\n  const [amount, setAmount] = useState(() => {\n    // Initialize with portfolio value if available, otherwise default to 100\n    return totalValue > 0 ? Math.floor(totalValue) : 100;\n  });\n  const [riskProfile, setRiskProfile] = useState(() => {\n    // Try to get stored preference or default to 'balanced'\n    return localStorage.getItem('defaultRiskProfile') || 'balanced';\n  });\n  const [preserveStakedPositions, setPreserveStakedPositions] = useState(true);\n\n  // Update the amount when totalValue changes\n  useEffect(() => {\n    if (totalValue > 0 && !amount) {\n      setAmount(Math.floor(totalValue));\n    }\n  }, [totalValue, amount]);\n\n  // Load recommendation history from localStorage\n  useEffect(() => {\n    try {\n      const storedHistory = localStorage.getItem('aiRecommendationsHistory');\n      if (storedHistory) {\n        const parsedHistory = JSON.parse(storedHistory);\n        if (Array.isArray(parsedHistory)) {\n          setRecommendationHistory(parsedHistory);\n        }\n      }\n    } catch (err) {\n      console.error('Failed to load recommendation history:', err);\n    }\n  }, []);\n\n  /**\r\n   * Generate a new AI recommendation based on current settings\r\n   */\n  const generateRecommendation = useCallback(async (amountParam, riskProfileParam, options = {}) => {\n    // Use provided params or current state values\n    const amountToUse = amountParam !== undefined ? amountParam : amount;\n    const riskProfileToUse = riskProfileParam || riskProfile;\n    setIsLoading(true);\n    setGeneratingRecommendation(true);\n    setError(null);\n    try {\n      // Build query parameters\n      const params = {\n        amount: amountToUse,\n        riskProfile: riskProfileToUse,\n        preserveStakedPositions: options.preserveStakedPositions !== undefined ? options.preserveStakedPositions : preserveStakedPositions\n      };\n\n      // Add wallet address if available\n      if (address) {\n        params.walletAddress = address;\n      }\n\n      // Add optional parameters\n      if (options.includeMemeTokens) {\n        params.includeMemeTokens = true;\n      }\n      if (options.maxProtocols) {\n        params.maxProtocols = options.maxProtocols;\n      }\n      if (options.preferredProtocols) {\n        params.preferredProtocols = options.preferredProtocols.join(',');\n      }\n\n      // Show notification\n      showToast({\n        message: 'Generating AI recommendation...',\n        type: 'info',\n        duration: 3000\n      });\n\n      // Request recommendation from API\n      const response = await api.get('/api/recommendations/ai', {\n        params\n      });\n      const newRecommendation = response.data;\n\n      // Update state\n      setRecommendation(newRecommendation);\n\n      // Add to history\n      addToRecommendationHistory(newRecommendation);\n\n      // Save preferences\n      localStorage.setItem('lastInvestmentAmount', amountToUse.toString());\n      localStorage.setItem('defaultRiskProfile', riskProfileToUse);\n\n      // Show success notification\n      showToast({\n        message: 'AI recommendation generated successfully',\n        type: 'success',\n        duration: 3000\n      });\n\n      // Track recommendation\n      trackRecommendation(riskProfileToUse, amountToUse, true);\n      return newRecommendation;\n    } catch (err) {\n      var _err$response, _err$response$data, _err$response2, _err$response2$data;\n      console.error('Error generating recommendation:', err);\n      setError(((_err$response = err.response) === null || _err$response === void 0 ? void 0 : (_err$response$data = _err$response.data) === null || _err$response$data === void 0 ? void 0 : _err$response$data.error) || 'Failed to generate recommendation');\n\n      // Show error notification\n      showToast({\n        message: `Failed to generate recommendation: ${((_err$response2 = err.response) === null || _err$response2 === void 0 ? void 0 : (_err$response2$data = _err$response2.data) === null || _err$response2$data === void 0 ? void 0 : _err$response2$data.error) || err.message || 'Unknown error'}`,\n        type: 'error',\n        duration: 5000\n      });\n\n      // Track failed recommendation\n      trackRecommendation(riskProfileToUse, amountToUse, false);\n      return null;\n    } finally {\n      setIsLoading(false);\n      setGeneratingRecommendation(false);\n    }\n  }, [amount, riskProfile, preserveStakedPositions, address, showNotification]);\n\n  /**\r\n   * Add recommendation to history\r\n   */\n  const addToRecommendationHistory = useCallback(newRecommendation => {\n    if (!newRecommendation) return;\n\n    // Add timestamp if not present\n    const recommendationWithTime = {\n      ...newRecommendation,\n      timestamp: newRecommendation.timestamp || new Date().toISOString()\n    };\n    setRecommendationHistory(prev => {\n      // Check for duplicates\n      const isDuplicate = prev.some(r => r.title === recommendationWithTime.title && JSON.stringify(r.allocation) === JSON.stringify(recommendationWithTime.allocation));\n      if (isDuplicate) return prev;\n\n      // Add to beginning of array\n      const newHistory = [recommendationWithTime, ...prev];\n\n      // Limit history size to 10 items\n      const limitedHistory = newHistory.slice(0, 10);\n\n      // Store in localStorage\n      try {\n        localStorage.setItem('aiRecommendationsHistory', JSON.stringify(limitedHistory));\n      } catch (error) {\n        console.warn('Failed to save recommendation history to localStorage:', error);\n      }\n      return limitedHistory;\n    });\n  }, []);\n\n  /**\r\n   * Execute the recommended investment strategy\r\n   */\n  const executeRecommendation = useCallback(async (recommendationToExecute = recommendation) => {\n    if (!recommendationToExecute) {\n      showToast({\n        message: 'No recommendation to execute',\n        type: 'error',\n        duration: 3000\n      });\n      return null;\n    }\n    setExecutingRecommendation(true);\n    setExecutionResult(null);\n    try {\n      var _result$operations, _result$failedOperati;\n      // Prepare operations from recommendation\n      const operations = prepareOperationsFromRecommendation(recommendationToExecute);\n      if (!operations || operations.length === 0) {\n        throw new Error('No valid operations could be prepared from the recommendation');\n      }\n\n      // Show info notification\n      showToast({\n        message: 'Preparing to execute strategy...',\n        type: 'info',\n        duration: 3000\n      });\n\n      // Execute the strategy\n      const result = await executeStrategyTx(operations);\n\n      // Update state with result\n      setExecutionResult(result);\n\n      // Show success notification\n      showToast({\n        message: result.success ? `Strategy executed successfully! ${((_result$operations = result.operations) === null || _result$operations === void 0 ? void 0 : _result$operations.length) || 0} operations completed.` : `Strategy executed with ${((_result$failedOperati = result.failedOperations) === null || _result$failedOperati === void 0 ? void 0 : _result$failedOperati.length) || 0} failures.`,\n        type: result.success ? 'success' : 'warning',\n        duration: 5000\n      });\n\n      // Update recommendation with execution result\n      const updatedRecommendation = {\n        ...recommendationToExecute,\n        executionResult: result\n      };\n\n      // Update in history\n      addToRecommendationHistory(updatedRecommendation);\n      return result;\n    } catch (err) {\n      console.error('Strategy execution error:', err);\n\n      // Set error result\n      setExecutionResult({\n        success: false,\n        error: err.message,\n        message: `Strategy execution failed: ${err.message}`\n      });\n\n      // Show error notification\n      showToast({\n        message: `Strategy execution failed: ${err.message}`,\n        type: 'error',\n        duration: 5000\n      });\n      return {\n        success: false,\n        error: err.message\n      };\n    } finally {\n      setExecutingRecommendation(false);\n    }\n  }, [recommendation, executeStrategyTx, showNotification, addToRecommendationHistory]);\n\n  /**\r\n   * Prepare operations from recommendation for execution\r\n   */\n  const prepareOperationsFromRecommendation = useCallback(recommendationData => {\n    if (!(recommendationData !== null && recommendationData !== void 0 && recommendationData.allocation)) {\n      return [];\n    }\n\n    // Get contract addresses from constants.js\n    const contractAddresses = window.contractAddresses || {\n      amnis: \"0x111ae3e5bc816a5e63c2da97d0aa3886519e0cd5e4b046659fa35796bd11542a\",\n      thala: \"0xfaf4e633ae9eb31366c9ca24214231760926576c7b625313b3688b5e900731f6\",\n      tortuga: \"0x952c1b1fc8eb75ee80f432c9d0a84fcda1d5c7481501a7eca9199f1596a60b53\",\n      ditto: \"0xd11107bdf0d6d7040c6c0bfbdecb6545191fdf13e8d8d259952f53e1713f61b5\",\n      aries: \"0x9770fa9c725cbd97eb50b2be5f7416efdfd1f1554beb0750d4dae4c64e860da3\",\n      echo: \"0xeab7ea4d635b6b6add79d5045c4a45d8148d88287b1cfa1c3b6a4b56f46839ed\",\n      pancakeswap: \"0xc7efb4076dbe143cbcd98cfaaa929ecfc8f299203dfff63b95ccb6bfe19850fa\",\n      liquidswap: \"0x190d44266241744264b964a37b8f09863167a12d3e70cda39376cfb4e3561e12\",\n      cetus: \"0x27156bd56eb5637b9adde4d915b596f92d2f28f0ade2eaef48fa73e360e4e8a6\"\n    };\n    const operations = recommendationData.allocation.map(item => {\n      // Determine operation type\n      const type = determineOperationType(item.product);\n\n      // Get contract address (normalize protocol name to lowercase)\n      const protocolLower = item.protocol.toLowerCase();\n      const contractAddress = contractAddresses[protocolLower] || null;\n\n      // If no contract address, skip this allocation\n      if (!contractAddress) {\n        console.warn(`No contract address found for protocol: ${item.protocol}`);\n        return null;\n      }\n\n      // Calculate amount if not explicitly provided\n      const calculatedAmount = item.amount || (parseFloat(recommendationData.totalInvestment || amount) * parseFloat(item.percentage || 0) / 100).toFixed(2);\n\n      // Skip if amount is invalid\n      if (isNaN(parseFloat(calculatedAmount)) || parseFloat(calculatedAmount) <= 0) {\n        console.warn(`Invalid amount for ${item.protocol}: ${calculatedAmount}`);\n        return null;\n      }\n      return {\n        protocol: item.protocol,\n        type,\n        amount: calculatedAmount,\n        contractAddress,\n        functionName: determineFunctionName(item.protocol, type),\n        expectedApr: parseFloat(item.expectedApr || 0)\n      };\n    }).filter(Boolean); // Remove null items\n\n    return operations;\n  }, [amount]);\n\n  /**\r\n   * Determine operation type based on product description\r\n   */\n  const determineOperationType = useCallback(product => {\n    if (!product) return 'stake';\n    const lower = product.toLowerCase();\n    if (lower.includes('stake') || lower.includes('stapt') || lower.includes('tapt')) {\n      return 'stake';\n    }\n    if (lower.includes('lend') || lower.includes('lending')) {\n      return 'lend';\n    }\n    if (lower.includes('liquidity') || lower.includes('amm') || lower.includes('pool')) {\n      return 'addLiquidity';\n    }\n    if (lower.includes('vault') || lower.includes('yield')) {\n      return 'deposit';\n    }\n    return 'stake'; // Default to staking\n  }, []);\n\n  /**\r\n   * Determine function name based on protocol and operation type\r\n   */\n  const determineFunctionName = useCallback((protocol, operationType) => {\n    var _functionMappings$pro;\n    const functionMappings = {\n      'amnis': {\n        'stake': '::staking::stake',\n        'unstake': '::staking::unstake',\n        'lend': '::lending::supply',\n        'withdraw': '::lending::withdraw',\n        'addLiquidity': '::router::add_liquidity',\n        'removeLiquidity': '::router::remove_liquidity'\n      },\n      'thala': {\n        'stake': '::staking::stake_apt',\n        'unstake': '::staking::unstake_apt',\n        'lend': '::lending::supply_apt',\n        'withdraw': '::lending::withdraw_apt',\n        'addLiquidity': '::router::add_liquidity',\n        'removeLiquidity': '::router::remove_liquidity'\n      },\n      'tortuga': {\n        'stake': '::staking::stake_apt',\n        'unstake': '::staking::unstake_apt'\n      },\n      'echo': {\n        'lend': '::lending::supply',\n        'withdraw': '::lending::withdraw'\n      },\n      'ditto': {\n        'stake': '::staking::stake',\n        'unstake': '::staking::unstake'\n      },\n      'aries': {\n        'lend': '::lending::supply',\n        'withdraw': '::lending::withdraw'\n      },\n      'cetus': {\n        'addLiquidity': '::pool::add_liquidity',\n        'removeLiquidity': '::pool::remove_liquidity'\n      },\n      'pancakeswap': {\n        'addLiquidity': '::router::add_liquidity',\n        'removeLiquidity': '::router::remove_liquidity',\n        'swap': '::router::swap_exact_input'\n      },\n      'liquidswap': {\n        'addLiquidity': '::router::add_liquidity',\n        'removeLiquidity': '::router::remove_liquidity'\n      }\n    };\n\n    // If we have a specific mapping for this protocol and operation type, use it\n    if ((_functionMappings$pro = functionMappings[protocol.toLowerCase()]) !== null && _functionMappings$pro !== void 0 && _functionMappings$pro[operationType]) {\n      return functionMappings[protocol.toLowerCase()][operationType];\n    }\n\n    // Otherwise use general mappings\n    switch (operationType) {\n      case 'stake':\n        return '::staking::stake';\n      case 'unstake':\n        return '::staking::unstake';\n      case 'lend':\n        return '::lending::supply';\n      case 'withdraw':\n        return '::lending::withdraw';\n      case 'addLiquidity':\n        return '::router::add_liquidity';\n      case 'removeLiquidity':\n        return '::router::remove_liquidity';\n      case 'deposit':\n        return '::yield::deposit';\n      default:\n        return `::${operationType}::execute`;\n    }\n  }, []);\n\n  /**\r\n   * Compare two recommendations to highlight differences\r\n   */\n  const compareRecommendations = useCallback((recommendation1, recommendation2) => {\n    var _recommendation1$allo, _recommendation2$allo;\n    if (!recommendation1 || !recommendation2) return null;\n    const result = {\n      aprDifference: parseFloat(recommendation2.totalApr || 0) - parseFloat(recommendation1.totalApr || 0),\n      allocationChanges: [],\n      newProtocols: [],\n      removedProtocols: [],\n      riskLevelChange: false\n    };\n\n    // Compare allocations\n    const alloc1Map = new Map();\n    (_recommendation1$allo = recommendation1.allocation) === null || _recommendation1$allo === void 0 ? void 0 : _recommendation1$allo.forEach(item => {\n      alloc1Map.set(item.protocol, item);\n    });\n\n    // Find changes and new protocols\n    (_recommendation2$allo = recommendation2.allocation) === null || _recommendation2$allo === void 0 ? void 0 : _recommendation2$allo.forEach(item => {\n      const prev = alloc1Map.get(item.protocol);\n      if (prev) {\n        // Protocol exists in both recommendations\n        if (parseFloat(prev.percentage) !== parseFloat(item.percentage)) {\n          result.allocationChanges.push({\n            protocol: item.protocol,\n            product: item.product,\n            prevPercentage: parseFloat(prev.percentage),\n            newPercentage: parseFloat(item.percentage),\n            percentageChange: parseFloat(item.percentage) - parseFloat(prev.percentage),\n            aprChange: parseFloat(item.expectedApr || 0) - parseFloat(prev.expectedApr || 0)\n          });\n        }\n        // Remove from map to track removed protocols\n        alloc1Map.delete(item.protocol);\n      } else {\n        // New protocol\n        result.newProtocols.push(item);\n      }\n    });\n\n    // Identify removed protocols\n    result.removedProtocols = Array.from(alloc1Map.values());\n\n    // Check for risk level change\n    if (recommendation1.riskProfile && recommendation2.riskProfile && recommendation1.riskProfile !== recommendation2.riskProfile) {\n      result.riskLevelChange = {\n        from: recommendation1.riskProfile,\n        to: recommendation2.riskProfile\n      };\n    }\n    return result;\n  }, []);\n  return {\n    // States\n    isLoading,\n    error,\n    recommendation,\n    recommendationHistory,\n    generatingRecommendation,\n    executingRecommendation,\n    executionResult,\n    // Form values\n    amount,\n    riskProfile,\n    preserveStakedPositions,\n    // Form setters\n    setAmount,\n    setRiskProfile,\n    setPreserveStakedPositions,\n    // Actions\n    generateRecommendation,\n    executeRecommendation,\n    compareRecommendations,\n    prepareOperationsFromRecommendation\n  };\n};\n_s(useRecommendations, \"i6INq7u+Q8eaT1WKlBKXbpUAzFQ=\", false, function () {\n  return [useWalletContext, usePortfolio];\n});\nexport default useRecommendations;","map":{"version":3,"names":["useState","useEffect","useCallback","useContext","useWalletContext","usePortfolio","NotificationContext","TransactionContext","api","showToast","trackRecommendation","useRecommendations","_s","address","totalValue","portfolioData","showNotification","executeStrategy","executeStrategyTx","isLoading","setIsLoading","error","setError","recommendation","setRecommendation","recommendationHistory","setRecommendationHistory","generatingRecommendation","setGeneratingRecommendation","executingRecommendation","setExecutingRecommendation","executionResult","setExecutionResult","amount","setAmount","Math","floor","riskProfile","setRiskProfile","localStorage","getItem","preserveStakedPositions","setPreserveStakedPositions","storedHistory","parsedHistory","JSON","parse","Array","isArray","err","console","generateRecommendation","amountParam","riskProfileParam","options","amountToUse","undefined","riskProfileToUse","params","walletAddress","includeMemeTokens","maxProtocols","preferredProtocols","join","message","type","duration","response","get","newRecommendation","data","addToRecommendationHistory","setItem","toString","_err$response","_err$response$data","_err$response2","_err$response2$data","recommendationWithTime","timestamp","Date","toISOString","prev","isDuplicate","some","r","title","stringify","allocation","newHistory","limitedHistory","slice","warn","executeRecommendation","recommendationToExecute","_result$operations","_result$failedOperati","operations","prepareOperationsFromRecommendation","length","Error","result","success","failedOperations","updatedRecommendation","recommendationData","contractAddresses","window","amnis","thala","tortuga","ditto","aries","echo","pancakeswap","liquidswap","cetus","map","item","determineOperationType","product","protocolLower","protocol","toLowerCase","contractAddress","calculatedAmount","parseFloat","totalInvestment","percentage","toFixed","isNaN","functionName","determineFunctionName","expectedApr","filter","Boolean","lower","includes","operationType","_functionMappings$pro","functionMappings","compareRecommendations","recommendation1","recommendation2","_recommendation1$allo","_recommendation2$allo","aprDifference","totalApr","allocationChanges","newProtocols","removedProtocols","riskLevelChange","alloc1Map","Map","forEach","set","push","prevPercentage","newPercentage","percentageChange","aprChange","delete","from","values","to"],"sources":["/home/ck/compoundefi/client/src/hooks/useRecommendations.js"],"sourcesContent":["// useRecommendations.js - Hook for AI-powered investment recommendations\r\nimport { useState, useEffect, useCallback, useContext } from 'react';\r\nimport { useWalletContext } from './useWallet';\r\nimport { usePortfolio } from './usePortfolio';\r\nimport { NotificationContext } from '../context/NotificationContext';\r\nimport { TransactionContext } from '../context/TransactionContext';\r\nimport api from '../services/api';\r\nimport { showToast } from '../utils/animations';\r\nimport { trackRecommendation } from '../utils/analyticsUtils';\r\n\r\n/**\r\n * Hook for working with AI-powered investment recommendations\r\n */\r\nconst useRecommendations = () => {\r\n  const { address } = useWalletContext();\r\n  const { totalValue, portfolioData } = usePortfolio();\r\n  const { showNotification } = useContext(NotificationContext);\r\n  const { executeStrategy: executeStrategyTx } = useContext(TransactionContext);\r\n  \r\n  // Recommendation states\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [error, setError] = useState(null);\r\n  const [recommendation, setRecommendation] = useState(null);\r\n  const [recommendationHistory, setRecommendationHistory] = useState([]);\r\n  const [generatingRecommendation, setGeneratingRecommendation] = useState(false);\r\n  const [executingRecommendation, setExecutingRecommendation] = useState(false);\r\n  const [executionResult, setExecutionResult] = useState(null);\r\n  \r\n  // Form states\r\n  const [amount, setAmount] = useState(() => {\r\n    // Initialize with portfolio value if available, otherwise default to 100\r\n    return totalValue > 0 ? Math.floor(totalValue) : 100;\r\n  });\r\n  \r\n  const [riskProfile, setRiskProfile] = useState(() => {\r\n    // Try to get stored preference or default to 'balanced'\r\n    return localStorage.getItem('defaultRiskProfile') || 'balanced';\r\n  });\r\n  \r\n  const [preserveStakedPositions, setPreserveStakedPositions] = useState(true);\r\n  \r\n  // Update the amount when totalValue changes\r\n  useEffect(() => {\r\n    if (totalValue > 0 && !amount) {\r\n      setAmount(Math.floor(totalValue));\r\n    }\r\n  }, [totalValue, amount]);\r\n  \r\n  // Load recommendation history from localStorage\r\n  useEffect(() => {\r\n    try {\r\n      const storedHistory = localStorage.getItem('aiRecommendationsHistory');\r\n      if (storedHistory) {\r\n        const parsedHistory = JSON.parse(storedHistory);\r\n        if (Array.isArray(parsedHistory)) {\r\n          setRecommendationHistory(parsedHistory);\r\n        }\r\n      }\r\n    } catch (err) {\r\n      console.error('Failed to load recommendation history:', err);\r\n    }\r\n  }, []);\r\n  \r\n  /**\r\n   * Generate a new AI recommendation based on current settings\r\n   */\r\n  const generateRecommendation = useCallback(async (amountParam, riskProfileParam, options = {}) => {\r\n    // Use provided params or current state values\r\n    const amountToUse = amountParam !== undefined ? amountParam : amount;\r\n    const riskProfileToUse = riskProfileParam || riskProfile;\r\n    \r\n    setIsLoading(true);\r\n    setGeneratingRecommendation(true);\r\n    setError(null);\r\n    \r\n    try {\r\n      // Build query parameters\r\n      const params = {\r\n        amount: amountToUse,\r\n        riskProfile: riskProfileToUse,\r\n        preserveStakedPositions: options.preserveStakedPositions !== undefined \r\n          ? options.preserveStakedPositions \r\n          : preserveStakedPositions\r\n      };\r\n      \r\n      // Add wallet address if available\r\n      if (address) {\r\n        params.walletAddress = address;\r\n      }\r\n      \r\n      // Add optional parameters\r\n      if (options.includeMemeTokens) {\r\n        params.includeMemeTokens = true;\r\n      }\r\n      \r\n      if (options.maxProtocols) {\r\n        params.maxProtocols = options.maxProtocols;\r\n      }\r\n      \r\n      if (options.preferredProtocols) {\r\n        params.preferredProtocols = options.preferredProtocols.join(',');\r\n      }\r\n      \r\n      // Show notification\r\n      showToast({\r\n        message: 'Generating AI recommendation...',\r\n        type: 'info',\r\n        duration: 3000\r\n      });\r\n      \r\n      // Request recommendation from API\r\n      const response = await api.get('/api/recommendations/ai', { params });\r\n      const newRecommendation = response.data;\r\n      \r\n      // Update state\r\n      setRecommendation(newRecommendation);\r\n      \r\n      // Add to history\r\n      addToRecommendationHistory(newRecommendation);\r\n      \r\n      // Save preferences\r\n      localStorage.setItem('lastInvestmentAmount', amountToUse.toString());\r\n      localStorage.setItem('defaultRiskProfile', riskProfileToUse);\r\n      \r\n      // Show success notification\r\n      showToast({\r\n        message: 'AI recommendation generated successfully',\r\n        type: 'success',\r\n        duration: 3000\r\n      });\r\n      \r\n      // Track recommendation\r\n      trackRecommendation(riskProfileToUse, amountToUse, true);\r\n      \r\n      return newRecommendation;\r\n    } catch (err) {\r\n      console.error('Error generating recommendation:', err);\r\n      setError(err.response?.data?.error || 'Failed to generate recommendation');\r\n      \r\n      // Show error notification\r\n      showToast({\r\n        message: `Failed to generate recommendation: ${err.response?.data?.error || err.message || 'Unknown error'}`,\r\n        type: 'error',\r\n        duration: 5000\r\n      });\r\n      \r\n      // Track failed recommendation\r\n      trackRecommendation(riskProfileToUse, amountToUse, false);\r\n      \r\n      return null;\r\n    } finally {\r\n      setIsLoading(false);\r\n      setGeneratingRecommendation(false);\r\n    }\r\n  }, [amount, riskProfile, preserveStakedPositions, address, showNotification]);\r\n  \r\n  /**\r\n   * Add recommendation to history\r\n   */\r\n  const addToRecommendationHistory = useCallback((newRecommendation) => {\r\n    if (!newRecommendation) return;\r\n    \r\n    // Add timestamp if not present\r\n    const recommendationWithTime = {\r\n      ...newRecommendation,\r\n      timestamp: newRecommendation.timestamp || new Date().toISOString()\r\n    };\r\n    \r\n    setRecommendationHistory(prev => {\r\n      // Check for duplicates\r\n      const isDuplicate = prev.some(r => \r\n        r.title === recommendationWithTime.title && \r\n        JSON.stringify(r.allocation) === JSON.stringify(recommendationWithTime.allocation)\r\n      );\r\n      \r\n      if (isDuplicate) return prev;\r\n      \r\n      // Add to beginning of array\r\n      const newHistory = [recommendationWithTime, ...prev];\r\n      \r\n      // Limit history size to 10 items\r\n      const limitedHistory = newHistory.slice(0, 10);\r\n      \r\n      // Store in localStorage\r\n      try {\r\n        localStorage.setItem('aiRecommendationsHistory', JSON.stringify(limitedHistory));\r\n      } catch (error) {\r\n        console.warn('Failed to save recommendation history to localStorage:', error);\r\n      }\r\n      \r\n      return limitedHistory;\r\n    });\r\n  }, []);\r\n  \r\n  /**\r\n   * Execute the recommended investment strategy\r\n   */\r\n  const executeRecommendation = useCallback(async (recommendationToExecute = recommendation) => {\r\n    if (!recommendationToExecute) {\r\n      showToast({\r\n        message: 'No recommendation to execute',\r\n        type: 'error',\r\n        duration: 3000\r\n      });\r\n      return null;\r\n    }\r\n    \r\n    setExecutingRecommendation(true);\r\n    setExecutionResult(null);\r\n    \r\n    try {\r\n      // Prepare operations from recommendation\r\n      const operations = prepareOperationsFromRecommendation(recommendationToExecute);\r\n      \r\n      if (!operations || operations.length === 0) {\r\n        throw new Error('No valid operations could be prepared from the recommendation');\r\n      }\r\n      \r\n      // Show info notification\r\n      showToast({\r\n        message: 'Preparing to execute strategy...',\r\n        type: 'info',\r\n        duration: 3000\r\n      });\r\n      \r\n      // Execute the strategy\r\n      const result = await executeStrategyTx(operations);\r\n      \r\n      // Update state with result\r\n      setExecutionResult(result);\r\n      \r\n      // Show success notification\r\n      showToast({\r\n        message: result.success ? \r\n          `Strategy executed successfully! ${result.operations?.length || 0} operations completed.` : \r\n          `Strategy executed with ${result.failedOperations?.length || 0} failures.`,\r\n        type: result.success ? 'success' : 'warning',\r\n        duration: 5000\r\n      });\r\n      \r\n      // Update recommendation with execution result\r\n      const updatedRecommendation = {\r\n        ...recommendationToExecute,\r\n        executionResult: result\r\n      };\r\n      \r\n      // Update in history\r\n      addToRecommendationHistory(updatedRecommendation);\r\n      \r\n      return result;\r\n    } catch (err) {\r\n      console.error('Strategy execution error:', err);\r\n      \r\n      // Set error result\r\n      setExecutionResult({ \r\n        success: false, \r\n        error: err.message,\r\n        message: `Strategy execution failed: ${err.message}`\r\n      });\r\n      \r\n      // Show error notification\r\n      showToast({\r\n        message: `Strategy execution failed: ${err.message}`,\r\n        type: 'error',\r\n        duration: 5000\r\n      });\r\n      \r\n      return { success: false, error: err.message };\r\n    } finally {\r\n      setExecutingRecommendation(false);\r\n    }\r\n  }, [recommendation, executeStrategyTx, showNotification, addToRecommendationHistory]);\r\n  \r\n  /**\r\n   * Prepare operations from recommendation for execution\r\n   */\r\n  const prepareOperationsFromRecommendation = useCallback((recommendationData) => {\r\n    if (!recommendationData?.allocation) {\r\n      return [];\r\n    }\r\n    \r\n    // Get contract addresses from constants.js\r\n    const contractAddresses = window.contractAddresses || {\r\n      amnis: \"0x111ae3e5bc816a5e63c2da97d0aa3886519e0cd5e4b046659fa35796bd11542a\",\r\n      thala: \"0xfaf4e633ae9eb31366c9ca24214231760926576c7b625313b3688b5e900731f6\",\r\n      tortuga: \"0x952c1b1fc8eb75ee80f432c9d0a84fcda1d5c7481501a7eca9199f1596a60b53\",\r\n      ditto: \"0xd11107bdf0d6d7040c6c0bfbdecb6545191fdf13e8d8d259952f53e1713f61b5\",\r\n      aries: \"0x9770fa9c725cbd97eb50b2be5f7416efdfd1f1554beb0750d4dae4c64e860da3\",\r\n      echo: \"0xeab7ea4d635b6b6add79d5045c4a45d8148d88287b1cfa1c3b6a4b56f46839ed\",\r\n      pancakeswap: \"0xc7efb4076dbe143cbcd98cfaaa929ecfc8f299203dfff63b95ccb6bfe19850fa\",\r\n      liquidswap: \"0x190d44266241744264b964a37b8f09863167a12d3e70cda39376cfb4e3561e12\",\r\n      cetus: \"0x27156bd56eb5637b9adde4d915b596f92d2f28f0ade2eaef48fa73e360e4e8a6\"\r\n    };\r\n    \r\n    const operations = recommendationData.allocation.map(item => {\r\n      // Determine operation type\r\n      const type = determineOperationType(item.product);\r\n      \r\n      // Get contract address (normalize protocol name to lowercase)\r\n      const protocolLower = item.protocol.toLowerCase();\r\n      const contractAddress = contractAddresses[protocolLower] || null;\r\n      \r\n      // If no contract address, skip this allocation\r\n      if (!contractAddress) {\r\n        console.warn(`No contract address found for protocol: ${item.protocol}`);\r\n        return null;\r\n      }\r\n      \r\n      // Calculate amount if not explicitly provided\r\n      const calculatedAmount = item.amount || \r\n        ((parseFloat(recommendationData.totalInvestment || amount) * parseFloat(item.percentage || 0) / 100).toFixed(2));\r\n      \r\n      // Skip if amount is invalid\r\n      if (isNaN(parseFloat(calculatedAmount)) || parseFloat(calculatedAmount) <= 0) {\r\n        console.warn(`Invalid amount for ${item.protocol}: ${calculatedAmount}`);\r\n        return null;\r\n      }\r\n      \r\n      return {\r\n        protocol: item.protocol,\r\n        type,\r\n        amount: calculatedAmount,\r\n        contractAddress,\r\n        functionName: determineFunctionName(item.protocol, type),\r\n        expectedApr: parseFloat(item.expectedApr || 0)\r\n      };\r\n    }).filter(Boolean); // Remove null items\r\n    \r\n    return operations;\r\n  }, [amount]);\r\n  \r\n  /**\r\n   * Determine operation type based on product description\r\n   */\r\n  const determineOperationType = useCallback((product) => {\r\n    if (!product) return 'stake';\r\n    \r\n    const lower = product.toLowerCase();\r\n    \r\n    if (lower.includes('stake') || lower.includes('stapt') || lower.includes('tapt')) {\r\n      return 'stake';\r\n    }\r\n    if (lower.includes('lend') || lower.includes('lending')) {\r\n      return 'lend';\r\n    }\r\n    if (lower.includes('liquidity') || lower.includes('amm') || lower.includes('pool')) {\r\n      return 'addLiquidity';\r\n    }\r\n    if (lower.includes('vault') || lower.includes('yield')) {\r\n      return 'deposit';\r\n    }\r\n    \r\n    return 'stake'; // Default to staking\r\n  }, []);\r\n  \r\n  /**\r\n   * Determine function name based on protocol and operation type\r\n   */\r\n  const determineFunctionName = useCallback((protocol, operationType) => {\r\n    const functionMappings = {\r\n      'amnis': { \r\n        'stake': '::staking::stake', \r\n        'unstake': '::staking::unstake', \r\n        'lend': '::lending::supply', \r\n        'withdraw': '::lending::withdraw', \r\n        'addLiquidity': '::router::add_liquidity', \r\n        'removeLiquidity': '::router::remove_liquidity' \r\n      },\r\n      'thala': { \r\n        'stake': '::staking::stake_apt', \r\n        'unstake': '::staking::unstake_apt', \r\n        'lend': '::lending::supply_apt', \r\n        'withdraw': '::lending::withdraw_apt', \r\n        'addLiquidity': '::router::add_liquidity', \r\n        'removeLiquidity': '::router::remove_liquidity' \r\n      },\r\n      'tortuga': { \r\n        'stake': '::staking::stake_apt', \r\n        'unstake': '::staking::unstake_apt' \r\n      },\r\n      'echo': { \r\n        'lend': '::lending::supply', \r\n        'withdraw': '::lending::withdraw' \r\n      },\r\n      'ditto': { \r\n        'stake': '::staking::stake', \r\n        'unstake': '::staking::unstake' \r\n      },\r\n      'aries': { \r\n        'lend': '::lending::supply', \r\n        'withdraw': '::lending::withdraw' \r\n      },\r\n      'cetus': { \r\n        'addLiquidity': '::pool::add_liquidity', \r\n        'removeLiquidity': '::pool::remove_liquidity' \r\n      },\r\n      'pancakeswap': { \r\n        'addLiquidity': '::router::add_liquidity', \r\n        'removeLiquidity': '::router::remove_liquidity', \r\n        'swap': '::router::swap_exact_input' \r\n      },\r\n      'liquidswap': { \r\n        'addLiquidity': '::router::add_liquidity', \r\n        'removeLiquidity': '::router::remove_liquidity' \r\n      }\r\n    };\r\n\r\n    // If we have a specific mapping for this protocol and operation type, use it\r\n    if (functionMappings[protocol.toLowerCase()]?.[operationType]) {\r\n      return functionMappings[protocol.toLowerCase()][operationType];\r\n    }\r\n\r\n    // Otherwise use general mappings\r\n    switch (operationType) {\r\n      case 'stake': return '::staking::stake';\r\n      case 'unstake': return '::staking::unstake';\r\n      case 'lend': return '::lending::supply';\r\n      case 'withdraw': return '::lending::withdraw';\r\n      case 'addLiquidity': return '::router::add_liquidity';\r\n      case 'removeLiquidity': return '::router::remove_liquidity';\r\n      case 'deposit': return '::yield::deposit';\r\n      default: return `::${operationType}::execute`;\r\n    }\r\n  }, []);\r\n  \r\n  /**\r\n   * Compare two recommendations to highlight differences\r\n   */\r\n  const compareRecommendations = useCallback((recommendation1, recommendation2) => {\r\n    if (!recommendation1 || !recommendation2) return null;\r\n    \r\n    const result = {\r\n      aprDifference: parseFloat(recommendation2.totalApr || 0) - parseFloat(recommendation1.totalApr || 0),\r\n      allocationChanges: [],\r\n      newProtocols: [],\r\n      removedProtocols: [],\r\n      riskLevelChange: false\r\n    };\r\n    \r\n    // Compare allocations\r\n    const alloc1Map = new Map();\r\n    recommendation1.allocation?.forEach(item => {\r\n      alloc1Map.set(item.protocol, item);\r\n    });\r\n    \r\n    // Find changes and new protocols\r\n    recommendation2.allocation?.forEach(item => {\r\n      const prev = alloc1Map.get(item.protocol);\r\n      if (prev) {\r\n        // Protocol exists in both recommendations\r\n        if (parseFloat(prev.percentage) !== parseFloat(item.percentage)) {\r\n          result.allocationChanges.push({\r\n            protocol: item.protocol,\r\n            product: item.product,\r\n            prevPercentage: parseFloat(prev.percentage),\r\n            newPercentage: parseFloat(item.percentage),\r\n            percentageChange: parseFloat(item.percentage) - parseFloat(prev.percentage),\r\n            aprChange: parseFloat(item.expectedApr || 0) - parseFloat(prev.expectedApr || 0)\r\n          });\r\n        }\r\n        // Remove from map to track removed protocols\r\n        alloc1Map.delete(item.protocol);\r\n      } else {\r\n        // New protocol\r\n        result.newProtocols.push(item);\r\n      }\r\n    });\r\n    \r\n    // Identify removed protocols\r\n    result.removedProtocols = Array.from(alloc1Map.values());\r\n    \r\n    // Check for risk level change\r\n    if (recommendation1.riskProfile && recommendation2.riskProfile && \r\n        recommendation1.riskProfile !== recommendation2.riskProfile) {\r\n      result.riskLevelChange = {\r\n        from: recommendation1.riskProfile,\r\n        to: recommendation2.riskProfile\r\n      };\r\n    }\r\n    \r\n    return result;\r\n  }, []);\r\n  \r\n  return {\r\n    // States\r\n    isLoading,\r\n    error,\r\n    recommendation,\r\n    recommendationHistory,\r\n    generatingRecommendation,\r\n    executingRecommendation,\r\n    executionResult,\r\n    \r\n    // Form values\r\n    amount,\r\n    riskProfile,\r\n    preserveStakedPositions,\r\n    \r\n    // Form setters\r\n    setAmount,\r\n    setRiskProfile,\r\n    setPreserveStakedPositions,\r\n    \r\n    // Actions\r\n    generateRecommendation,\r\n    executeRecommendation,\r\n    compareRecommendations,\r\n    prepareOperationsFromRecommendation\r\n  };\r\n};\r\n\r\nexport default useRecommendations;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}