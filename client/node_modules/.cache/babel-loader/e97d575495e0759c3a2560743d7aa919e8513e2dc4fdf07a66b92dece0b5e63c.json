{"ast":null,"code":"var _s = $RefreshSig$();\n// usePortfolio.js - Hook for fetching and managing wallet portfolio data\nimport { useState, useEffect, useCallback, useContext } from 'react';\nimport { useWallet } from './useWallet';\nimport { NotificationContext } from '../context/NotificationContext';\nimport api from '../services/api';\n\n/**\r\n * Hook for fetching and managing portfolio data from a wallet\r\n */\nconst usePortfolio = walletAddressParam => {\n  _s();\n  const {\n    isConnected,\n    walletAddress: connectedWalletAddress\n  } = useWalletContext();\n  const {\n    showNotification\n  } = useContext(NotificationContext);\n\n  // Use provided wallet address or the connected wallet address\n  const walletAddress = walletAddressParam || connectedWalletAddress;\n\n  // Portfolio data states\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [portfolioData, setPortfolioData] = useState(null);\n  const [portfolioHistory, setPortfolioHistory] = useState([]);\n  const [lastUpdated, setLastUpdated] = useState(null);\n  const [tokenBreakdown, setTokenBreakdown] = useState([]);\n  const [totalValue, setTotalValue] = useState(0);\n  const [aptBalance, setAptBalance] = useState(0);\n  const [stakedPositions, setStakedPositions] = useState([]);\n  const [liquidityPositions, setLiquidityPositions] = useState([]);\n\n  // Track refresh status\n  const [isRefreshing, setIsRefreshing] = useState(false);\n  const [autoRefreshEnabled, setAutoRefreshEnabled] = useState(false);\n  const [autoRefreshInterval, setAutoRefreshInterval] = useState(5 * 60 * 1000); // 5 minutes default\n\n  /**\r\n   * Fetch portfolio data for a wallet\r\n   */\n  const fetchPortfolio = useCallback(async (address = walletAddress) => {\n    if (!address) {\n      setError('No wallet address provided');\n      return null;\n    }\n    setIsLoading(true);\n    setError(null);\n    try {\n      const response = await api.get(`/wallet/${address}`);\n      const data = response.data;\n\n      // Update state with new data\n      setPortfolioData(data);\n      setLastUpdated(new Date());\n\n      // Extract key metrics from response\n      if (data.portfolio) {\n        var _portfolio$apt;\n        const portfolio = data.portfolio;\n        setTotalValue(portfolio.totalValueUSD || 0);\n        setAptBalance(parseFloat(((_portfolio$apt = portfolio.apt) === null || _portfolio$apt === void 0 ? void 0 : _portfolio$apt.amount) || 0));\n\n        // Process token breakdown\n        const tokens = [];\n\n        // Add APT\n        if (portfolio.apt) {\n          tokens.push({\n            token: 'APT',\n            name: 'Aptos',\n            amount: parseFloat(portfolio.apt.amount),\n            valueUSD: portfolio.apt.valueUSD,\n            percentage: (portfolio.apt.valueUSD / portfolio.totalValueUSD * 100).toFixed(2),\n            type: 'native'\n          });\n        }\n\n        // Add staked tokens\n        const stakedTokensMap = {\n          'stAPT': {\n            name: 'stAPT (Amnis)',\n            protocol: 'Amnis'\n          },\n          'sthAPT': {\n            name: 'sthAPT (Thala)',\n            protocol: 'Thala'\n          },\n          'tAPT': {\n            name: 'tAPT (Tortuga)',\n            protocol: 'Tortuga'\n          },\n          'dAPT': {\n            name: 'dAPT (Ditto)',\n            protocol: 'Ditto'\n          }\n        };\n        const stakedList = [];\n        Object.entries(stakedTokensMap).forEach(([key, info]) => {\n          if (portfolio[key] && parseFloat(portfolio[key].amount) > 0) {\n            const token = {\n              token: key,\n              name: info.name,\n              protocol: info.protocol,\n              amount: parseFloat(portfolio[key].amount),\n              valueUSD: portfolio[key].valueUSD,\n              percentage: (portfolio[key].valueUSD / portfolio.totalValueUSD * 100).toFixed(2),\n              type: 'staked',\n              apr: portfolio[key].apr || null\n            };\n            tokens.push(token);\n            stakedList.push(token);\n          }\n        });\n        setStakedPositions(stakedList);\n\n        // Add liquidity positions\n        const liquidityList = [];\n        if (portfolio.ammLiquidity && portfolio.ammLiquidity.hasLiquidity) {\n          if (portfolio.ammLiquidity.positions && portfolio.ammLiquidity.positions.length > 0) {\n            portfolio.ammLiquidity.positions.forEach(position => {\n              if (position.valueUSD > 0) {\n                const liquidityToken = {\n                  token: position.pairName || 'LP Token',\n                  name: position.pairName || 'Liquidity Pool Token',\n                  protocol: position.protocol || 'AMM',\n                  valueUSD: position.valueUSD,\n                  percentage: (position.valueUSD / portfolio.totalValueUSD * 100).toFixed(2),\n                  type: 'liquidity',\n                  apr: position.apr || null\n                };\n                tokens.push(liquidityToken);\n                liquidityList.push(liquidityToken);\n              }\n            });\n          } else if (portfolio.ammLiquidity.valueUSD > 0) {\n            const liquidityToken = {\n              token: 'LP',\n              name: 'Liquidity Pool Token',\n              protocol: 'AMM',\n              valueUSD: portfolio.ammLiquidity.valueUSD,\n              percentage: (portfolio.ammLiquidity.valueUSD / portfolio.totalValueUSD * 100).toFixed(2),\n              type: 'liquidity'\n            };\n            tokens.push(liquidityToken);\n            liquidityList.push(liquidityToken);\n          }\n        }\n        setLiquidityPositions(liquidityList);\n\n        // Add any other tokens\n        if (portfolio.otherTokens && portfolio.otherTokens.length > 0) {\n          portfolio.otherTokens.forEach(token => {\n            if (token.valueUSD > 0) {\n              tokens.push({\n                token: token.symbol || 'Unknown',\n                name: token.name || token.symbol || 'Unknown Token',\n                amount: parseFloat(token.amount || 0),\n                valueUSD: token.valueUSD,\n                percentage: (token.valueUSD / portfolio.totalValueUSD * 100).toFixed(2),\n                type: 'other'\n              });\n            }\n          });\n        }\n        setTokenBreakdown(tokens);\n      }\n\n      // Extract historical data if available\n      if (data.portfolioHistory) {\n        setPortfolioHistory(data.portfolioHistory);\n      }\n      return data;\n    } catch (err) {\n      var _err$response, _err$response$data;\n      console.error('Error fetching portfolio data:', err);\n      setError(((_err$response = err.response) === null || _err$response === void 0 ? void 0 : (_err$response$data = _err$response.data) === null || _err$response$data === void 0 ? void 0 : _err$response$data.message) || 'Failed to fetch portfolio data');\n      showNotification({\n        type: 'error',\n        title: 'Portfolio Error',\n        message: 'Failed to fetch portfolio data'\n      });\n      return null;\n    } finally {\n      setIsLoading(false);\n      setIsRefreshing(false);\n    }\n  }, [walletAddress, showNotification]);\n\n  /**\r\n   * Refresh portfolio data\r\n   */\n  const refreshPortfolio = useCallback(() => {\n    setIsRefreshing(true);\n    return fetchPortfolio(walletAddress);\n  }, [fetchPortfolio, walletAddress]);\n\n  /**\r\n   * Toggle auto-refresh functionality\r\n   */\n  const toggleAutoRefresh = useCallback(() => {\n    setAutoRefreshEnabled(prev => !prev);\n  }, []);\n\n  /**\r\n   * Set auto-refresh interval\r\n   */\n  const setRefreshInterval = useCallback(interval => {\n    if (interval && interval > 0) {\n      setAutoRefreshInterval(interval);\n    }\n  }, []);\n\n  /**\r\n   * Calculate performance metrics\r\n   */\n  const calculatePerformanceMetrics = useCallback(() => {\n    if (!portfolioHistory || portfolioHistory.length < 2) {\n      return {\n        dailyChange: 0,\n        weeklyChange: 0,\n        monthlyChange: 0,\n        dailyPercentage: 0,\n        weeklyPercentage: 0,\n        monthlyPercentage: 0\n      };\n    }\n\n    // Sort history by date\n    const sortedHistory = [...portfolioHistory].sort((a, b) => new Date(a.date) - new Date(b.date));\n    const currentValue = sortedHistory[sortedHistory.length - 1].value;\n\n    // Get historical values\n    const now = new Date();\n    const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n    const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\n    const oneMonthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\n\n    // Find closest data points\n    const findClosestValue = targetDate => {\n      return sortedHistory.reduce((closest, current) => {\n        const currentDate = new Date(current.date);\n        const closestDate = new Date(closest.date);\n        return Math.abs(currentDate - targetDate) < Math.abs(closestDate - targetDate) ? current : closest;\n      });\n    };\n    const dayValue = findClosestValue(oneDayAgo).value;\n    const weekValue = findClosestValue(oneWeekAgo).value;\n    const monthValue = findClosestValue(oneMonthAgo).value;\n\n    // Calculate changes\n    const dailyChange = currentValue - dayValue;\n    const weeklyChange = currentValue - weekValue;\n    const monthlyChange = currentValue - monthValue;\n\n    // Calculate percentages\n    const dailyPercentage = dayValue !== 0 ? dailyChange / dayValue * 100 : 0;\n    const weeklyPercentage = weekValue !== 0 ? weeklyChange / weekValue * 100 : 0;\n    const monthlyPercentage = monthValue !== 0 ? monthlyChange / monthValue * 100 : 0;\n    return {\n      dailyChange,\n      weeklyChange,\n      monthlyChange,\n      dailyPercentage,\n      weeklyPercentage,\n      monthlyPercentage\n    };\n  }, [portfolioHistory]);\n\n  // Fetch portfolio data on mount and address change\n  useEffect(() => {\n    if (walletAddress) {\n      fetchPortfolio(walletAddress);\n    }\n  }, [walletAddress, fetchPortfolio]);\n\n  // Set up auto-refresh interval\n  useEffect(() => {\n    let intervalId;\n    if (autoRefreshEnabled && walletAddress) {\n      intervalId = setInterval(() => {\n        refreshPortfolio();\n      }, autoRefreshInterval);\n    }\n    return () => {\n      if (intervalId) {\n        clearInterval(intervalId);\n      }\n    };\n  }, [autoRefreshEnabled, autoRefreshInterval, refreshPortfolio, walletAddress]);\n\n  // Return portfolio data and operations\n  return {\n    isLoading,\n    isRefreshing,\n    error,\n    portfolioData,\n    portfolioHistory,\n    lastUpdated,\n    tokenBreakdown,\n    totalValue,\n    aptBalance,\n    stakedPositions,\n    liquidityPositions,\n    fetchPortfolio,\n    refreshPortfolio,\n    autoRefreshEnabled,\n    autoRefreshInterval,\n    toggleAutoRefresh,\n    setRefreshInterval,\n    performanceMetrics: calculatePerformanceMetrics(),\n    hasData: !!portfolioData\n  };\n};\n_s(usePortfolio, \"WMHuKkrSa+zn4ayHlbXaIb3Iejc=\", true);\nconst usePortfolioHook = (...args) => {\n  // Implementation\n};\nexport default usePortfolioHook;","map":{"version":3,"names":["useState","useEffect","useCallback","useContext","useWallet","NotificationContext","api","usePortfolio","walletAddressParam","_s","isConnected","walletAddress","connectedWalletAddress","useWalletContext","showNotification","isLoading","setIsLoading","error","setError","portfolioData","setPortfolioData","portfolioHistory","setPortfolioHistory","lastUpdated","setLastUpdated","tokenBreakdown","setTokenBreakdown","totalValue","setTotalValue","aptBalance","setAptBalance","stakedPositions","setStakedPositions","liquidityPositions","setLiquidityPositions","isRefreshing","setIsRefreshing","autoRefreshEnabled","setAutoRefreshEnabled","autoRefreshInterval","setAutoRefreshInterval","fetchPortfolio","address","response","get","data","Date","portfolio","_portfolio$apt","totalValueUSD","parseFloat","apt","amount","tokens","push","token","name","valueUSD","percentage","toFixed","type","stakedTokensMap","protocol","stakedList","Object","entries","forEach","key","info","apr","liquidityList","ammLiquidity","hasLiquidity","positions","length","position","liquidityToken","pairName","otherTokens","symbol","err","_err$response","_err$response$data","console","message","title","refreshPortfolio","toggleAutoRefresh","prev","setRefreshInterval","interval","calculatePerformanceMetrics","dailyChange","weeklyChange","monthlyChange","dailyPercentage","weeklyPercentage","monthlyPercentage","sortedHistory","sort","a","b","date","currentValue","value","now","oneDayAgo","getTime","oneWeekAgo","oneMonthAgo","findClosestValue","targetDate","reduce","closest","current","currentDate","closestDate","Math","abs","dayValue","weekValue","monthValue","intervalId","setInterval","clearInterval","performanceMetrics","hasData","usePortfolioHook","args"],"sources":["/home/ck/compoundefi/client/src/hooks/usePortfolio.js"],"sourcesContent":["// usePortfolio.js - Hook for fetching and managing wallet portfolio data\r\nimport { useState, useEffect, useCallback, useContext } from 'react';\r\nimport { useWallet } from './useWallet';\r\nimport { NotificationContext } from '../context/NotificationContext';\r\nimport api from '../services/api';\r\n\r\n/**\r\n * Hook for fetching and managing portfolio data from a wallet\r\n */\r\nconst usePortfolio = (walletAddressParam) => {\r\n  const { isConnected, walletAddress: connectedWalletAddress } = useWalletContext();\r\n  const { showNotification } = useContext(NotificationContext);\r\n  \r\n  // Use provided wallet address or the connected wallet address\r\n  const walletAddress = walletAddressParam || connectedWalletAddress;\r\n  \r\n  // Portfolio data states\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [error, setError] = useState(null);\r\n  const [portfolioData, setPortfolioData] = useState(null);\r\n  const [portfolioHistory, setPortfolioHistory] = useState([]);\r\n  const [lastUpdated, setLastUpdated] = useState(null);\r\n  const [tokenBreakdown, setTokenBreakdown] = useState([]);\r\n  const [totalValue, setTotalValue] = useState(0);\r\n  const [aptBalance, setAptBalance] = useState(0);\r\n  const [stakedPositions, setStakedPositions] = useState([]);\r\n  const [liquidityPositions, setLiquidityPositions] = useState([]);\r\n  \r\n  // Track refresh status\r\n  const [isRefreshing, setIsRefreshing] = useState(false);\r\n  const [autoRefreshEnabled, setAutoRefreshEnabled] = useState(false);\r\n  const [autoRefreshInterval, setAutoRefreshInterval] = useState(5 * 60 * 1000); // 5 minutes default\r\n  \r\n  /**\r\n   * Fetch portfolio data for a wallet\r\n   */\r\n  const fetchPortfolio = useCallback(async (address = walletAddress) => {\r\n    if (!address) {\r\n      setError('No wallet address provided');\r\n      return null;\r\n    }\r\n    \r\n    setIsLoading(true);\r\n    setError(null);\r\n\r\n    try {\r\n      const response = await api.get(`/wallet/${address}`);\r\n      const data = response.data;\r\n      \r\n      // Update state with new data\r\n      setPortfolioData(data);\r\n      setLastUpdated(new Date());\r\n      \r\n      // Extract key metrics from response\r\n      if (data.portfolio) {\r\n        const portfolio = data.portfolio;\r\n        setTotalValue(portfolio.totalValueUSD || 0);\r\n        setAptBalance(parseFloat(portfolio.apt?.amount || 0));\r\n        \r\n        // Process token breakdown\r\n        const tokens = [];\r\n        \r\n        // Add APT\r\n        if (portfolio.apt) {\r\n          tokens.push({\r\n            token: 'APT',\r\n            name: 'Aptos',\r\n            amount: parseFloat(portfolio.apt.amount),\r\n            valueUSD: portfolio.apt.valueUSD,\r\n            percentage: (portfolio.apt.valueUSD / portfolio.totalValueUSD * 100).toFixed(2),\r\n            type: 'native'\r\n          });\r\n        }\r\n        \r\n        // Add staked tokens\r\n        const stakedTokensMap = {\r\n          'stAPT': { name: 'stAPT (Amnis)', protocol: 'Amnis' },\r\n          'sthAPT': { name: 'sthAPT (Thala)', protocol: 'Thala' },\r\n          'tAPT': { name: 'tAPT (Tortuga)', protocol: 'Tortuga' },\r\n          'dAPT': { name: 'dAPT (Ditto)', protocol: 'Ditto' }\r\n        };\r\n        \r\n        const stakedList = [];\r\n        Object.entries(stakedTokensMap).forEach(([key, info]) => {\r\n          if (portfolio[key] && parseFloat(portfolio[key].amount) > 0) {\r\n            const token = {\r\n              token: key,\r\n              name: info.name,\r\n              protocol: info.protocol,\r\n              amount: parseFloat(portfolio[key].amount),\r\n              valueUSD: portfolio[key].valueUSD,\r\n              percentage: (portfolio[key].valueUSD / portfolio.totalValueUSD * 100).toFixed(2),\r\n              type: 'staked',\r\n              apr: portfolio[key].apr || null\r\n            };\r\n            \r\n            tokens.push(token);\r\n            stakedList.push(token);\r\n          }\r\n        });\r\n        setStakedPositions(stakedList);\r\n        \r\n        // Add liquidity positions\r\n        const liquidityList = [];\r\n        if (portfolio.ammLiquidity && portfolio.ammLiquidity.hasLiquidity) {\r\n          if (portfolio.ammLiquidity.positions && portfolio.ammLiquidity.positions.length > 0) {\r\n            portfolio.ammLiquidity.positions.forEach(position => {\r\n              if (position.valueUSD > 0) {\r\n                const liquidityToken = {\r\n                  token: position.pairName || 'LP Token',\r\n                  name: position.pairName || 'Liquidity Pool Token',\r\n                  protocol: position.protocol || 'AMM',\r\n                  valueUSD: position.valueUSD,\r\n                  percentage: (position.valueUSD / portfolio.totalValueUSD * 100).toFixed(2),\r\n                  type: 'liquidity',\r\n                  apr: position.apr || null\r\n                };\r\n                \r\n                tokens.push(liquidityToken);\r\n                liquidityList.push(liquidityToken);\r\n              }\r\n            });\r\n          } else if (portfolio.ammLiquidity.valueUSD > 0) {\r\n            const liquidityToken = {\r\n              token: 'LP',\r\n              name: 'Liquidity Pool Token',\r\n              protocol: 'AMM',\r\n              valueUSD: portfolio.ammLiquidity.valueUSD,\r\n              percentage: (portfolio.ammLiquidity.valueUSD / portfolio.totalValueUSD * 100).toFixed(2),\r\n              type: 'liquidity'\r\n            };\r\n            \r\n            tokens.push(liquidityToken);\r\n            liquidityList.push(liquidityToken);\r\n          }\r\n        }\r\n        setLiquidityPositions(liquidityList);\r\n        \r\n        // Add any other tokens\r\n        if (portfolio.otherTokens && portfolio.otherTokens.length > 0) {\r\n          portfolio.otherTokens.forEach(token => {\r\n            if (token.valueUSD > 0) {\r\n              tokens.push({\r\n                token: token.symbol || 'Unknown',\r\n                name: token.name || token.symbol || 'Unknown Token',\r\n                amount: parseFloat(token.amount || 0),\r\n                valueUSD: token.valueUSD,\r\n                percentage: (token.valueUSD / portfolio.totalValueUSD * 100).toFixed(2),\r\n                type: 'other'\r\n              });\r\n            }\r\n          });\r\n        }\r\n        \r\n        setTokenBreakdown(tokens);\r\n      }\r\n      \r\n      // Extract historical data if available\r\n      if (data.portfolioHistory) {\r\n        setPortfolioHistory(data.portfolioHistory);\r\n      }\r\n      \r\n      return data;\r\n    } catch (err) {\r\n      console.error('Error fetching portfolio data:', err);\r\n      setError(err.response?.data?.message || 'Failed to fetch portfolio data');\r\n      \r\n      showNotification({\r\n        type: 'error',\r\n        title: 'Portfolio Error',\r\n        message: 'Failed to fetch portfolio data'\r\n      });\r\n      \r\n      return null;\r\n    } finally {\r\n      setIsLoading(false);\r\n      setIsRefreshing(false);\r\n    }\r\n  }, [walletAddress, showNotification]);\r\n  \r\n  /**\r\n   * Refresh portfolio data\r\n   */\r\n  const refreshPortfolio = useCallback(() => {\r\n    setIsRefreshing(true);\r\n    return fetchPortfolio(walletAddress);\r\n  }, [fetchPortfolio, walletAddress]);\r\n  \r\n  /**\r\n   * Toggle auto-refresh functionality\r\n   */\r\n  const toggleAutoRefresh = useCallback(() => {\r\n    setAutoRefreshEnabled(prev => !prev);\r\n  }, []);\r\n  \r\n  /**\r\n   * Set auto-refresh interval\r\n   */\r\n  const setRefreshInterval = useCallback((interval) => {\r\n    if (interval && interval > 0) {\r\n      setAutoRefreshInterval(interval);\r\n    }\r\n  }, []);\r\n  \r\n  /**\r\n   * Calculate performance metrics\r\n   */\r\n  const calculatePerformanceMetrics = useCallback(() => {\r\n    if (!portfolioHistory || portfolioHistory.length < 2) {\r\n      return {\r\n        dailyChange: 0,\r\n        weeklyChange: 0,\r\n        monthlyChange: 0,\r\n        dailyPercentage: 0,\r\n        weeklyPercentage: 0,\r\n        monthlyPercentage: 0\r\n      };\r\n    }\r\n    \r\n    // Sort history by date\r\n    const sortedHistory = [...portfolioHistory].sort((a, b) => \r\n      new Date(a.date) - new Date(b.date)\r\n    );\r\n    \r\n    const currentValue = sortedHistory[sortedHistory.length - 1].value;\r\n    \r\n    // Get historical values\r\n    const now = new Date();\r\n    const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);\r\n    const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);\r\n    const oneMonthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);\r\n    \r\n    // Find closest data points\r\n    const findClosestValue = (targetDate) => {\r\n      return sortedHistory.reduce((closest, current) => {\r\n        const currentDate = new Date(current.date);\r\n        const closestDate = new Date(closest.date);\r\n        \r\n        return Math.abs(currentDate - targetDate) < Math.abs(closestDate - targetDate) \r\n          ? current \r\n          : closest;\r\n      });\r\n    };\r\n    \r\n    const dayValue = findClosestValue(oneDayAgo).value;\r\n    const weekValue = findClosestValue(oneWeekAgo).value;\r\n    const monthValue = findClosestValue(oneMonthAgo).value;\r\n    \r\n    // Calculate changes\r\n    const dailyChange = currentValue - dayValue;\r\n    const weeklyChange = currentValue - weekValue;\r\n    const monthlyChange = currentValue - monthValue;\r\n    \r\n    // Calculate percentages\r\n    const dailyPercentage = dayValue !== 0 ? (dailyChange / dayValue) * 100 : 0;\r\n    const weeklyPercentage = weekValue !== 0 ? (weeklyChange / weekValue) * 100 : 0;\r\n    const monthlyPercentage = monthValue !== 0 ? (monthlyChange / monthValue) * 100 : 0;\r\n    \r\n    return {\r\n      dailyChange,\r\n      weeklyChange,\r\n      monthlyChange,\r\n      dailyPercentage,\r\n      weeklyPercentage,\r\n      monthlyPercentage\r\n    };\r\n  }, [portfolioHistory]);\r\n  \r\n  // Fetch portfolio data on mount and address change\r\n  useEffect(() => {\r\n    if (walletAddress) {\r\n      fetchPortfolio(walletAddress);\r\n    }\r\n  }, [walletAddress, fetchPortfolio]);\r\n  \r\n  // Set up auto-refresh interval\r\n  useEffect(() => {\r\n    let intervalId;\r\n    \r\n    if (autoRefreshEnabled && walletAddress) {\r\n      intervalId = setInterval(() => {\r\n        refreshPortfolio();\r\n      }, autoRefreshInterval);\r\n    }\r\n    \r\n    return () => {\r\n      if (intervalId) {\r\n        clearInterval(intervalId);\r\n      }\r\n    };\r\n  }, [autoRefreshEnabled, autoRefreshInterval, refreshPortfolio, walletAddress]);\r\n  \r\n  // Return portfolio data and operations\r\n  return {\r\n    isLoading,\r\n    isRefreshing,\r\n    error,\r\n    portfolioData,\r\n    portfolioHistory,\r\n    lastUpdated,\r\n    tokenBreakdown,\r\n    totalValue,\r\n    aptBalance,\r\n    stakedPositions,\r\n    liquidityPositions,\r\n    fetchPortfolio,\r\n    refreshPortfolio,\r\n    autoRefreshEnabled,\r\n    autoRefreshInterval,\r\n    toggleAutoRefresh,\r\n    setRefreshInterval,\r\n    performanceMetrics: calculatePerformanceMetrics(),\r\n    hasData: !!portfolioData\r\n  };\r\n};\r\n\r\nconst usePortfolioHook = (...args) => {\r\n  // Implementation\r\n};\r\n\r\nexport default usePortfolioHook;"],"mappings":";AAAA;AACA,SAASA,QAAQ,EAAEC,SAAS,EAAEC,WAAW,EAAEC,UAAU,QAAQ,OAAO;AACpE,SAASC,SAAS,QAAQ,aAAa;AACvC,SAASC,mBAAmB,QAAQ,gCAAgC;AACpE,OAAOC,GAAG,MAAM,iBAAiB;;AAEjC;AACA;AACA;AACA,MAAMC,YAAY,GAAIC,kBAAkB,IAAK;EAAAC,EAAA;EAC3C,MAAM;IAAEC,WAAW;IAAEC,aAAa,EAAEC;EAAuB,CAAC,GAAGC,gBAAgB,CAAC,CAAC;EACjF,MAAM;IAAEC;EAAiB,CAAC,GAAGX,UAAU,CAACE,mBAAmB,CAAC;;EAE5D;EACA,MAAMM,aAAa,GAAGH,kBAAkB,IAAII,sBAAsB;;EAElE;EACA,MAAM,CAACG,SAAS,EAAEC,YAAY,CAAC,GAAGhB,QAAQ,CAAC,KAAK,CAAC;EACjD,MAAM,CAACiB,KAAK,EAAEC,QAAQ,CAAC,GAAGlB,QAAQ,CAAC,IAAI,CAAC;EACxC,MAAM,CAACmB,aAAa,EAAEC,gBAAgB,CAAC,GAAGpB,QAAQ,CAAC,IAAI,CAAC;EACxD,MAAM,CAACqB,gBAAgB,EAAEC,mBAAmB,CAAC,GAAGtB,QAAQ,CAAC,EAAE,CAAC;EAC5D,MAAM,CAACuB,WAAW,EAAEC,cAAc,CAAC,GAAGxB,QAAQ,CAAC,IAAI,CAAC;EACpD,MAAM,CAACyB,cAAc,EAAEC,iBAAiB,CAAC,GAAG1B,QAAQ,CAAC,EAAE,CAAC;EACxD,MAAM,CAAC2B,UAAU,EAAEC,aAAa,CAAC,GAAG5B,QAAQ,CAAC,CAAC,CAAC;EAC/C,MAAM,CAAC6B,UAAU,EAAEC,aAAa,CAAC,GAAG9B,QAAQ,CAAC,CAAC,CAAC;EAC/C,MAAM,CAAC+B,eAAe,EAAEC,kBAAkB,CAAC,GAAGhC,QAAQ,CAAC,EAAE,CAAC;EAC1D,MAAM,CAACiC,kBAAkB,EAAEC,qBAAqB,CAAC,GAAGlC,QAAQ,CAAC,EAAE,CAAC;;EAEhE;EACA,MAAM,CAACmC,YAAY,EAAEC,eAAe,CAAC,GAAGpC,QAAQ,CAAC,KAAK,CAAC;EACvD,MAAM,CAACqC,kBAAkB,EAAEC,qBAAqB,CAAC,GAAGtC,QAAQ,CAAC,KAAK,CAAC;EACnE,MAAM,CAACuC,mBAAmB,EAAEC,sBAAsB,CAAC,GAAGxC,QAAQ,CAAC,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC,CAAC;;EAE/E;AACF;AACA;EACE,MAAMyC,cAAc,GAAGvC,WAAW,CAAC,OAAOwC,OAAO,GAAG/B,aAAa,KAAK;IACpE,IAAI,CAAC+B,OAAO,EAAE;MACZxB,QAAQ,CAAC,4BAA4B,CAAC;MACtC,OAAO,IAAI;IACb;IAEAF,YAAY,CAAC,IAAI,CAAC;IAClBE,QAAQ,CAAC,IAAI,CAAC;IAEd,IAAI;MACF,MAAMyB,QAAQ,GAAG,MAAMrC,GAAG,CAACsC,GAAG,CAAC,WAAWF,OAAO,EAAE,CAAC;MACpD,MAAMG,IAAI,GAAGF,QAAQ,CAACE,IAAI;;MAE1B;MACAzB,gBAAgB,CAACyB,IAAI,CAAC;MACtBrB,cAAc,CAAC,IAAIsB,IAAI,CAAC,CAAC,CAAC;;MAE1B;MACA,IAAID,IAAI,CAACE,SAAS,EAAE;QAAA,IAAAC,cAAA;QAClB,MAAMD,SAAS,GAAGF,IAAI,CAACE,SAAS;QAChCnB,aAAa,CAACmB,SAAS,CAACE,aAAa,IAAI,CAAC,CAAC;QAC3CnB,aAAa,CAACoB,UAAU,CAAC,EAAAF,cAAA,GAAAD,SAAS,CAACI,GAAG,cAAAH,cAAA,uBAAbA,cAAA,CAAeI,MAAM,KAAI,CAAC,CAAC,CAAC;;QAErD;QACA,MAAMC,MAAM,GAAG,EAAE;;QAEjB;QACA,IAAIN,SAAS,CAACI,GAAG,EAAE;UACjBE,MAAM,CAACC,IAAI,CAAC;YACVC,KAAK,EAAE,KAAK;YACZC,IAAI,EAAE,OAAO;YACbJ,MAAM,EAAEF,UAAU,CAACH,SAAS,CAACI,GAAG,CAACC,MAAM,CAAC;YACxCK,QAAQ,EAAEV,SAAS,CAACI,GAAG,CAACM,QAAQ;YAChCC,UAAU,EAAE,CAACX,SAAS,CAACI,GAAG,CAACM,QAAQ,GAAGV,SAAS,CAACE,aAAa,GAAG,GAAG,EAAEU,OAAO,CAAC,CAAC,CAAC;YAC/EC,IAAI,EAAE;UACR,CAAC,CAAC;QACJ;;QAEA;QACA,MAAMC,eAAe,GAAG;UACtB,OAAO,EAAE;YAAEL,IAAI,EAAE,eAAe;YAAEM,QAAQ,EAAE;UAAQ,CAAC;UACrD,QAAQ,EAAE;YAAEN,IAAI,EAAE,gBAAgB;YAAEM,QAAQ,EAAE;UAAQ,CAAC;UACvD,MAAM,EAAE;YAAEN,IAAI,EAAE,gBAAgB;YAAEM,QAAQ,EAAE;UAAU,CAAC;UACvD,MAAM,EAAE;YAAEN,IAAI,EAAE,cAAc;YAAEM,QAAQ,EAAE;UAAQ;QACpD,CAAC;QAED,MAAMC,UAAU,GAAG,EAAE;QACrBC,MAAM,CAACC,OAAO,CAACJ,eAAe,CAAC,CAACK,OAAO,CAAC,CAAC,CAACC,GAAG,EAAEC,IAAI,CAAC,KAAK;UACvD,IAAIrB,SAAS,CAACoB,GAAG,CAAC,IAAIjB,UAAU,CAACH,SAAS,CAACoB,GAAG,CAAC,CAACf,MAAM,CAAC,GAAG,CAAC,EAAE;YAC3D,MAAMG,KAAK,GAAG;cACZA,KAAK,EAAEY,GAAG;cACVX,IAAI,EAAEY,IAAI,CAACZ,IAAI;cACfM,QAAQ,EAAEM,IAAI,CAACN,QAAQ;cACvBV,MAAM,EAAEF,UAAU,CAACH,SAAS,CAACoB,GAAG,CAAC,CAACf,MAAM,CAAC;cACzCK,QAAQ,EAAEV,SAAS,CAACoB,GAAG,CAAC,CAACV,QAAQ;cACjCC,UAAU,EAAE,CAACX,SAAS,CAACoB,GAAG,CAAC,CAACV,QAAQ,GAAGV,SAAS,CAACE,aAAa,GAAG,GAAG,EAAEU,OAAO,CAAC,CAAC,CAAC;cAChFC,IAAI,EAAE,QAAQ;cACdS,GAAG,EAAEtB,SAAS,CAACoB,GAAG,CAAC,CAACE,GAAG,IAAI;YAC7B,CAAC;YAEDhB,MAAM,CAACC,IAAI,CAACC,KAAK,CAAC;YAClBQ,UAAU,CAACT,IAAI,CAACC,KAAK,CAAC;UACxB;QACF,CAAC,CAAC;QACFvB,kBAAkB,CAAC+B,UAAU,CAAC;;QAE9B;QACA,MAAMO,aAAa,GAAG,EAAE;QACxB,IAAIvB,SAAS,CAACwB,YAAY,IAAIxB,SAAS,CAACwB,YAAY,CAACC,YAAY,EAAE;UACjE,IAAIzB,SAAS,CAACwB,YAAY,CAACE,SAAS,IAAI1B,SAAS,CAACwB,YAAY,CAACE,SAAS,CAACC,MAAM,GAAG,CAAC,EAAE;YACnF3B,SAAS,CAACwB,YAAY,CAACE,SAAS,CAACP,OAAO,CAACS,QAAQ,IAAI;cACnD,IAAIA,QAAQ,CAAClB,QAAQ,GAAG,CAAC,EAAE;gBACzB,MAAMmB,cAAc,GAAG;kBACrBrB,KAAK,EAAEoB,QAAQ,CAACE,QAAQ,IAAI,UAAU;kBACtCrB,IAAI,EAAEmB,QAAQ,CAACE,QAAQ,IAAI,sBAAsB;kBACjDf,QAAQ,EAAEa,QAAQ,CAACb,QAAQ,IAAI,KAAK;kBACpCL,QAAQ,EAAEkB,QAAQ,CAAClB,QAAQ;kBAC3BC,UAAU,EAAE,CAACiB,QAAQ,CAAClB,QAAQ,GAAGV,SAAS,CAACE,aAAa,GAAG,GAAG,EAAEU,OAAO,CAAC,CAAC,CAAC;kBAC1EC,IAAI,EAAE,WAAW;kBACjBS,GAAG,EAAEM,QAAQ,CAACN,GAAG,IAAI;gBACvB,CAAC;gBAEDhB,MAAM,CAACC,IAAI,CAACsB,cAAc,CAAC;gBAC3BN,aAAa,CAAChB,IAAI,CAACsB,cAAc,CAAC;cACpC;YACF,CAAC,CAAC;UACJ,CAAC,MAAM,IAAI7B,SAAS,CAACwB,YAAY,CAACd,QAAQ,GAAG,CAAC,EAAE;YAC9C,MAAMmB,cAAc,GAAG;cACrBrB,KAAK,EAAE,IAAI;cACXC,IAAI,EAAE,sBAAsB;cAC5BM,QAAQ,EAAE,KAAK;cACfL,QAAQ,EAAEV,SAAS,CAACwB,YAAY,CAACd,QAAQ;cACzCC,UAAU,EAAE,CAACX,SAAS,CAACwB,YAAY,CAACd,QAAQ,GAAGV,SAAS,CAACE,aAAa,GAAG,GAAG,EAAEU,OAAO,CAAC,CAAC,CAAC;cACxFC,IAAI,EAAE;YACR,CAAC;YAEDP,MAAM,CAACC,IAAI,CAACsB,cAAc,CAAC;YAC3BN,aAAa,CAAChB,IAAI,CAACsB,cAAc,CAAC;UACpC;QACF;QACA1C,qBAAqB,CAACoC,aAAa,CAAC;;QAEpC;QACA,IAAIvB,SAAS,CAAC+B,WAAW,IAAI/B,SAAS,CAAC+B,WAAW,CAACJ,MAAM,GAAG,CAAC,EAAE;UAC7D3B,SAAS,CAAC+B,WAAW,CAACZ,OAAO,CAACX,KAAK,IAAI;YACrC,IAAIA,KAAK,CAACE,QAAQ,GAAG,CAAC,EAAE;cACtBJ,MAAM,CAACC,IAAI,CAAC;gBACVC,KAAK,EAAEA,KAAK,CAACwB,MAAM,IAAI,SAAS;gBAChCvB,IAAI,EAAED,KAAK,CAACC,IAAI,IAAID,KAAK,CAACwB,MAAM,IAAI,eAAe;gBACnD3B,MAAM,EAAEF,UAAU,CAACK,KAAK,CAACH,MAAM,IAAI,CAAC,CAAC;gBACrCK,QAAQ,EAAEF,KAAK,CAACE,QAAQ;gBACxBC,UAAU,EAAE,CAACH,KAAK,CAACE,QAAQ,GAAGV,SAAS,CAACE,aAAa,GAAG,GAAG,EAAEU,OAAO,CAAC,CAAC,CAAC;gBACvEC,IAAI,EAAE;cACR,CAAC,CAAC;YACJ;UACF,CAAC,CAAC;QACJ;QAEAlC,iBAAiB,CAAC2B,MAAM,CAAC;MAC3B;;MAEA;MACA,IAAIR,IAAI,CAACxB,gBAAgB,EAAE;QACzBC,mBAAmB,CAACuB,IAAI,CAACxB,gBAAgB,CAAC;MAC5C;MAEA,OAAOwB,IAAI;IACb,CAAC,CAAC,OAAOmC,GAAG,EAAE;MAAA,IAAAC,aAAA,EAAAC,kBAAA;MACZC,OAAO,CAAClE,KAAK,CAAC,gCAAgC,EAAE+D,GAAG,CAAC;MACpD9D,QAAQ,CAAC,EAAA+D,aAAA,GAAAD,GAAG,CAACrC,QAAQ,cAAAsC,aAAA,wBAAAC,kBAAA,GAAZD,aAAA,CAAcpC,IAAI,cAAAqC,kBAAA,uBAAlBA,kBAAA,CAAoBE,OAAO,KAAI,gCAAgC,CAAC;MAEzEtE,gBAAgB,CAAC;QACf8C,IAAI,EAAE,OAAO;QACbyB,KAAK,EAAE,iBAAiB;QACxBD,OAAO,EAAE;MACX,CAAC,CAAC;MAEF,OAAO,IAAI;IACb,CAAC,SAAS;MACRpE,YAAY,CAAC,KAAK,CAAC;MACnBoB,eAAe,CAAC,KAAK,CAAC;IACxB;EACF,CAAC,EAAE,CAACzB,aAAa,EAAEG,gBAAgB,CAAC,CAAC;;EAErC;AACF;AACA;EACE,MAAMwE,gBAAgB,GAAGpF,WAAW,CAAC,MAAM;IACzCkC,eAAe,CAAC,IAAI,CAAC;IACrB,OAAOK,cAAc,CAAC9B,aAAa,CAAC;EACtC,CAAC,EAAE,CAAC8B,cAAc,EAAE9B,aAAa,CAAC,CAAC;;EAEnC;AACF;AACA;EACE,MAAM4E,iBAAiB,GAAGrF,WAAW,CAAC,MAAM;IAC1CoC,qBAAqB,CAACkD,IAAI,IAAI,CAACA,IAAI,CAAC;EACtC,CAAC,EAAE,EAAE,CAAC;;EAEN;AACF;AACA;EACE,MAAMC,kBAAkB,GAAGvF,WAAW,CAAEwF,QAAQ,IAAK;IACnD,IAAIA,QAAQ,IAAIA,QAAQ,GAAG,CAAC,EAAE;MAC5BlD,sBAAsB,CAACkD,QAAQ,CAAC;IAClC;EACF,CAAC,EAAE,EAAE,CAAC;;EAEN;AACF;AACA;EACE,MAAMC,2BAA2B,GAAGzF,WAAW,CAAC,MAAM;IACpD,IAAI,CAACmB,gBAAgB,IAAIA,gBAAgB,CAACqD,MAAM,GAAG,CAAC,EAAE;MACpD,OAAO;QACLkB,WAAW,EAAE,CAAC;QACdC,YAAY,EAAE,CAAC;QACfC,aAAa,EAAE,CAAC;QAChBC,eAAe,EAAE,CAAC;QAClBC,gBAAgB,EAAE,CAAC;QACnBC,iBAAiB,EAAE;MACrB,CAAC;IACH;;IAEA;IACA,MAAMC,aAAa,GAAG,CAAC,GAAG7E,gBAAgB,CAAC,CAAC8E,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KACpD,IAAIvD,IAAI,CAACsD,CAAC,CAACE,IAAI,CAAC,GAAG,IAAIxD,IAAI,CAACuD,CAAC,CAACC,IAAI,CACpC,CAAC;IAED,MAAMC,YAAY,GAAGL,aAAa,CAACA,aAAa,CAACxB,MAAM,GAAG,CAAC,CAAC,CAAC8B,KAAK;;IAElE;IACA,MAAMC,GAAG,GAAG,IAAI3D,IAAI,CAAC,CAAC;IACtB,MAAM4D,SAAS,GAAG,IAAI5D,IAAI,CAAC2D,GAAG,CAACE,OAAO,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC;IAC/D,MAAMC,UAAU,GAAG,IAAI9D,IAAI,CAAC2D,GAAG,CAACE,OAAO,CAAC,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC;IACpE,MAAME,WAAW,GAAG,IAAI/D,IAAI,CAAC2D,GAAG,CAACE,OAAO,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC;;IAEtE;IACA,MAAMG,gBAAgB,GAAIC,UAAU,IAAK;MACvC,OAAOb,aAAa,CAACc,MAAM,CAAC,CAACC,OAAO,EAAEC,OAAO,KAAK;QAChD,MAAMC,WAAW,GAAG,IAAIrE,IAAI,CAACoE,OAAO,CAACZ,IAAI,CAAC;QAC1C,MAAMc,WAAW,GAAG,IAAItE,IAAI,CAACmE,OAAO,CAACX,IAAI,CAAC;QAE1C,OAAOe,IAAI,CAACC,GAAG,CAACH,WAAW,GAAGJ,UAAU,CAAC,GAAGM,IAAI,CAACC,GAAG,CAACF,WAAW,GAAGL,UAAU,CAAC,GAC1EG,OAAO,GACPD,OAAO;MACb,CAAC,CAAC;IACJ,CAAC;IAED,MAAMM,QAAQ,GAAGT,gBAAgB,CAACJ,SAAS,CAAC,CAACF,KAAK;IAClD,MAAMgB,SAAS,GAAGV,gBAAgB,CAACF,UAAU,CAAC,CAACJ,KAAK;IACpD,MAAMiB,UAAU,GAAGX,gBAAgB,CAACD,WAAW,CAAC,CAACL,KAAK;;IAEtD;IACA,MAAMZ,WAAW,GAAGW,YAAY,GAAGgB,QAAQ;IAC3C,MAAM1B,YAAY,GAAGU,YAAY,GAAGiB,SAAS;IAC7C,MAAM1B,aAAa,GAAGS,YAAY,GAAGkB,UAAU;;IAE/C;IACA,MAAM1B,eAAe,GAAGwB,QAAQ,KAAK,CAAC,GAAI3B,WAAW,GAAG2B,QAAQ,GAAI,GAAG,GAAG,CAAC;IAC3E,MAAMvB,gBAAgB,GAAGwB,SAAS,KAAK,CAAC,GAAI3B,YAAY,GAAG2B,SAAS,GAAI,GAAG,GAAG,CAAC;IAC/E,MAAMvB,iBAAiB,GAAGwB,UAAU,KAAK,CAAC,GAAI3B,aAAa,GAAG2B,UAAU,GAAI,GAAG,GAAG,CAAC;IAEnF,OAAO;MACL7B,WAAW;MACXC,YAAY;MACZC,aAAa;MACbC,eAAe;MACfC,gBAAgB;MAChBC;IACF,CAAC;EACH,CAAC,EAAE,CAAC5E,gBAAgB,CAAC,CAAC;;EAEtB;EACApB,SAAS,CAAC,MAAM;IACd,IAAIU,aAAa,EAAE;MACjB8B,cAAc,CAAC9B,aAAa,CAAC;IAC/B;EACF,CAAC,EAAE,CAACA,aAAa,EAAE8B,cAAc,CAAC,CAAC;;EAEnC;EACAxC,SAAS,CAAC,MAAM;IACd,IAAIyH,UAAU;IAEd,IAAIrF,kBAAkB,IAAI1B,aAAa,EAAE;MACvC+G,UAAU,GAAGC,WAAW,CAAC,MAAM;QAC7BrC,gBAAgB,CAAC,CAAC;MACpB,CAAC,EAAE/C,mBAAmB,CAAC;IACzB;IAEA,OAAO,MAAM;MACX,IAAImF,UAAU,EAAE;QACdE,aAAa,CAACF,UAAU,CAAC;MAC3B;IACF,CAAC;EACH,CAAC,EAAE,CAACrF,kBAAkB,EAAEE,mBAAmB,EAAE+C,gBAAgB,EAAE3E,aAAa,CAAC,CAAC;;EAE9E;EACA,OAAO;IACLI,SAAS;IACToB,YAAY;IACZlB,KAAK;IACLE,aAAa;IACbE,gBAAgB;IAChBE,WAAW;IACXE,cAAc;IACdE,UAAU;IACVE,UAAU;IACVE,eAAe;IACfE,kBAAkB;IAClBQ,cAAc;IACd6C,gBAAgB;IAChBjD,kBAAkB;IAClBE,mBAAmB;IACnBgD,iBAAiB;IACjBE,kBAAkB;IAClBoC,kBAAkB,EAAElC,2BAA2B,CAAC,CAAC;IACjDmC,OAAO,EAAE,CAAC,CAAC3G;EACb,CAAC;AACH,CAAC;AAACV,EAAA,CAjTIF,YAAY;AAmTlB,MAAMwH,gBAAgB,GAAGA,CAAC,GAAGC,IAAI,KAAK;EACpC;AAAA,CACD;AAED,eAAeD,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}