{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useContext, useCallback } from 'react';\nimport { NotificationContext } from '../context/NotificationContext';\nimport { WalletContext } from '../context/WalletContext';\nimport { TransactionContext } from '../context/TransactionContext';\n\n/**\r\n * Custom hook for handling blockchain transactions\r\n * Manages transaction lifecycle from preparation to confirmation\r\n */\nconst useTransactions = () => {\n  _s();\n  const {\n    setNotification\n  } = useContext(NotificationContext);\n  const {\n    walletAddress,\n    walletProvider,\n    networkType\n  } = useContext(WalletContext);\n  const {\n    addTransaction,\n    updateTransaction,\n    transactions\n  } = useContext(TransactionContext);\n  const addTransactionToQueue = tx => {\n    // Implementation\n  };\n  const isTransactionPending = txId => {\n    // Implementation\n  };\n  const getTransaction = txId => {\n    // Implementation\n  };\n\n  // Transaction execution state\n  const [executing, setExecuting] = useState(false);\n  const [currentTxId, setCurrentTxId] = useState(null);\n  const [txProgress, setTxProgress] = useState(0);\n  const [txStatus, setTxStatus] = useState(null);\n  const [abortController, setAbortController] = useState(null);\n\n  // Contract addresses for Aptos protocols\n  const contractAddresses = {\n    amnis: \"0x111ae3e5bc816a5e63c2da97d0aa3886519e0cd5e4b046659fa35796bd11542a\",\n    thala: \"0xfaf4e633ae9eb31366c9ca24214231760926576c7b625313b3688b5e900731f6\",\n    tortuga: \"0x952c1b1fc8eb75ee80f432c9d0a84fcda1d5c7481501a7eca9199f1596a60b53\",\n    ditto: \"0xd11107bdf0d6d7040c6c0bfbdecb6545191fdf13e8d8d259952f53e1713f61b5\",\n    aries: \"0x9770fa9c725cbd97eb50b2be5f7416efdfd1f1554beb0750d4dae4c64e860da3\",\n    echo: \"0xeab7ea4d635b6b6add79d5045c4a45d8148d88287b1cfa1c3b6a4b56f46839ed\",\n    pancakeswap: \"0xc7efb4076dbe143cbcd98cfaaa929ecfc8f299203dfff63b95ccb6bfe19850fa\",\n    liquidswap: \"0x190d44266241744264b964a37b8f09863167a12d3e70cda39376cfb4e3561e12\",\n    cetus: \"0x27156bd56eb5637b9adde4d915b596f92d2f28f0ade2eaef48fa73e360e4e8a6\"\n  };\n\n  /**\r\n   * Execute a single operation on a DeFi protocol\r\n   * @param {string} protocol - Protocol name (e.g., 'amnis', 'thala')\r\n   * @param {string} type - Operation type (e.g., 'stake', 'unstake', 'lend')\r\n   * @param {string|number} amount - Amount of tokens for the operation\r\n   * @param {string} [contractAddress] - Override contract address\r\n   * @param {string} [functionName] - Override function name\r\n   * @returns {Promise<Object>} - Transaction result\r\n   */\n  const executeOperation = useCallback(async (protocol, type, amount, contractAddress, functionName) => {\n    if (!walletAddress || !walletProvider) {\n      setNotification({\n        type: 'error',\n        message: 'Please connect your wallet first'\n      });\n      throw new Error('Wallet not connected');\n    }\n    if (!amount || isNaN(parseFloat(amount)) || parseFloat(amount) <= 0) {\n      setNotification({\n        type: 'error',\n        message: 'Invalid amount for transaction'\n      });\n      throw new Error('Invalid amount');\n    }\n\n    // Generate transaction ID\n    const txId = `${Date.now()}-${protocol}-${type}`;\n    setCurrentTxId(txId);\n\n    // Determine contract address if not provided\n    if (!contractAddress) {\n      contractAddress = contractAddresses[protocol.toLowerCase()];\n      if (!contractAddress) {\n        setNotification({\n          type: 'error',\n          message: `Unknown protocol: ${protocol}`\n        });\n        throw new Error(`Unknown protocol: ${protocol}`);\n      }\n    }\n\n    // Determine function name if not provided\n    if (!functionName) {\n      functionName = determineFunctionName(protocol, type);\n    }\n    try {\n      var _result$transaction;\n      setExecuting(true);\n      setTxProgress(10);\n      setTxStatus('preparing');\n\n      // Create new transaction in context\n      addTransaction({\n        id: txId,\n        protocol,\n        type,\n        amount: parseFloat(amount),\n        status: 'preparing',\n        timestamp: new Date().toISOString()\n      });\n\n      // Convert APT to octas (10^8 multiplication for Aptos)\n      const amountInOctas = Math.floor(parseFloat(amount) * 100000000).toString();\n\n      // Prepare transaction payload\n      const transaction = {\n        function: `${contractAddress}${functionName}`,\n        type_arguments: [],\n        arguments: [amountInOctas]\n      };\n      setTxProgress(30);\n      setTxStatus('signing');\n      updateTransaction(txId, {\n        status: 'signing'\n      });\n\n      // Display notification\n      setNotification({\n        type: 'info',\n        message: `Preparing to ${type} on ${protocol}. Please confirm in your wallet.`\n      });\n\n      // Sign and submit transaction\n      const result = await walletProvider.signAndSubmitTransaction(transaction);\n\n      // Extract transaction hash\n      const hash = result.hash || result.txHash || ((_result$transaction = result.transaction) === null || _result$transaction === void 0 ? void 0 : _result$transaction.hash);\n      if (!hash) {\n        throw new Error('Transaction submitted but no hash returned');\n      }\n      setTxProgress(50);\n      setTxStatus('submitted');\n      updateTransaction(txId, {\n        status: 'submitted',\n        hash\n      });\n      setNotification({\n        type: 'info',\n        message: `Transaction submitted, waiting for confirmation...`\n      });\n\n      // Poll for transaction status\n      const confirmation = await pollTransactionStatus(hash);\n      setTxProgress(100);\n\n      // Check if transaction was successful\n      if (confirmation.success) {\n        setTxStatus('confirmed');\n        updateTransaction(txId, {\n          status: 'confirmed',\n          result: confirmation\n        });\n        setNotification({\n          type: 'success',\n          message: `Successfully executed ${type} operation on ${protocol}`\n        });\n      } else {\n        setTxStatus('failed');\n        updateTransaction(txId, {\n          status: 'failed',\n          error: confirmation.vm_status || 'Transaction failed on-chain'\n        });\n        setNotification({\n          type: 'error',\n          message: `Transaction failed: ${confirmation.vm_status || 'Unknown error'}`\n        });\n        throw new Error(confirmation.vm_status || 'Transaction failed on-chain');\n      }\n      return {\n        success: confirmation.success,\n        txId,\n        hash,\n        result: confirmation\n      };\n    } catch (error) {\n      console.error(`Error executing ${type} on ${protocol}:`, error);\n      let errorMessage = error.message;\n\n      // Handle user rejection separately\n      if (errorMessage.includes('User rejected') || errorMessage.includes('Rejected by user') || errorMessage.includes('cancelled')) {\n        setTxStatus('rejected');\n        updateTransaction(txId, {\n          status: 'rejected',\n          error: 'Transaction rejected by user'\n        });\n        setNotification({\n          type: 'warning',\n          message: 'Transaction rejected by user'\n        });\n      } else {\n        setTxStatus('failed');\n        updateTransaction(txId, {\n          status: 'failed',\n          error: errorMessage\n        });\n        setNotification({\n          type: 'error',\n          message: `Failed to execute operation: ${errorMessage}`\n        });\n      }\n      throw error;\n    } finally {\n      setExecuting(false);\n      setCurrentTxId(null);\n    }\n  }, [walletAddress, walletProvider, addTransaction, updateTransaction, setNotification]);\n\n  /**\r\n   * Execute multiple operations in sequence as a strategy\r\n   * @param {Array} operations - Array of operation objects\r\n   * @param {Object} options - Execution options\r\n   * @returns {Promise<Object>} - Results of all operations\r\n   */\n  const executeStrategy = useCallback(async (operations, options = {}) => {\n    if (!walletAddress || !walletProvider) {\n      setNotification({\n        type: 'error',\n        message: 'Please connect your wallet first'\n      });\n      throw new Error('Wallet not connected');\n    }\n    if (!operations || !Array.isArray(operations) || operations.length === 0) {\n      setNotification({\n        type: 'error',\n        message: 'No operations to execute'\n      });\n      throw new Error('No operations provided');\n    }\n\n    // Create new abort controller for this strategy execution\n    const controller = new AbortController();\n    setAbortController(controller);\n\n    // Strategy execution ID\n    const strategyId = `strategy-${Date.now()}`;\n    try {\n      setExecuting(true);\n      setTxProgress(5);\n      setTxStatus('preparing');\n\n      // Show notification about strategy execution\n      setNotification({\n        type: 'info',\n        message: `Executing strategy with ${operations.length} operations. Please confirm each transaction.`\n      });\n\n      // Optimize operation order (withdrawals/unstakes before deposits/stakes)\n      const optimizedOperations = optimizeOperationOrder(operations);\n\n      // Results objects\n      const results = {\n        strategyId,\n        operations: [],\n        failedOperations: [],\n        success: true,\n        startTime: Date.now()\n      };\n      setTxProgress(10);\n\n      // Execute operations in sequence\n      for (let i = 0; i < optimizedOperations.length; i++) {\n        // Check if execution was aborted\n        if (controller.signal.aborted) {\n          throw new Error('Strategy execution was aborted by user');\n        }\n        const operation = optimizedOperations[i];\n        const progressPerOperation = 80 / optimizedOperations.length;\n        const baseProgress = 10 + i * progressPerOperation;\n        setTxProgress(baseProgress);\n        setTxStatus(`executing_${i + 1}_of_${optimizedOperations.length}`);\n        try {\n          // Execute the operation\n          const result = await executeOperation(operation.protocol, operation.type, operation.amount, operation.contractAddress, operation.functionName);\n\n          // Add to successful operations\n          results.operations.push({\n            ...operation,\n            status: 'success',\n            result\n          });\n          setTxProgress(baseProgress + progressPerOperation);\n        } catch (error) {\n          // Add to failed operations\n          results.failedOperations.push({\n            ...operation,\n            status: 'failed',\n            error: error.message\n          });\n          results.success = false;\n\n          // Check if we should abort the whole strategy\n          if (shouldAbortStrategy(operation, results, options)) {\n            throw new Error(`Critical operation failed: ${error.message}`);\n          }\n\n          // Show warning but continue with next operation\n          setNotification({\n            type: 'warning',\n            message: `Operation ${i + 1} failed, continuing with remaining operations`\n          });\n        }\n\n        // Add a slight delay between operations\n        if (i < optimizedOperations.length - 1) {\n          await new Promise(resolve => setTimeout(resolve, options.delay || 500));\n        }\n      }\n      setTxProgress(100);\n      setTxStatus(results.success ? 'completed' : 'completed_with_errors');\n\n      // Final notification\n      setNotification({\n        type: results.success ? 'success' : 'warning',\n        message: results.success ? `Strategy executed successfully! ${results.operations.length} operations completed.` : `Strategy execution completed with ${results.failedOperations.length} failures.`\n      });\n      results.endTime = Date.now();\n      results.duration = results.endTime - results.startTime;\n      return results;\n    } catch (error) {\n      console.error('Strategy execution error:', error);\n      setTxProgress(100);\n      setTxStatus('failed');\n      setNotification({\n        type: 'error',\n        message: `Strategy execution failed: ${error.message}`\n      });\n      throw error;\n    } finally {\n      setExecuting(false);\n      setAbortController(null);\n    }\n  }, [walletAddress, walletProvider, executeOperation, setNotification]);\n\n  /**\r\n   * Abort the current strategy execution\r\n   */\n  const abortExecution = useCallback(() => {\n    if (abortController) {\n      abortController.abort();\n      setNotification({\n        type: 'warning',\n        message: 'Execution aborted by user'\n      });\n    }\n  }, [abortController, setNotification]);\n\n  /**\r\n   * Poll for transaction status until confirmed\r\n   * @param {string} txHash - Transaction hash to check\r\n   * @param {number} maxAttempts - Maximum polling attempts\r\n   * @param {number} interval - Polling interval in ms\r\n   * @returns {Promise<Object>} - Transaction status\r\n   */\n  const pollTransactionStatus = async (txHash, maxAttempts = 30, interval = 2000) => {\n    for (let attempt = 0; attempt < maxAttempts; attempt++) {\n      try {\n        // Use Aptos explorer API to fetch transaction status\n        const response = await fetch(`https://fullnode.${networkType || 'mainnet'}.aptoslabs.com/v1/transactions/by_hash/${txHash}`);\n        if (!response.ok) {\n          console.warn(`Error fetching transaction status: ${response.status}`);\n          await new Promise(resolve => setTimeout(resolve, interval));\n          continue;\n        }\n        const data = await response.json();\n\n        // If transaction is found and has success field, we're done\n        if (data && data.success !== undefined) {\n          return data;\n        }\n      } catch (error) {\n        console.warn(`Error polling transaction (attempt ${attempt + 1}):`, error.message);\n      }\n\n      // Wait before checking again\n      await new Promise(resolve => setTimeout(resolve, interval));\n    }\n\n    // If we've reached maximum attempts without conclusion\n    throw new Error('Timed out waiting for transaction confirmation');\n  };\n\n  /**\r\n   * Determine if we should abort the entire strategy after an operation fails\r\n   * @param {Object} failedOperation - The operation that failed\r\n   * @param {Object} currentResults - Current execution results\r\n   * @param {Object} options - Strategy execution options\r\n   * @returns {boolean} - Whether to abort\r\n   */\n  const shouldAbortStrategy = (failedOperation, currentResults, options) => {\n    // Always abort if explicitly marked as critical\n    if (failedOperation.critical) {\n      return true;\n    }\n\n    // Check if we've exceeded the failure threshold\n    const totalOps = currentResults.operations.length + currentResults.failedOperations.length;\n    const failureRate = currentResults.failedOperations.length / totalOps;\n\n    // Abort if more than 40% of operations have failed (or custom threshold)\n    const failureThreshold = options.failureThreshold || 0.4;\n    if (failureRate > failureThreshold && currentResults.failedOperations.length >= 2) {\n      return true;\n    }\n    return false;\n  };\n\n  /**\r\n   * Optimize the order of operations for execution\r\n   * @param {Array} operations - Operations to optimize\r\n   * @returns {Array} - Optimized operations\r\n   */\n  const optimizeOperationOrder = operations => {\n    if (!operations || operations.length <= 1) return operations;\n\n    // First do all operations that free up APT\n    const withdrawTypes = ['unstake', 'withdraw', 'removeliquidity'];\n    const withdrawOps = operations.filter(op => withdrawTypes.includes(op.type.toLowerCase())).sort((a, b) => parseFloat(b.amount) - parseFloat(a.amount));\n    const addOps = operations.filter(op => !withdrawTypes.includes(op.type.toLowerCase())).sort((a, b) => parseFloat(b.amount) - parseFloat(a.amount));\n    return [...withdrawOps, ...addOps];\n  };\n\n  /**\r\n   * Determine the function name for a protocol operation\r\n   * @param {string} protocol - Protocol name\r\n   * @param {string} operationType - Operation type\r\n   * @returns {string} - Function name\r\n   */\n  const determineFunctionName = (protocol, operationType) => {\n    var _functionMappings$pro;\n    const functionMappings = {\n      'amnis': {\n        'stake': '::staking::stake',\n        'unstake': '::staking::unstake',\n        'lend': '::lending::supply',\n        'withdraw': '::lending::withdraw',\n        'addLiquidity': '::router::add_liquidity',\n        'removeLiquidity': '::router::remove_liquidity'\n      },\n      'thala': {\n        'stake': '::staking::stake_apt',\n        'unstake': '::staking::unstake_apt',\n        'lend': '::lending::supply_apt',\n        'withdraw': '::lending::withdraw_apt',\n        'addLiquidity': '::router::add_liquidity',\n        'removeLiquidity': '::router::remove_liquidity'\n      },\n      'tortuga': {\n        'stake': '::staking::stake_apt',\n        'unstake': '::staking::unstake_apt'\n      },\n      'echo': {\n        'lend': '::lending::supply',\n        'withdraw': '::lending::withdraw'\n      },\n      'ditto': {\n        'stake': '::staking::stake',\n        'unstake': '::staking::unstake'\n      },\n      'aries': {\n        'lend': '::lending::supply',\n        'withdraw': '::lending::withdraw'\n      },\n      'cetus': {\n        'addLiquidity': '::pool::add_liquidity',\n        'removeLiquidity': '::pool::remove_liquidity'\n      },\n      'pancakeswap': {\n        'addLiquidity': '::router::add_liquidity',\n        'removeLiquidity': '::router::remove_liquidity',\n        'swap': '::router::swap_exact_input'\n      },\n      'liquidswap': {\n        'addLiquidity': '::router::add_liquidity',\n        'removeLiquidity': '::router::remove_liquidity'\n      }\n    };\n    const protocolLower = protocol.toLowerCase();\n    const operationLower = operationType.toLowerCase();\n\n    // If we have a specific mapping for this protocol and operation type, use it\n    if ((_functionMappings$pro = functionMappings[protocolLower]) !== null && _functionMappings$pro !== void 0 && _functionMappings$pro[operationLower]) {\n      return functionMappings[protocolLower][operationLower];\n    }\n\n    // Otherwise use general mappings\n    switch (operationLower) {\n      case 'stake':\n        return '::staking::stake';\n      case 'unstake':\n        return '::staking::unstake';\n      case 'lend':\n        return '::lending::supply';\n      case 'withdraw':\n        return '::lending::withdraw';\n      case 'addliquidity':\n        return '::router::add_liquidity';\n      case 'removeliquidity':\n        return '::router::remove_liquidity';\n      case 'deposit':\n        return '::yield::deposit';\n      case 'swap':\n        return '::router::swap_exact_input';\n      default:\n        return `::${operationLower}::execute`;\n    }\n  };\n\n  // End of src/hooks/useTransactions.js\n  return {\n    executeOperation,\n    executeStrategy,\n    addTransactionToQueue,\n    isTransactionPending,\n    getTransaction\n  };\n};\n_s(useTransactions, \"7Cw8vYouaZbXodKU2TecxLhYfNo=\");\nexport default useTransactions;","map":{"version":3,"names":["useState","useEffect","useContext","useCallback","NotificationContext","WalletContext","TransactionContext","useTransactions","_s","setNotification","walletAddress","walletProvider","networkType","addTransaction","updateTransaction","transactions","addTransactionToQueue","tx","isTransactionPending","txId","getTransaction","executing","setExecuting","currentTxId","setCurrentTxId","txProgress","setTxProgress","txStatus","setTxStatus","abortController","setAbortController","contractAddresses","amnis","thala","tortuga","ditto","aries","echo","pancakeswap","liquidswap","cetus","executeOperation","protocol","type","amount","contractAddress","functionName","message","Error","isNaN","parseFloat","Date","now","toLowerCase","determineFunctionName","_result$transaction","id","status","timestamp","toISOString","amountInOctas","Math","floor","toString","transaction","function","type_arguments","arguments","result","signAndSubmitTransaction","hash","txHash","confirmation","pollTransactionStatus","success","error","vm_status","console","errorMessage","includes","executeStrategy","operations","options","Array","isArray","length","controller","AbortController","strategyId","optimizedOperations","optimizeOperationOrder","results","failedOperations","startTime","i","signal","aborted","operation","progressPerOperation","baseProgress","push","shouldAbortStrategy","Promise","resolve","setTimeout","delay","endTime","duration","abortExecution","abort","maxAttempts","interval","attempt","response","fetch","ok","warn","data","json","undefined","failedOperation","currentResults","critical","totalOps","failureRate","failureThreshold","withdrawTypes","withdrawOps","filter","op","sort","a","b","addOps","operationType","_functionMappings$pro","functionMappings","protocolLower","operationLower"],"sources":["/home/ck/compoundefi/client/src/hooks/useTransactions.js"],"sourcesContent":["import { useState, useEffect, useContext, useCallback } from 'react';\r\nimport { NotificationContext } from '../context/NotificationContext';\r\nimport { WalletContext } from '../context/WalletContext';\r\nimport { TransactionContext } from '../context/TransactionContext';\r\n\r\n/**\r\n * Custom hook for handling blockchain transactions\r\n * Manages transaction lifecycle from preparation to confirmation\r\n */\r\nconst useTransactions = () => {\r\n  const { setNotification } = useContext(NotificationContext);\r\n  const { walletAddress, walletProvider, networkType } = useContext(WalletContext);\r\n  const { addTransaction, updateTransaction, transactions } = useContext(TransactionContext);\r\n\r\n  const addTransactionToQueue = (tx) => {\r\n  // Implementation\r\n};\r\n\r\nconst isTransactionPending = (txId) => {\r\n  // Implementation\r\n};\r\n\r\nconst getTransaction = (txId) => {\r\n  // Implementation\r\n};\r\n  \r\n  // Transaction execution state\r\n  const [executing, setExecuting] = useState(false);\r\n  const [currentTxId, setCurrentTxId] = useState(null);\r\n  const [txProgress, setTxProgress] = useState(0);\r\n  const [txStatus, setTxStatus] = useState(null);\r\n  const [abortController, setAbortController] = useState(null);\r\n  \r\n  // Contract addresses for Aptos protocols\r\n  const contractAddresses = {\r\n    amnis: \"0x111ae3e5bc816a5e63c2da97d0aa3886519e0cd5e4b046659fa35796bd11542a\",\r\n    thala: \"0xfaf4e633ae9eb31366c9ca24214231760926576c7b625313b3688b5e900731f6\",\r\n    tortuga: \"0x952c1b1fc8eb75ee80f432c9d0a84fcda1d5c7481501a7eca9199f1596a60b53\",\r\n    ditto: \"0xd11107bdf0d6d7040c6c0bfbdecb6545191fdf13e8d8d259952f53e1713f61b5\",\r\n    aries: \"0x9770fa9c725cbd97eb50b2be5f7416efdfd1f1554beb0750d4dae4c64e860da3\",\r\n    echo: \"0xeab7ea4d635b6b6add79d5045c4a45d8148d88287b1cfa1c3b6a4b56f46839ed\",\r\n    pancakeswap: \"0xc7efb4076dbe143cbcd98cfaaa929ecfc8f299203dfff63b95ccb6bfe19850fa\",\r\n    liquidswap: \"0x190d44266241744264b964a37b8f09863167a12d3e70cda39376cfb4e3561e12\",\r\n    cetus: \"0x27156bd56eb5637b9adde4d915b596f92d2f28f0ade2eaef48fa73e360e4e8a6\"\r\n  };\r\n\r\n  /**\r\n   * Execute a single operation on a DeFi protocol\r\n   * @param {string} protocol - Protocol name (e.g., 'amnis', 'thala')\r\n   * @param {string} type - Operation type (e.g., 'stake', 'unstake', 'lend')\r\n   * @param {string|number} amount - Amount of tokens for the operation\r\n   * @param {string} [contractAddress] - Override contract address\r\n   * @param {string} [functionName] - Override function name\r\n   * @returns {Promise<Object>} - Transaction result\r\n   */\r\n  const executeOperation = useCallback(async (\r\n    protocol, \r\n    type, \r\n    amount, \r\n    contractAddress, \r\n    functionName\r\n  ) => {\r\n    if (!walletAddress || !walletProvider) {\r\n      setNotification({\r\n        type: 'error',\r\n        message: 'Please connect your wallet first'\r\n      });\r\n      throw new Error('Wallet not connected');\r\n    }\r\n    \r\n    if (!amount || isNaN(parseFloat(amount)) || parseFloat(amount) <= 0) {\r\n      setNotification({\r\n        type: 'error',\r\n        message: 'Invalid amount for transaction'\r\n      });\r\n      throw new Error('Invalid amount');\r\n    }\r\n    \r\n    // Generate transaction ID\r\n    const txId = `${Date.now()}-${protocol}-${type}`;\r\n    setCurrentTxId(txId);\r\n    \r\n    // Determine contract address if not provided\r\n    if (!contractAddress) {\r\n      contractAddress = contractAddresses[protocol.toLowerCase()];\r\n      if (!contractAddress) {\r\n        setNotification({\r\n          type: 'error',\r\n          message: `Unknown protocol: ${protocol}`\r\n        });\r\n        throw new Error(`Unknown protocol: ${protocol}`);\r\n      }\r\n    }\r\n    \r\n    // Determine function name if not provided\r\n    if (!functionName) {\r\n      functionName = determineFunctionName(protocol, type);\r\n    }\r\n    \r\n    try {\r\n      setExecuting(true);\r\n      setTxProgress(10);\r\n      setTxStatus('preparing');\r\n      \r\n      // Create new transaction in context\r\n      addTransaction({\r\n        id: txId,\r\n        protocol,\r\n        type,\r\n        amount: parseFloat(amount),\r\n        status: 'preparing',\r\n        timestamp: new Date().toISOString()\r\n      });\r\n      \r\n      // Convert APT to octas (10^8 multiplication for Aptos)\r\n      const amountInOctas = Math.floor(parseFloat(amount) * 100000000).toString();\r\n      \r\n      // Prepare transaction payload\r\n      const transaction = {\r\n        function: `${contractAddress}${functionName}`,\r\n        type_arguments: [],\r\n        arguments: [amountInOctas]\r\n      };\r\n      \r\n      setTxProgress(30);\r\n      setTxStatus('signing');\r\n      updateTransaction(txId, { status: 'signing' });\r\n      \r\n      // Display notification\r\n      setNotification({\r\n        type: 'info',\r\n        message: `Preparing to ${type} on ${protocol}. Please confirm in your wallet.`\r\n      });\r\n      \r\n      // Sign and submit transaction\r\n      const result = await walletProvider.signAndSubmitTransaction(transaction);\r\n      \r\n      // Extract transaction hash\r\n      const hash = result.hash || result.txHash || result.transaction?.hash;\r\n      if (!hash) {\r\n        throw new Error('Transaction submitted but no hash returned');\r\n      }\r\n      \r\n      setTxProgress(50);\r\n      setTxStatus('submitted');\r\n      updateTransaction(txId, { \r\n        status: 'submitted',\r\n        hash\r\n      });\r\n      \r\n      setNotification({\r\n        type: 'info',\r\n        message: `Transaction submitted, waiting for confirmation...`\r\n      });\r\n      \r\n      // Poll for transaction status\r\n      const confirmation = await pollTransactionStatus(hash);\r\n      \r\n      setTxProgress(100);\r\n      \r\n      // Check if transaction was successful\r\n      if (confirmation.success) {\r\n        setTxStatus('confirmed');\r\n        updateTransaction(txId, { \r\n          status: 'confirmed',\r\n          result: confirmation\r\n        });\r\n        \r\n        setNotification({\r\n          type: 'success',\r\n          message: `Successfully executed ${type} operation on ${protocol}`\r\n        });\r\n      } else {\r\n        setTxStatus('failed');\r\n        updateTransaction(txId, { \r\n          status: 'failed',\r\n          error: confirmation.vm_status || 'Transaction failed on-chain'\r\n        });\r\n        \r\n        setNotification({\r\n          type: 'error',\r\n          message: `Transaction failed: ${confirmation.vm_status || 'Unknown error'}`\r\n        });\r\n        \r\n        throw new Error(confirmation.vm_status || 'Transaction failed on-chain');\r\n      }\r\n      \r\n      return {\r\n        success: confirmation.success,\r\n        txId,\r\n        hash,\r\n        result: confirmation\r\n      };\r\n    } catch (error) {\r\n      console.error(`Error executing ${type} on ${protocol}:`, error);\r\n      \r\n      let errorMessage = error.message;\r\n      \r\n      // Handle user rejection separately\r\n      if (errorMessage.includes('User rejected') || \r\n          errorMessage.includes('Rejected by user') ||\r\n          errorMessage.includes('cancelled')) {\r\n        setTxStatus('rejected');\r\n        updateTransaction(txId, { \r\n          status: 'rejected',\r\n          error: 'Transaction rejected by user'\r\n        });\r\n        \r\n        setNotification({\r\n          type: 'warning',\r\n          message: 'Transaction rejected by user'\r\n        });\r\n      } else {\r\n        setTxStatus('failed');\r\n        updateTransaction(txId, { \r\n          status: 'failed',\r\n          error: errorMessage\r\n        });\r\n        \r\n        setNotification({\r\n          type: 'error',\r\n          message: `Failed to execute operation: ${errorMessage}`\r\n        });\r\n      }\r\n      \r\n      throw error;\r\n    } finally {\r\n      setExecuting(false);\r\n      setCurrentTxId(null);\r\n    }\r\n  }, [walletAddress, walletProvider, addTransaction, updateTransaction, setNotification]);\r\n\r\n  /**\r\n   * Execute multiple operations in sequence as a strategy\r\n   * @param {Array} operations - Array of operation objects\r\n   * @param {Object} options - Execution options\r\n   * @returns {Promise<Object>} - Results of all operations\r\n   */\r\n  const executeStrategy = useCallback(async (operations, options = {}) => {\r\n    if (!walletAddress || !walletProvider) {\r\n      setNotification({\r\n        type: 'error',\r\n        message: 'Please connect your wallet first'\r\n      });\r\n      throw new Error('Wallet not connected');\r\n    }\r\n    \r\n    if (!operations || !Array.isArray(operations) || operations.length === 0) {\r\n      setNotification({\r\n        type: 'error',\r\n        message: 'No operations to execute'\r\n      });\r\n      throw new Error('No operations provided');\r\n    }\r\n    \r\n    // Create new abort controller for this strategy execution\r\n    const controller = new AbortController();\r\n    setAbortController(controller);\r\n    \r\n    // Strategy execution ID\r\n    const strategyId = `strategy-${Date.now()}`;\r\n    \r\n    try {\r\n      setExecuting(true);\r\n      setTxProgress(5);\r\n      setTxStatus('preparing');\r\n      \r\n      // Show notification about strategy execution\r\n      setNotification({\r\n        type: 'info',\r\n        message: `Executing strategy with ${operations.length} operations. Please confirm each transaction.`\r\n      });\r\n      \r\n      // Optimize operation order (withdrawals/unstakes before deposits/stakes)\r\n      const optimizedOperations = optimizeOperationOrder(operations);\r\n      \r\n      // Results objects\r\n      const results = {\r\n        strategyId,\r\n        operations: [],\r\n        failedOperations: [],\r\n        success: true,\r\n        startTime: Date.now()\r\n      };\r\n      \r\n      setTxProgress(10);\r\n      \r\n      // Execute operations in sequence\r\n      for (let i = 0; i < optimizedOperations.length; i++) {\r\n        // Check if execution was aborted\r\n        if (controller.signal.aborted) {\r\n          throw new Error('Strategy execution was aborted by user');\r\n        }\r\n        \r\n        const operation = optimizedOperations[i];\r\n        const progressPerOperation = 80 / optimizedOperations.length;\r\n        const baseProgress = 10 + (i * progressPerOperation);\r\n        \r\n        setTxProgress(baseProgress);\r\n        setTxStatus(`executing_${i + 1}_of_${optimizedOperations.length}`);\r\n        \r\n        try {\r\n          // Execute the operation\r\n          const result = await executeOperation(\r\n            operation.protocol,\r\n            operation.type,\r\n            operation.amount,\r\n            operation.contractAddress,\r\n            operation.functionName\r\n          );\r\n          \r\n          // Add to successful operations\r\n          results.operations.push({\r\n            ...operation,\r\n            status: 'success',\r\n            result\r\n          });\r\n          \r\n          setTxProgress(baseProgress + progressPerOperation);\r\n        } catch (error) {\r\n          // Add to failed operations\r\n          results.failedOperations.push({\r\n            ...operation,\r\n            status: 'failed',\r\n            error: error.message\r\n          });\r\n          \r\n          results.success = false;\r\n          \r\n          // Check if we should abort the whole strategy\r\n          if (shouldAbortStrategy(operation, results, options)) {\r\n            throw new Error(`Critical operation failed: ${error.message}`);\r\n          }\r\n          \r\n          // Show warning but continue with next operation\r\n          setNotification({\r\n            type: 'warning',\r\n            message: `Operation ${i + 1} failed, continuing with remaining operations`\r\n          });\r\n        }\r\n        \r\n        // Add a slight delay between operations\r\n        if (i < optimizedOperations.length - 1) {\r\n          await new Promise(resolve => setTimeout(resolve, options.delay || 500));\r\n        }\r\n      }\r\n      \r\n      setTxProgress(100);\r\n      setTxStatus(results.success ? 'completed' : 'completed_with_errors');\r\n      \r\n      // Final notification\r\n      setNotification({\r\n        type: results.success ? 'success' : 'warning',\r\n        message: results.success\r\n          ? `Strategy executed successfully! ${results.operations.length} operations completed.`\r\n          : `Strategy execution completed with ${results.failedOperations.length} failures.`\r\n      });\r\n      \r\n      results.endTime = Date.now();\r\n      results.duration = results.endTime - results.startTime;\r\n      \r\n      return results;\r\n    } catch (error) {\r\n      console.error('Strategy execution error:', error);\r\n      \r\n      setTxProgress(100);\r\n      setTxStatus('failed');\r\n      \r\n      setNotification({\r\n        type: 'error',\r\n        message: `Strategy execution failed: ${error.message}`\r\n      });\r\n      \r\n      throw error;\r\n    } finally {\r\n      setExecuting(false);\r\n      setAbortController(null);\r\n    }\r\n  }, [walletAddress, walletProvider, executeOperation, setNotification]);\r\n\r\n  /**\r\n   * Abort the current strategy execution\r\n   */\r\n  const abortExecution = useCallback(() => {\r\n    if (abortController) {\r\n      abortController.abort();\r\n      setNotification({\r\n        type: 'warning',\r\n        message: 'Execution aborted by user'\r\n      });\r\n    }\r\n  }, [abortController, setNotification]);\r\n\r\n  /**\r\n   * Poll for transaction status until confirmed\r\n   * @param {string} txHash - Transaction hash to check\r\n   * @param {number} maxAttempts - Maximum polling attempts\r\n   * @param {number} interval - Polling interval in ms\r\n   * @returns {Promise<Object>} - Transaction status\r\n   */\r\n  const pollTransactionStatus = async (txHash, maxAttempts = 30, interval = 2000) => {\r\n    for (let attempt = 0; attempt < maxAttempts; attempt++) {\r\n      try {\r\n        // Use Aptos explorer API to fetch transaction status\r\n        const response = await fetch(`https://fullnode.${networkType || 'mainnet'}.aptoslabs.com/v1/transactions/by_hash/${txHash}`);\r\n        \r\n        if (!response.ok) {\r\n          console.warn(`Error fetching transaction status: ${response.status}`);\r\n          await new Promise(resolve => setTimeout(resolve, interval));\r\n          continue;\r\n        }\r\n        \r\n        const data = await response.json();\r\n        \r\n        // If transaction is found and has success field, we're done\r\n        if (data && data.success !== undefined) {\r\n          return data;\r\n        }\r\n      } catch (error) {\r\n        console.warn(`Error polling transaction (attempt ${attempt + 1}):`, error.message);\r\n      }\r\n      \r\n      // Wait before checking again\r\n      await new Promise(resolve => setTimeout(resolve, interval));\r\n    }\r\n    \r\n    // If we've reached maximum attempts without conclusion\r\n    throw new Error('Timed out waiting for transaction confirmation');\r\n  };\r\n\r\n  /**\r\n   * Determine if we should abort the entire strategy after an operation fails\r\n   * @param {Object} failedOperation - The operation that failed\r\n   * @param {Object} currentResults - Current execution results\r\n   * @param {Object} options - Strategy execution options\r\n   * @returns {boolean} - Whether to abort\r\n   */\r\n  const shouldAbortStrategy = (failedOperation, currentResults, options) => {\r\n    // Always abort if explicitly marked as critical\r\n    if (failedOperation.critical) {\r\n      return true;\r\n    }\r\n    \r\n    // Check if we've exceeded the failure threshold\r\n    const totalOps = currentResults.operations.length + currentResults.failedOperations.length;\r\n    const failureRate = currentResults.failedOperations.length / totalOps;\r\n    \r\n    // Abort if more than 40% of operations have failed (or custom threshold)\r\n    const failureThreshold = options.failureThreshold || 0.4;\r\n    if (failureRate > failureThreshold && currentResults.failedOperations.length >= 2) {\r\n      return true;\r\n    }\r\n    \r\n    return false;\r\n  };\r\n\r\n  /**\r\n   * Optimize the order of operations for execution\r\n   * @param {Array} operations - Operations to optimize\r\n   * @returns {Array} - Optimized operations\r\n   */\r\n  const optimizeOperationOrder = (operations) => {\r\n    if (!operations || operations.length <= 1) return operations;\r\n    \r\n    // First do all operations that free up APT\r\n    const withdrawTypes = ['unstake', 'withdraw', 'removeliquidity'];\r\n    \r\n    const withdrawOps = operations\r\n      .filter(op => withdrawTypes.includes(op.type.toLowerCase()))\r\n      .sort((a, b) => parseFloat(b.amount) - parseFloat(a.amount));\r\n      \r\n    const addOps = operations\r\n      .filter(op => !withdrawTypes.includes(op.type.toLowerCase()))\r\n      .sort((a, b) => parseFloat(b.amount) - parseFloat(a.amount));\r\n    \r\n    return [...withdrawOps, ...addOps];\r\n  };\r\n\r\n  /**\r\n   * Determine the function name for a protocol operation\r\n   * @param {string} protocol - Protocol name\r\n   * @param {string} operationType - Operation type\r\n   * @returns {string} - Function name\r\n   */\r\n  const determineFunctionName = (protocol, operationType) => {\r\n    const functionMappings = {\r\n      'amnis': { \r\n        'stake': '::staking::stake', \r\n        'unstake': '::staking::unstake', \r\n        'lend': '::lending::supply', \r\n        'withdraw': '::lending::withdraw', \r\n        'addLiquidity': '::router::add_liquidity', \r\n        'removeLiquidity': '::router::remove_liquidity' \r\n      },\r\n      'thala': { \r\n        'stake': '::staking::stake_apt', \r\n        'unstake': '::staking::unstake_apt', \r\n        'lend': '::lending::supply_apt', \r\n        'withdraw': '::lending::withdraw_apt', \r\n        'addLiquidity': '::router::add_liquidity', \r\n        'removeLiquidity': '::router::remove_liquidity' \r\n      },\r\n      'tortuga': { \r\n        'stake': '::staking::stake_apt', \r\n        'unstake': '::staking::unstake_apt' \r\n      },\r\n      'echo': { \r\n        'lend': '::lending::supply', \r\n        'withdraw': '::lending::withdraw' \r\n      },\r\n      'ditto': { \r\n        'stake': '::staking::stake', \r\n        'unstake': '::staking::unstake' \r\n      },\r\n      'aries': { \r\n        'lend': '::lending::supply', \r\n        'withdraw': '::lending::withdraw' \r\n      },\r\n      'cetus': { \r\n        'addLiquidity': '::pool::add_liquidity', \r\n        'removeLiquidity': '::pool::remove_liquidity' \r\n      },\r\n      'pancakeswap': { \r\n        'addLiquidity': '::router::add_liquidity', \r\n        'removeLiquidity': '::router::remove_liquidity',\r\n        'swap': '::router::swap_exact_input' \r\n      },\r\n      'liquidswap': { \r\n        'addLiquidity': '::router::add_liquidity', \r\n        'removeLiquidity': '::router::remove_liquidity' \r\n      }\r\n    };\r\n    \r\n    const protocolLower = protocol.toLowerCase();\r\n    const operationLower = operationType.toLowerCase();\r\n    \r\n    // If we have a specific mapping for this protocol and operation type, use it\r\n    if (functionMappings[protocolLower]?.[operationLower]) {\r\n      return functionMappings[protocolLower][operationLower];\r\n    }\r\n    \r\n    // Otherwise use general mappings\r\n    switch (operationLower) {\r\n      case 'stake': return '::staking::stake';\r\n      case 'unstake': return '::staking::unstake';\r\n      case 'lend': return '::lending::supply';\r\n      case 'withdraw': return '::lending::withdraw';\r\n      case 'addliquidity': return '::router::add_liquidity';\r\n      case 'removeliquidity': return '::router::remove_liquidity';\r\n      case 'deposit': return '::yield::deposit';\r\n      case 'swap': return '::router::swap_exact_input';\r\n      default: return `::${operationLower}::execute`;\r\n    }\r\n  };\r\n\r\n// End of src/hooks/useTransactions.js\r\n  return {\r\n    executeOperation,\r\n    executeStrategy,\r\n    addTransactionToQueue,\r\n    isTransactionPending,\r\n    getTransaction\r\n  };\r\n};\r\n\r\nexport default useTransactions;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}