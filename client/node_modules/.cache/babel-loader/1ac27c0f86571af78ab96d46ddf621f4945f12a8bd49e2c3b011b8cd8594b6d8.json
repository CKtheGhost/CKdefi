{"ast":null,"code":"var _jsxFileName = \"/home/ck/compoundefi/client/src/context/TransactionContext.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n// src/context/TransactionContext.jsx\nimport React, { createContext, useState, useContext, useCallback } from 'react';\nimport { useWalletContext } from './WalletContext';\nimport { useNotification } from './NotificationContext';\nimport { aptosClient } from '../services/walletService';\n\n// Create context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const TransactionContext = /*#__PURE__*/createContext();\nexport const TransactionProvider = ({\n  children\n}) => {\n  _s();\n  const {\n    wallet,\n    isConnected\n  } = useWalletContext();\n  const {\n    showNotification\n  } = useNotification();\n  const [pendingTransactions, setPendingTransactions] = useState([]);\n  const [transactionHistory, setTransactionHistory] = useState([]);\n  const [executing, setExecuting] = useState(false);\n\n  // Execute a single transaction\n  const executeTransaction = useCallback(async (payload, options = {}) => {\n    if (!isConnected || !wallet) {\n      showNotification('Please connect your wallet to execute transactions', 'error');\n      throw new Error('Wallet not connected');\n    }\n    try {\n      var _payload$function;\n      setExecuting(true);\n\n      // Create transaction payload\n      const transaction = {\n        ...payload,\n        sender: wallet.address,\n        options: {\n          maxGasAmount: options.maxGasAmount || 5000,\n          gasUnitPrice: options.gasUnitPrice || 100,\n          ...options\n        }\n      };\n\n      // Add to pending transactions\n      const txId = Date.now().toString();\n      setPendingTransactions(prev => [...prev, {\n        id: txId,\n        payload: transaction,\n        status: 'pending',\n        timestamp: Date.now()\n      }]);\n\n      // Send transaction to wallet for signing\n      const response = await wallet.signAndSubmitTransaction(transaction);\n\n      // Wait for transaction to complete\n      const result = await aptosClient.waitForTransaction(response.hash);\n\n      // Update transaction history\n      const txRecord = {\n        id: txId,\n        hash: response.hash,\n        success: result.success,\n        timestamp: Date.now(),\n        type: ((_payload$function = payload.function) === null || _payload$function === void 0 ? void 0 : _payload$function.split('::').pop()) || 'transaction',\n        gasFee: result.gas_used || 0,\n        payload: transaction\n      };\n      setTransactionHistory(prev => [txRecord, ...prev]);\n\n      // Remove from pending\n      setPendingTransactions(prev => prev.filter(tx => tx.id !== txId));\n\n      // Show notification\n      showNotification(result.success ? 'Transaction completed successfully' : 'Transaction failed', result.success ? 'success' : 'error');\n      return {\n        ...result,\n        hash: response.hash\n      };\n    } catch (error) {\n      console.error('Transaction failed:', error);\n      showNotification(`Transaction failed: ${error.message}`, 'error');\n      throw error;\n    } finally {\n      setExecuting(false);\n    }\n  }, [wallet, isConnected, showNotification]);\n\n  // Execute multiple transactions for a strategy\n  const executeStrategyTransaction = useCallback(async (strategy, options = {}) => {\n    if (!strategy || !strategy.operations || strategy.operations.length === 0) {\n      throw new Error('Invalid strategy: no operations defined');\n    }\n    const results = {\n      success: true,\n      operations: [],\n      failedOperations: [],\n      timestamp: Date.now()\n    };\n\n    // Execute each operation sequentially\n    for (const operation of strategy.operations) {\n      try {\n        // Prepare transaction payload\n        const payload = buildTransactionPayload(operation);\n\n        // Execute transaction\n        const result = await executeTransaction(payload, options);\n\n        // Add to successful operations\n        results.operations.push({\n          ...operation,\n          hash: result.hash,\n          status: 'success'\n        });\n      } catch (error) {\n        console.error(`Operation failed: ${operation.type} on ${operation.protocol}`, error);\n\n        // Add to failed operations\n        results.failedOperations.push({\n          ...operation,\n          error: error.message,\n          status: 'failed'\n        });\n        results.success = false;\n      }\n    }\n    return results;\n  }, [executeTransaction]);\n\n  // Helper to build transaction payload from operation\n  const buildTransactionPayload = operation => {\n    const {\n      protocol,\n      type,\n      amount,\n      contractAddress\n    } = operation;\n\n    // Convert amount to octas (Aptos uses 8 decimal places)\n    const amountInOctas = Math.floor(parseFloat(amount) * 100000000).toString();\n\n    // Build function name based on protocol and operation type\n    const functionName = determineFunctionName(protocol, type);\n    return {\n      function: `${contractAddress}${functionName}`,\n      type_arguments: [],\n      arguments: [amountInOctas]\n    };\n  };\n\n  // Helper to determine function name\n  const determineFunctionName = (protocol, type) => {\n    var _functionMappings$pro;\n    const protocol_lower = protocol.toLowerCase();\n    const functionMappings = {\n      'amnis': {\n        'stake': '::staking::stake',\n        'unstake': '::staking::unstake'\n      },\n      'thala': {\n        'stake': '::staking::stake_apt',\n        'unstake': '::staking::unstake_apt'\n      },\n      'tortuga': {\n        'stake': '::staking::stake_apt',\n        'unstake': '::staking::unstake_apt'\n      },\n      'ditto': {\n        'stake': '::staking::stake',\n        'unstake': '::staking::unstake'\n      }\n      // Add other protocols as needed\n    };\n\n    // If we have a specific mapping for this protocol and operation type, use it\n    if ((_functionMappings$pro = functionMappings[protocol_lower]) !== null && _functionMappings$pro !== void 0 && _functionMappings$pro[type]) {\n      return functionMappings[protocol_lower][type];\n    }\n\n    // Default mappings by operation type\n    switch (type) {\n      case 'stake':\n        return '::staking::stake';\n      case 'unstake':\n        return '::staking::unstake';\n      case 'lend':\n        return '::lending::supply';\n      case 'withdraw':\n        return '::lending::withdraw';\n      case 'addLiquidity':\n        return '::pool::add_liquidity';\n      case 'removeLiquidity':\n        return '::pool::remove_liquidity';\n      default:\n        return `::${type}::execute`;\n    }\n  };\n\n  // Add a transaction to history (for tracking external transactions)\n  const addTransaction = useCallback(transaction => {\n    setTransactionHistory(prev => [transaction, ...prev]);\n  }, []);\n\n  // Clear transaction history\n  const clearTransactionHistory = useCallback(() => {\n    setTransactionHistory([]);\n  }, []);\n  return /*#__PURE__*/_jsxDEV(TransactionContext.Provider, {\n    value: {\n      pendingTransactions,\n      transactionHistory,\n      executing,\n      executeTransaction,\n      executeStrategyTransaction,\n      addTransaction,\n      clearTransactionHistory\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 202,\n    columnNumber: 5\n  }, this);\n};\n\n// Custom hook to use the Transaction context\n_s(TransactionProvider, \"Q06S2QJ6+lo4VTdSOfKUpv6TDHo=\", false, function () {\n  return [useWalletContext, useNotification];\n});\n_c = TransactionProvider;\nexport const useTransaction = () => {\n  _s2();\n  return useContext(TransactionContext);\n};\n_s2(useTransaction, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar _c;\n$RefreshReg$(_c, \"TransactionProvider\");","map":{"version":3,"names":["React","createContext","useState","useContext","useCallback","useWalletContext","useNotification","aptosClient","jsxDEV","_jsxDEV","TransactionContext","TransactionProvider","children","_s","wallet","isConnected","showNotification","pendingTransactions","setPendingTransactions","transactionHistory","setTransactionHistory","executing","setExecuting","executeTransaction","payload","options","Error","_payload$function","transaction","sender","address","maxGasAmount","gasUnitPrice","txId","Date","now","toString","prev","id","status","timestamp","response","signAndSubmitTransaction","result","waitForTransaction","hash","txRecord","success","type","function","split","pop","gasFee","gas_used","filter","tx","error","console","message","executeStrategyTransaction","strategy","operations","length","results","failedOperations","operation","buildTransactionPayload","push","protocol","amount","contractAddress","amountInOctas","Math","floor","parseFloat","functionName","determineFunctionName","type_arguments","arguments","_functionMappings$pro","protocol_lower","toLowerCase","functionMappings","addTransaction","clearTransactionHistory","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useTransaction","_s2","$RefreshReg$"],"sources":["/home/ck/compoundefi/client/src/context/TransactionContext.jsx"],"sourcesContent":["// src/context/TransactionContext.jsx\r\nimport React, { createContext, useState, useContext, useCallback } from 'react';\r\nimport { useWalletContext } from './WalletContext';\r\nimport { useNotification } from './NotificationContext';\r\nimport { aptosClient } from '../services/walletService';\r\n\r\n// Create context\r\nexport const TransactionContext = createContext();\r\n\r\nexport const TransactionProvider = ({ children }) => {\r\n  const { wallet, isConnected } = useWalletContext();\r\n  const { showNotification } = useNotification();\r\n  \r\n  const [pendingTransactions, setPendingTransactions] = useState([]);\r\n  const [transactionHistory, setTransactionHistory] = useState([]);\r\n  const [executing, setExecuting] = useState(false);\r\n\r\n  // Execute a single transaction\r\n  const executeTransaction = useCallback(async (payload, options = {}) => {\r\n    if (!isConnected || !wallet) {\r\n      showNotification('Please connect your wallet to execute transactions', 'error');\r\n      throw new Error('Wallet not connected');\r\n    }\r\n\r\n    try {\r\n      setExecuting(true);\r\n      \r\n      // Create transaction payload\r\n      const transaction = {\r\n        ...payload,\r\n        sender: wallet.address,\r\n        options: {\r\n          maxGasAmount: options.maxGasAmount || 5000,\r\n          gasUnitPrice: options.gasUnitPrice || 100,\r\n          ...options\r\n        }\r\n      };\r\n\r\n      // Add to pending transactions\r\n      const txId = Date.now().toString();\r\n      setPendingTransactions(prev => [...prev, { \r\n        id: txId, \r\n        payload: transaction, \r\n        status: 'pending',\r\n        timestamp: Date.now()\r\n      }]);\r\n\r\n      // Send transaction to wallet for signing\r\n      const response = await wallet.signAndSubmitTransaction(transaction);\r\n      \r\n      // Wait for transaction to complete\r\n      const result = await aptosClient.waitForTransaction(response.hash);\r\n      \r\n      // Update transaction history\r\n      const txRecord = {\r\n        id: txId,\r\n        hash: response.hash,\r\n        success: result.success,\r\n        timestamp: Date.now(),\r\n        type: payload.function?.split('::').pop() || 'transaction',\r\n        gasFee: result.gas_used || 0,\r\n        payload: transaction\r\n      };\r\n      \r\n      setTransactionHistory(prev => [txRecord, ...prev]);\r\n      \r\n      // Remove from pending\r\n      setPendingTransactions(prev => prev.filter(tx => tx.id !== txId));\r\n      \r\n      // Show notification\r\n      showNotification(\r\n        result.success \r\n          ? 'Transaction completed successfully' \r\n          : 'Transaction failed',\r\n        result.success ? 'success' : 'error'\r\n      );\r\n      \r\n      return { ...result, hash: response.hash };\r\n    } catch (error) {\r\n      console.error('Transaction failed:', error);\r\n      showNotification(`Transaction failed: ${error.message}`, 'error');\r\n      throw error;\r\n    } finally {\r\n      setExecuting(false);\r\n    }\r\n  }, [wallet, isConnected, showNotification]);\r\n\r\n  // Execute multiple transactions for a strategy\r\n  const executeStrategyTransaction = useCallback(async (strategy, options = {}) => {\r\n    if (!strategy || !strategy.operations || strategy.operations.length === 0) {\r\n      throw new Error('Invalid strategy: no operations defined');\r\n    }\r\n    \r\n    const results = {\r\n      success: true,\r\n      operations: [],\r\n      failedOperations: [],\r\n      timestamp: Date.now()\r\n    };\r\n    \r\n    // Execute each operation sequentially\r\n    for (const operation of strategy.operations) {\r\n      try {\r\n        // Prepare transaction payload\r\n        const payload = buildTransactionPayload(operation);\r\n        \r\n        // Execute transaction\r\n        const result = await executeTransaction(payload, options);\r\n        \r\n        // Add to successful operations\r\n        results.operations.push({\r\n          ...operation,\r\n          hash: result.hash,\r\n          status: 'success'\r\n        });\r\n      } catch (error) {\r\n        console.error(`Operation failed: ${operation.type} on ${operation.protocol}`, error);\r\n        \r\n        // Add to failed operations\r\n        results.failedOperations.push({\r\n          ...operation,\r\n          error: error.message,\r\n          status: 'failed'\r\n        });\r\n        \r\n        results.success = false;\r\n      }\r\n    }\r\n    \r\n    return results;\r\n  }, [executeTransaction]);\r\n\r\n  // Helper to build transaction payload from operation\r\n  const buildTransactionPayload = (operation) => {\r\n    const { protocol, type, amount, contractAddress } = operation;\r\n    \r\n    // Convert amount to octas (Aptos uses 8 decimal places)\r\n    const amountInOctas = Math.floor(parseFloat(amount) * 100000000).toString();\r\n    \r\n    // Build function name based on protocol and operation type\r\n    const functionName = determineFunctionName(protocol, type);\r\n    \r\n    return {\r\n      function: `${contractAddress}${functionName}`,\r\n      type_arguments: [],\r\n      arguments: [amountInOctas]\r\n    };\r\n  };\r\n\r\n  // Helper to determine function name\r\n  const determineFunctionName = (protocol, type) => {\r\n    const protocol_lower = protocol.toLowerCase();\r\n    \r\n    const functionMappings = {\r\n      'amnis': { \r\n        'stake': '::staking::stake', \r\n        'unstake': '::staking::unstake'\r\n      },\r\n      'thala': { \r\n        'stake': '::staking::stake_apt', \r\n        'unstake': '::staking::unstake_apt'\r\n      },\r\n      'tortuga': { \r\n        'stake': '::staking::stake_apt', \r\n        'unstake': '::staking::unstake_apt'\r\n      },\r\n      'ditto': { \r\n        'stake': '::staking::stake', \r\n        'unstake': '::staking::unstake'\r\n      }\r\n      // Add other protocols as needed\r\n    };\r\n\r\n    // If we have a specific mapping for this protocol and operation type, use it\r\n    if (functionMappings[protocol_lower]?.[type]) {\r\n      return functionMappings[protocol_lower][type];\r\n    }\r\n\r\n    // Default mappings by operation type\r\n    switch (type) {\r\n      case 'stake': return '::staking::stake';\r\n      case 'unstake': return '::staking::unstake';\r\n      case 'lend': return '::lending::supply';\r\n      case 'withdraw': return '::lending::withdraw';\r\n      case 'addLiquidity': return '::pool::add_liquidity';\r\n      case 'removeLiquidity': return '::pool::remove_liquidity';\r\n      default: return `::${type}::execute`;\r\n    }\r\n  };\r\n\r\n  // Add a transaction to history (for tracking external transactions)\r\n  const addTransaction = useCallback((transaction) => {\r\n    setTransactionHistory(prev => [transaction, ...prev]);\r\n  }, []);\r\n\r\n  // Clear transaction history\r\n  const clearTransactionHistory = useCallback(() => {\r\n    setTransactionHistory([]);\r\n  }, []);\r\n\r\n  return (\r\n    <TransactionContext.Provider\r\n      value={{\r\n        pendingTransactions,\r\n        transactionHistory,\r\n        executing,\r\n        executeTransaction,\r\n        executeStrategyTransaction,\r\n        addTransaction,\r\n        clearTransactionHistory\r\n      }}\r\n    >\r\n      {children}\r\n    </TransactionContext.Provider>\r\n  );\r\n};\r\n\r\n// Custom hook to use the Transaction context\r\nexport const useTransaction = () => useContext(TransactionContext);"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}